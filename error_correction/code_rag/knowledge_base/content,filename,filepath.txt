content,filename,filepath
"[Keyword]: adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements an 8-bit binary adder. It takes two 8-bit binary numbers as inputs and produces an 8-bit sum and a carry-out as outputs.

[Input Signal Description]:
a[7:0]: An 8-bit input signal representing the first operand for the addition.
b[7:0]: An 8-bit input signal representing the second operand for the addition.

[Output Signal Description]:
s[7:0]: An 8-bit output signal representing the sum of the two input operands.
c: A 1-bit output signal representing the carry-out from the most significant bit of the addition.


[Design Detail]:
//Adder
 
 module adder(a,b,c,s);
 input [7:0] a,b;
 output [7:0] s;
 output c; 
 assign {c,s}=a+b;
 endmodule
",adder.txt,32-Verilog-Mini-Projects\adder.txt
"[Keyword]: adder32

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 32-bit binary adder with carry-in and carry-out functionality. It takes two 32-bit binary numbers and an additional carry-in bit as inputs, and produces a 32-bit sum and a carry-out bit as outputs.

[Input Signal Description]:
- A[31:0]: A 32-bit input operand for the addition.
- B[31:0]: Another 32-bit input operand for the addition.
- Ci: A single-bit carry-in input that is added to the sum of A and B.

[Output Signal Description]:
- S[31:0]: A 32-bit output representing the sum of the inputs A, B, and the carry-in Ci.
- Co: A single-bit carry-out output that indicates an overflow from the most significant bit of the sum.


[Design Detail]:
module Adder32 (A, B, Ci, S, Co);

input[31:0] A;
input[31:0] B;
input Ci;
output[31:0] S;
output Co;
wire[32:0] Sum33;
assign Sum33 = A + B + Ci ;
assign S = Sum33[31:0] ;
assign Co = Sum33[32] ;
endmodule
",adder32.txt,32-Verilog-Mini-Projects\adder32.txt
"[Keyword]: Addition_Subtraction

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a floating-point addition and subtraction circuit. It includes a priority encoder to normalize the significand after subtraction and handles both addition and subtraction of two 32-bit floating-point numbers. The circuit also checks for exceptions such as overflow or invalid operations.

[Input Signal Description]:
- `a[31:0]`: 32-bit floating-point input operand A.
- `b[31:0]`: 32-bit floating-point input operand B.
- `add_sub_signal`: Control signal to determine the operation; 1 for subtraction and 0 for addition.

[Output Signal Description]:
- `res[31:0]`: 32-bit floating-point result of the addition or subtraction.
- `exception`: A flag indicating if an exception occurred during the operation, such as overflow or invalid operation.


[Design Detail]:
module priority_encoder(
			input [24:0] significand,
			input [7:0] exp_a,
			output reg [24:0] Significand,
			output [7:0] exp_sub
			);

reg [4:0] shift;

always @(significand)
begin
	casex (significand)
		25'b1_1xxx_xxxx_xxxx_xxxx_xxxx_xxxx :	begin
													Significand = significand;
									 				shift = 5'd0;
								 			  	end
		25'b1_01xx_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 1;
									 				shift = 5'd1;
								 			  	end

		25'b1_001x_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 2;
									 				shift = 5'd2;
								 				end

		25'b1_0001_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin 							
													Significand = significand << 3;
								 	 				shift = 5'd3;
								 				end

		25'b1_0000_1xxx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 4;
								 	 				shift = 5'd4;
								 				end

		25'b1_0000_01xx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 5;
								 	 				shift = 5'd5;
								 				end

		25'b1_0000_001x_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h020000
									 				Significand = significand << 6;
								 	 				shift = 5'd6;
								 				end

		25'b1_0000_0001_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h010000
									 				Significand = significand << 7;
								 	 				shift = 5'd7;
								 				end

		25'b1_0000_0000_1xxx_xxxx_xxxx_xxxx : 	begin						// 24'h008000
									 				Significand = significand << 8;
								 	 				shift = 5'd8;
								 				end

		25'b1_0000_0000_01xx_xxxx_xxxx_xxxx : 	begin						// 24'h004000
									 				Significand = significand << 9;
								 	 				shift = 5'd9;
								 				end

		25'b1_0000_0000_001x_xxxx_xxxx_xxxx : 	begin						// 24'h002000
									 				Significand = significand << 10;
								 	 				shift = 5'd10;
								 				end

		25'b1_0000_0000_0001_xxxx_xxxx_xxxx : 	begin						// 24'h001000
									 				Significand = significand << 11;
								 	 				shift = 5'd11;
								 				end

		25'b1_0000_0000_0000_1xxx_xxxx_xxxx : 	begin						// 24'h000800
									 				Significand = significand << 12;
								 	 				shift = 5'd12;
								 				end

		25'b1_0000_0000_0000_01xx_xxxx_xxxx : 	begin						// 24'h000400
									 				Significand = significand << 13;
								 	 				shift = 5'd13;
								 				end

		25'b1_0000_0000_0000_001x_xxxx_xxxx : 	begin						// 24'h000200
									 				Significand = significand << 14;
								 	 				shift = 5'd14;
								 				end

		25'b1_0000_0000_0000_0001_xxxx_xxxx  : 	begin						// 24'h000100
									 				Significand = significand << 15;
								 	 				shift = 5'd15;
								 				end

		25'b1_0000_0000_0000_0000_1xxx_xxxx : 	begin						// 24'h000080
									 				Significand = significand << 16;
								 	 				shift = 5'd16;
								 				end

		25'b1_0000_0000_0000_0000_01xx_xxxx : 	begin						// 24'h000040
											 		Significand = significand << 17;
										 	 		shift = 5'd17;
												end

		25'b1_0000_0000_0000_0000_001x_xxxx : 	begin						// 24'h000020
									 				Significand = significand << 18;
								 	 				shift = 5'd18;
								 				end

		25'b1_0000_0000_0000_0000_0001_xxxx : 	begin						// 24'h000010
									 				Significand = significand << 19;
								 	 				shift = 5'd19;
												end

		25'b1_0000_0000_0000_0000_0000_1xxx :	begin						// 24'h000008
									 				Significand = significand << 20;
								 					shift = 5'd20;
								 				end

		25'b1_0000_0000_0000_0000_0000_01xx : 	begin						// 24'h000004
									 				Significand = significand << 21;
								 	 				shift = 5'd21;
								 				end

		25'b1_0000_0000_0000_0000_0000_001x : 	begin						// 24'h000002
									 				Significand = significand << 22;
								 	 				shift = 5'd22;
								 				end

		25'b1_0000_0000_0000_0000_0000_0001 : 	begin						// 24'h000001
									 				Significand = significand << 23;
								 	 				shift = 5'd23;
								 				end

		25'b1_0000_0000_0000_0000_0000_0000 : 	begin						// 24'h000000
								 					Significand = significand << 24;
							 	 					shift = 5'd24;
								 				end
		default : 	begin
						Significand = (~significand) + 1'b1;
						shift = 8'd0;
					end

	endcase
end
assign exp_sub = exp_a - shift;

endmodule

module Addition_Subtraction(input [31:0] a,b,
input add_sub_signal,														// If 1 then addition otherwise subtraction
output exception,
output [31:0] res );

wire operation_add_sub_signal;
wire enable;
wire output_sign;

wire [31:0] op_a,op_b;
wire [23:0] significand_a,significand_b;
wire [7:0] exp_diff;


wire [23:0] significand_b_add_sub;
wire [7:0] exp_b_add_sub;

wire [24:0] significand_add;
wire [30:0] add_sum;

wire [23:0] significand_sub_complement;
wire [24:0] significand_sub;
wire [30:0] sub_diff;
wire [24:0] subtraction_diff; 
wire [7:0] exp_sub;

assign {enable,op_a,op_b} = (a[30:0] < b[30:0]) ? {1'b1,b,a} : {1'b0,a,b};							// For operations always op_a must not be less than b

assign exp_a = op_a[30:23];
assign exp_b = op_b[30:23];

assign exception = (&op_a[30:23]) | (&op_b[30:23]) | (add_sub_signal ? ((|(op_a[30:0] ^ op_b[30:0])) || ~(op_a[31] ^ op_b[31])) : |(op_a ^ op_b));										// Exception flag sets 1 if either one of the exponent is 255.

assign output_sign = add_sub_signal ? enable ? !op_a[31] : op_a[31] : op_a[31] ;

assign operation_add_sub_signal = add_sub_signal ? op_a[31] ^ op_b[31] : ~(op_a[31] ^ op_b[31]);
																// Assign significand values according to Hidden Bit.
assign significand_a = (|op_a[30:23]) ? {1'b1,op_a[22:0]} : {1'b0,op_a[22:0]};							// If exponent is zero,hidden bit = 0,else 1
assign significand_b = (|op_b[30:23]) ? {1'b1,op_b[22:0]} : {1'b0,op_b[22:0]};

assign exp_diff = op_a[30:23] - op_b[30:23];											// Exponent difference calculation
assign significand_b_add_sub = significand_b >> exp_diff;
assign exp_b_add_sub = op_b[30:23] + exp_diff; 

assign perform = (op_a[30:23] == exp_b_add_sub);										// Checking if exponents are same


// Add Block //
assign significand_add = (perform & operation_add_sub_signal) ? (significand_a + significand_b_add_sub) : 25'd0; 

assign add_sum[22:0] = significand_add[24] ? significand_add[23:1] : significand_add[22:0];					// res will be most 23 bits if carry generated, else least 22 bits.

assign add_sum[30:23] = significand_add[24] ? (1'b1 + op_a[30:23]) : op_a[30:23];						// If carry generates in sum value then exponent is added with 1 else feed as it is.

// Sub Block //
assign significand_sub_complement = (perform & !operation_add_sub_signal) ? ~(significand_b_add_sub) + 24'd1 : 24'd0 ; 

assign significand_sub = perform ? (significand_a + significand_sub_complement) : 25'd0;

priority_encoder pe(significand_sub,op_a[30:23],subtraction_diff,exp_sub);

assign sub_diff[30:23] = exp_sub;

assign sub_diff[22:0] = subtraction_diff[22:0];

// Output //
assign res = exception ? 32'b0 : ((!operation_add_sub_signal) ? {output_sign,sub_diff} : {output_sign,add_sum});

endmodule


module Addition_Subtraction_tb;

reg [31:0] a,b;
reg clk=1'b0,
	reset =1'b1;
reg add_sub_signal;

wire [31:0] res;
wire exception;

Addition_Subtraction dut(a,b,add_sub_signal,exception,res);

always #5 clk = ~clk;

initial
begin

add_sub_signal = 1'b0;

iteration (32'h4201_51EC,32'h4242_147B,32'h42A1_B333,`__LINE__); //32.33 + 48.52 = 80.85

iteration (32'h4068_51EC,32'h4090_A3D7,32'h4102_6666,`__LINE__); //3.63 + 4.52 = 8.15.

iteration (32'h4195_0A3D,32'h419B_47AE,32'h4218_28F6,`__LINE__); //18.63 + 19.41 = 38.04.

iteration (32'h4217_999A,32'h3F8C_CCCD,32'h421C_0000,`__LINE__); //37.9 + 1.1 = 39.

iteration (32'h4383_C7AE,32'h4164_F5C3,32'h438A_EF5C,`__LINE__); //263.56 + 14.31 = 277.87

iteration (32'h4542_77D7,32'h453B_8FD7,32'h45BF_03D7,`__LINE__); //3111.49 + 3000.99 = 6112.48

iteration (32'h3F3A_E148,32'h3EB33333,32'h3F8A_3D71,`__LINE__); //0.73 + 0.35 = 1.08.

iteration (32'h3F7D_70A4,32'h3F7D_70A4,32'h3FFD_70A4,`__LINE__); //0.99 + 0.99 = 1.98

iteration (32'h3F40_0000,32'h3E94_7AE1,32'h3F85_1EB8,`__LINE__); //0.75 + 0.29 = 1.04

iteration (32'h4B7F_FFFF,32'h3F80_0000,32'h4B80_0000,`__LINE__); //16777215 + 1 = 16777216
								 // Corner Case

iteration (32'h4B7F_FFFF,32'h4000_0000,32'h4B80_0001,`__LINE__); //16777215 + 2 = 16777217.
								 // Corner Case

iteration (32'h4B7F_FFFF,32'h4B7F_FFFF,32'h4BFF_FFFF,`__LINE__); //16777215 + 16777215 = 33554430
								 // Working

iteration (32'h4B7F_FFFE,32'h3F80_0000,32'h4B7F_FFFF,`__LINE__); //16777214 + 1 = 16777215

iteration (32'hBF3A_E148,32'h3EC7_AE14,32'hBEAE_147B,`__LINE__); //-0.73 + 0.39 = -0.34

iteration (32'hC207_C28F,32'h4243_B852,32'h416F_D70A,`__LINE__); //-33.94 + 48.93 = 14.99

iteration (32'hBDB2_2D0E,32'h4305_970A,32'h4305_80C5,`__LINE__); //-0.087 + 133.59 = 133.503

iteration (32'h4E6B_79A3,32'hCCEB_79A3,32'h4E4E_0A6F,`__LINE__); //987654321 - 123456789 = 864197532

iteration (32'h4B80_0000,32'hCB80_0000,32'h0000_0000,`__LINE__); //16777216 - 16777216 = 0

iteration (32'h4B7F_FFFF,32'hCB7F_FFFF,32'h0000_0000,`__LINE__); //16777215 - 16777215 = 0

// Subtraction //

add_sub_signal = 1'b1;

iteration (32'h40A00000,32'h40C00000,32'hBF800000,`__LINE__); //5 - 6 = -1

iteration (32'h40C00000,32'h40A00000,32'h3F800000,`__LINE__); //6 - 5 = 1

iteration (32'hC0C00000,32'hC0A00000,32'hBF800000,`__LINE__); //-6 - (-5) = -1

iteration (32'hC0A00000,32'hC0C00000,32'h3F800000,`__LINE__); // -5 - (-6) = 1

iteration (32'h40C00000,32'hC0A00000,32'h41300000,`__LINE__); // 6 - (-5) = 11

iteration (32'h40A00000,32'hC0C00000,32'h41300000,`__LINE__); // 5 - (-6) = 11

iteration (32'hC0A00000,32'h40C00000,32'hC1300000,`__LINE__); // -5 - (6) = -11

iteration (32'hC0C00000,32'h40A00000,32'hC1300000,`__LINE__); // -6 - (+5) = -11

// Exception Cases //

iteration (32'h0000_0000,32'h3EC7_AE14,32'h3EC7_AE14,`__LINE__);

iteration (32'h3EC7_AE14,32'h0000_0000,32'h3EC7_AE14,`__LINE__);

iteration (32'h0000_0000,32'h0000_0000,32'h0000_0000,`__LINE__);

iteration (32'h7F80_0000,32'h7F90_0100,32'h0000_0000,`__LINE__);

iteration (32'h7F80_0000,32'h3EC7_AE14,32'h0000_0000,`__LINE__);

iteration (32'h3EC7_AE14,32'h7F80_0000,32'h0000_0000,`__LINE__);

iteration (32'h7F80_0000,32'h0000_0000,32'h0000_0000,`__LINE__);

iteration (32'h7F90_0100,32'h7F80_0000,32'h0000_0000,`__LINE__);

@(negedge clk)
$stop;

end

task iteration(
input [31:0] op_a,op_b,expected_value,
input integer line_num );

begin
	@(negedge clk)
	begin
		a = op_a;
		b = op_b;
	end

	@(posedge clk)
	begin
		#1;
		if (expected_value == res)
			$display (""Success: Line Number -> %d"",line_num);
		else 
			$display (""Failed: \t\n A => %h, \t\n B => %h, \t\n Result Obtained => %h, \t\n Expected Value => %h - Line Number"",op_a,op_b,res,expected_value,line_num);
	end
end
endtask

endmodule
",Addition_Subtraction.txt,32-Verilog-Mini-Projects\Addition_Subtraction.txt
"[Keyword]: array_multiplier

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a hierarchical array multiplier for multiplying two 16-bit binary numbers. It uses smaller array multipliers (2-bit, 4-bit, and 8-bit) as building blocks to construct the 16-bit multiplier. The final output is a 32-bit product of the two 16-bit input numbers.

[Input Signal Description]:
- `a[15:0]`: A 16-bit input operand for the multiplication.
- `b[15:0]`: Another 16-bit input operand for the multiplication.

[Output Signal Description]:
- `c[31:0]`: A 32-bit output representing the product of the two 16-bit input operands `a` and `b`.


[Design Detail]:
module array16(a,b,c);
 
    input [15:0]a,b;
    output [31:0]c;
     
    wire [15:0]q0,q1,q2,q3,q4,temp1;
    wire [31:0]c;
    wire [23:0]q5,q6,temp2,temp3,temp4;
     
    array8 z1(a[7:0],b[7:0],q0[15:0]);
    array8 z2(a[15:8],b[7:0],q1[15:0]);
    array8 z3(a[7:0],b[15:8],q2[15:0]);
    array8 z4(a[15:8],b[15:8],q3[15:0]);
    assign temp1 ={8'b0,q0[15:8]};
    assign q4 = q1[15:0]+temp1;
    assign temp2 ={8'b0,q2[15:0]};
    assign temp3 ={q3[15:0],8'b0};
    assign q5 = temp2+temp3;
    assign temp4={8'b0,q4[15:0]};
     
    assign q6 = temp4 + q5;
     
    assign c[7:0]=q0[7:0];
    assign c[31:8]=q6[23:0];
 
endmodule
 
module array2(a, b, c);
    input [1:0]a, b;
    output [3:0]c;
    wire [3:0]c, temp;
     
    assign c[0]=a[0]&b[0];
    assign temp[0]=a[1]&b[0];
    assign temp[1]=a[0]&b[1];
    assign temp[2]=a[1]&b[1];
    ha z1(temp[0],temp[1],c[1],temp[3]);
    ha z2(temp[2],temp[3],c[2],c[3]);
 
endmodule
 
module array4(a,b,c);
    input [3:0]a, b;
    output [7:0]c;
     
    wire [3:0]q0,q1,q2,q3,q4,temp1;
     
    wire [7:0]c;
    wire [5:0]q5,q6,temp2,temp3,temp4;
     
    array2 z1(a[1:0],b[1:0],q0[3:0]);
    array2 z2(a[3:2],b[1:0],q1[3:0]);
    array2 z3(a[1:0],b[3:2],q2[3:0]);
    array2 z4(a[3:2],b[3:2],q3[3:0]);
     
    assign temp1 ={2'b0,q0[3:2]};
    assign q4 = q1[3:0]+temp1;
    assign temp2 ={2'b0,q2[3:0]};
    assign temp3 ={q3[3:0],2'b0};
    assign q5 = temp2+temp3;
    assign temp4={2'b0,q4[3:0]};
    assign q6 = temp4+q5;
     
    assign c[1:0]=q0[1:0];
    assign c[7:2]=q6[5:0];
endmodule
 
module array8(a,b,c);
    input [7:0]a,b;
    output [15:0]c;
     
    wire [15:0]q0,q1,q2,q3,c;
    wire [7:0]q4,temp1;
    wire [11:0]q5,q6,temp2temp3,temp4;
     
    array4 z1(a[3:0],b[3:0],q0[15:0]);
    array4 z2(a[7:4],b[3:0],q1[15:0]);
    array4 z3(a[3:0],b[7:4],q2[15:0]);
    array4 z4(a[7:4],b[7:4],q3[15:0]);
     
    assign temp1 ={4'b0,q0[7:4]};
    assign q4 = q1[7:0]+temp1;
    assign temp2 ={4'b0,q2[7:0]};
    assign temp3 ={q3[7:0],4'b0};
    assign q5 = temp2+temp3;
    assign temp4={4'b0,q4[7:0]};
     
    
    assign q6 = temp4+q5;
     
    assign c[3:0]=q0[3:0];
    assign c[15:4]=q6[11:0];
endmodule
 
module ha(a,b,s,c);
    input a,b;
    output s,c;
     
    assign s = a^b;
    assign c = a&b;
endmodule
",array_multiplier.txt,32-Verilog-Mini-Projects\array_multiplier.txt
"[Keyword]: barrel_shifter_8bit

[Design Category]: Combinational Logic

[Design Function Description]:
The design is an 8-bit barrel shifter that performs right shifts on an 8-bit input vector. The amount of shift is controlled by a 3-bit control signal, allowing for shifts from 0 to 7 positions to the right.

[Input Signal Description]:
- `in[7:0]`: 8-bit input signal that represents the data to be shifted.
- `ctrl[2:0]`: 3-bit control signal that determines the number of positions the input data is shifted to the right. Each bit in `ctrl` corresponds to a different level of shifting (4-bit, 2-bit, and 1-bit shifts).

[Output Signal Description]:
- `out[7:0]`: 8-bit output signal that represents the shifted result of the input data based on the control signal.


[Design Detail]:
module barrel_shifter_8bit (in, ctrl, out);
  input  [7:0] in;
  input [2:0] ctrl;
  output [7:0] out;
  wire [7:0] x,y;
 
//4bit shift right
mux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));
mux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));
mux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));
mux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));
mux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));
mux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));
mux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));
mux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));
 
//2 bit shift right
 
mux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));
mux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));
mux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));
mux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));
mux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));
mux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));
mux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));
mux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));
 
//1 bit shift right
mux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));
mux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));
mux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));
mux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));
mux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));
mux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));
mux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));
mux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));

endmodule
",barrel_shifter_8bit.txt,32-Verilog-Mini-Projects\barrel_shifter_8bit.txt
"[Keyword]: bcd_adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design is a Binary Coded Decimal (BCD) adder. It takes two 4-bit BCD numbers and an optional carry-in bit as inputs, and produces a 4-bit BCD sum and a carry-out bit. If the sum of the inputs exceeds 9, it adjusts the result by adding 6 to ensure the output remains a valid BCD number.

[Input Signal Description]:
- a[3:0]: A 4-bit input representing the first BCD number.
- b[3:0]: A 4-bit input representing the second BCD number.
- cin: A 1-bit input representing the carry-in from a previous addition.

[Output Signal Description]:
- sum[3:0]: A 4-bit output representing the BCD sum of the inputs.
- cout: A 1-bit output representing the carry-out, indicating if the sum exceeded the BCD range.


[Design Detail]:
module bcd_adder(a,b,cin,sum,cout);
    input [3:0] a,b;
    input cin;
    output [3:0] sum;
    output cout;
    reg [4:0] temp;
    reg [3:0] sum;
    reg cout;  

    always @(a,b,cin)
    begin
        temp = a+b+cin; 
        if(temp > 9)    
	begin
            temp = temp+6; //add 6, if result is more than 9.
            cout = 1;  //set the carry output
            sum = temp[3:0];   
   	end
        else    
	begin
            cout = 0;
            sum = temp[3:0];
        end
    end     

endmodule


module tb_bcdadder;

    reg [3:0] a;
    reg [3:0] b;
    reg cin;

    wire [3:0] sum;
    wire cout;

    bcd_adder uut (
        .a(a), 
        .b(b), 
        .cin(cin), 
        .sum(sum), 
        .cout(cout)
    );

    initial begin
        a = 0;  b = 0;  cin = 0;   #100;
        a = 6;  b = 9;  cin = 0;   #100;
        a = 3;  b = 3;  cin = 1;   #100;
        a = 4;  b = 5;  cin = 0;   #100;
        a = 8;  b = 2;  cin = 0;   #100;
        a = 9;  b = 9;  cin = 1;   #100;
    end
      
endmodule
",bcd_adder.txt,32-Verilog-Mini-Projects\bcd_adder.txt
"[Keyword]: binary_divider

It seems like you haven't provided a specific Verilog design for analysis. Please provide the Verilog code or design details, and I will be able to help you categorize and describe the design accordingly.
[Design Detail]:

",binary_divider.txt,32-Verilog-Mini-Projects\binary_divider.txt
"[Keyword]: booth_multiplication

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements various basic logic gates and arithmetic operations, including addition, subtraction, and multiplication using Booth's algorithm. The primary focus is on performing signed multiplication of two 8-bit numbers using Booth's multiplication technique, which is efficient for binary multiplication.

[Input Signal Description]:
- For the `invert`, `and2`, `or2`, `xor2`, `nand2`, `nor2`, `xnor2`, `and3`, `or3`, `nor3`, `nand3`, `xor3`, `xnor3` modules: These modules take basic binary inputs (i0, i1, i2) to perform logical operations.
- For the `fa` (full adder) module: Inputs are `i0`, `i1`, and `cin` (carry-in) for bitwise addition.
- For the `Adder` and `subtractor` modules: Inputs are two 8-bit numbers `a` and `b`.
- For the `booth_substep` module: Inputs are an 8-bit accumulator `a`, an 8-bit multiplicand `Q`, a single bit `q0`, and an 8-bit multiplier `m`.
- For the `boothmul` module: Inputs are two signed 8-bit numbers `a` and `b`.

[Output Signal Description]:
- For the basic logic gate modules: Outputs are the results of the respective logical operations.
- For the `fa` module: Outputs are `sum` (result of addition) and `cout` (carry-out).
- For the `Adder` and `subtractor` modules: Output is an 8-bit `sum` representing the result of addition or subtraction.
- For the `booth_substep` module: Outputs are `f8` and `l8`, which are intermediate results of the Booth's multiplication step, and `cq0`, which is the updated q0 bit.
- For the `boothmul` module: Output is a 16-bit signed number `c`, which is the product of the two input numbers.


[Design Detail]:
module invert(output ib,input b);
	assign ib = ~b;
endmodule

module and2 (input wire i0, i1, output wire o);
  assign o = i0 & i1;
endmodule

module or2 (input wire i0, i1, output wire o);
  assign o = i0 | i1;
endmodule

module xor2 (input wire i0, i1, output wire o);
  assign o = i0 ^ i1;
endmodule

module nand2 (input wire i0, i1, output wire o);
   wire t;
   and2 and2_0 (i0, i1, t);
   invert invert_0 (t, o);
endmodule

module nor2 (input wire i0, i1, output wire o);
   wire t;
   or2 or2_0 (i0, i1, t);
   invert invert_0 (t, o);
endmodule

module xnor2 (input wire i0, i1, output wire o);
   wire t;
   xor2 xor2_0 (i0, i1, t);
   invert invert_0 (t, o);
endmodule

module and3 (input wire i0, i1, i2, output wire o);
   wire t;
   and2 and2_0 (i0, i1, t);
   and2 and2_1 (i2, t, o);
endmodule

module or3 (input wire i0, i1, i2, output wire o);
   wire t;
   or2 or2_0 (i0, i1, t);
   or2 or2_1 (i2, t, o);
endmodule

module nor3 (input wire i0, i1, i2, output wire o);
   wire t;
   or2 or2_0 (i0, i1, t);
   nor2 nor2_0 (i2, t, o);
endmodule

module nand3 (input wire i0, i1, i2, output wire o);
   wire t;
   and2 and2_0 (i0, i1, t);
   nand2 nand2_1 (i2, t, o);
endmodule

module xor3 (input wire i0, i1, i2, output wire o);
   wire t;
   xor2 xor2_0 (i0, i1, t);
   xor2 xor2_1 (i2, t, o);
endmodule

module xnor3 (input wire i0, i1, i2, output wire o);
   wire t;
   xor2 xor2_0 (i0, i1, t);
   xnor2 xnor2_0 (i2, t, o);
endmodule



module fa (input wire i0, i1, cin, output wire sum, cout);
   wire t0, t1, t2;
   xor3 _i0 (i0, i1, cin, sum);
   and2 _i1 (i0, i1, t0);
   and2 _i2 (i1, cin, t1);
   and2 _i3 (cin, i0, t2);
   or3 _i4 (t0, t1, t2, cout);
endmodule


module Adder(a,b,sum);
	input [7:0] a,b;
	output [7:0]sum;
	wire cout;
	wire [7:0] q;
	fa fa1(a[0],b[0],1'b0,sum[0],q[0]);
	fa fa2(a[1],b[1],q[0],sum[1],q[1]);
	fa fa3(a[2],b[2],q[1],sum[2],q[2]);
	fa fa4(a[3],b[3],q[2],sum[3],q[3]);
	fa fa5(a[4],b[4],q[3],sum[4],q[4]);
	fa fa6(a[5],b[5],q[4],sum[5],q[5]);
	fa fa7(a[6],b[6],q[5],sum[6],q[6]);
	fa fa8(a[7],b[7],q[6],sum[7],cout);
	
endmodule

module subtractor(a,b,sum);
	input [7:0] a,b;
	output [7:0]sum;
	wire [7:0] ib;
	wire cout;
	invert b1(ib[0],b[0]);
	invert b2(ib[1],b[1]);
	invert b3(ib[2],b[2]);
	invert b4(ib[3],b[3]);
	invert b5(ib[4],b[4]);
	invert b6(ib[5],b[5]);
	invert b7(ib[6],b[6]);
	invert b8(ib[7],b[7]);

	wire [7:0] q;
	fa fa1(a[0],ib[0],1'b1,sum[0],q[0]);
	fa fa2(a[1],ib[1],q[0],sum[1],q[1]);
	fa fa3(a[2],ib[2],q[1],sum[2],q[2]);
	fa fa4(a[3],ib[3],q[2],sum[3],q[3]);
	fa fa5(a[4],ib[4],q[3],sum[4],q[4]);
	fa fa6(a[5],ib[5],q[4],sum[5],q[5]);
	fa fa7(a[6],ib[6],q[5],sum[6],q[6]);
	fa fa8(a[7],ib[7],q[6],sum[7],cout);

endmodule



module booth_substep(input wire signed [7:0]a,Q,input wire signed q0,input wire signed [7:0] m,output reg signed [7:0] f8,output reg signed [7:0] l8,output reg cq0);
	wire [7:0] addam,subam;
	Adder myadd(a,m,addam);
	subtractor mysub(a,m,subam);
		always @(*) begin	
		if(Q[0] == q0) begin
			 cq0 = Q[0];
			l8 = Q>>1;
			 l8[7] = a[0];
			 f8 = a>>1;
			if (a[7] == 1)
			f8[7] = 1;
		end

		else if(Q[0] == 1 && q0 ==0) begin
			 cq0 = Q[0];
				l8 = Q>>1;
			 l8[7] = subam[0];
			 f8 = subam>>1;
			if (subam[7] == 1)
			f8[7] = 1;
		end

		else begin
			 cq0 = Q[0];
				l8 = Q>>1;
			 l8[7] = addam[0];
			 f8 = addam>>1;
			if (addam[7] == 1)
			f8[7] = 1;
		end
						
			
			
			 	
		
	
end	
endmodule 





 
module boothmul(input signed[7:0]a,b,output signed [15:0] c);
	wire signed [7:0]Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7;
	wire signed [7:0] m;
	wire signed [7:0] A1,A0,A3,A2;
	wire signed [7:0] A4,A5,A6,A7;
	wire signed[7:0] q0;
	wire qout;
	
	booth_substep step1(8'b00000000,a,1'b0,b,A1,Q1,q0[1]);
	booth_substep step2(A1,Q1,q0[1],b,A2,Q2,q0[2]);
	booth_substep step3(A2,Q2,q0[2],b,A3,Q3,q0[3]);
	booth_substep step4(A3,Q3,q0[3],b,A4,Q4,q0[4]);
	booth_substep step5(A4,Q4,q0[4],b,A5,Q5,q0[5]);
	booth_substep step6(A5,Q5,q0[5],b,A6,Q6,q0[6]);
	booth_substep step7(A6,Q6,q0[6],b,A7,Q7,q0[7]);
	booth_substep step8(A7,Q7,q0[7],b,c[15:8],c[7:0],qout);
	
	 
endmodule

module tb;
wire signed [15:0] z;
reg signed [7:0] a,b;


boothmul my_booth(.a(a),.b(b),.c(z));

initial begin 
end

initial
begin
$monitor($time,""Multiplication: %d * %d = %d"",a,b,z );
a = 8'b11110000;
b = 8'b11110000;

#10

a = 8'b10010101;
b = 8'b100000;

#10

a = 8'b0111;
b = 8'b0;

#10

b = 8'b1;
a = 8'b1;

#10  

a = 8'b00111100;
b = 8'b0101;

#10

a = 8'b10101010;
b = 8'b100011;

#10

a = 8'b010001;
b = 8'b11100;

#10
a = 8'b1000;
b = 8'b10111111;

end
endmodule
",booth_multiplication.txt,32-Verilog-Mini-Projects\booth_multiplication.txt
"[Keyword]: carry_look_ahead_adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a 16-bit carry look-ahead adder. This adder is used to perform fast binary addition of two 16-bit numbers along with an input carry. It uses a hierarchical structure of 4-bit carry look-ahead adders to achieve faster computation by reducing the carry propagation delay.

[Input Signal Description]:
- a[15:0]: A 16-bit input operand for the addition.
- b[15:0]: Another 16-bit input operand for the addition.
- cin: A single-bit input representing the carry-in for the least significant bit addition.

[Output Signal Description]:
- sum[15:0]: A 16-bit output representing the sum of the input operands a and b, including the carry-in.
- cout: A single-bit output representing the carry-out from the most significant bit addition.


[Design Detail]:
module carry_look_ahead_16bit(a,b, cin, sum,cout);
input [15:0] a,b;
input cin;
output [15:0] sum;
output cout;
wire c1,c2,c3;
 
carry_look_ahead_4bit cla1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c1));
carry_look_ahead_4bit cla2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .sum(sum[7:4]), .cout(c2));
carry_look_ahead_4bit cla3(.a(a[11:8]), .b(b[11:8]), .cin(c2), .sum(sum[11:8]), .cout(c3));
carry_look_ahead_4bit cla4(.a(a[15:12]), .b(b[15:12]), .cin(c3), .sum(sum[15:12]), .cout(cout));
 
endmodule

module carry_look_ahead_4bit(a,b, cin, sum,cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
 
wire [3:0] p,g,c;
 
assign p=a^b;
assign g=a&b;

assign c[0]=cin;
assign c[1]= g[0]|(p[0]&c[0]);
assign c[2]= g[1] | (p[1]&g[0]) | p[1]&p[0]&c[0];
assign c[3]= g[2] | (p[2]&g[1]) | p[2]&p[1]&g[0] | p[2]&p[1]&p[0]&c[0];
assign cout= g[3] | (p[3]&g[2]) | p[3]&p[2]&g[1] | p[3]&p[2]&p[1]&g[0] | p[3]&p[2]&p[1]&p[0]&c[0];
assign sum=p^c;
 
endmodule

module carry_look_ahead_16bit_tb;
reg [15:0] a,b;
reg cin;
wire [15:0] sum;
wire cout;
 
  carry_look_ahead_16bit uut(.a(a), .b(b),.cin(cin),.sum(sum),.cout(cout));
 
initial begin
  a=0; b=0; cin=0;
  #20 a=16'd2; b=16'd2; cin=1'd1;
  #20 a=16'd2; b=16'd3; cin=1'd1;
  #20 a=16'd18; b=16'd18; cin=1'd0;
  #20 a=16'd100; b=16'd0; cin=1'd1;
end
 
initial
  $monitor( ""A=%d, B=%d, Cin= %d, Sum=%d, Cout=%d"", a,b,cin,sum,cout);
endmodule
",carry_look_ahead_adder.txt,32-Verilog-Mini-Projects\carry_look_ahead_adder.txt
"[Keyword]: carry_save_adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a carry-save adder (CSA) that adds four 4-bit numbers (a, b, c, and d) and produces a 5-bit sum and a carry-out. The CSA is a type of digital adder used to compute the sum of three or more n-bit numbers in binary. It is particularly useful in multi-operand addition scenarios, such as in digital signal processing and computer arithmetic.

[Input Signal Description]:
- a[3:0]: A 4-bit input operand.
- b[3:0]: A 4-bit input operand.
- c[3:0]: A 4-bit input operand.
- d[3:0]: A 4-bit input operand.

These inputs represent the four numbers to be added together.

[Output Signal Description]:
- sum[4:0]: A 5-bit output representing the sum of the four input operands.
- cout: A 1-bit output representing the carry-out from the most significant bit of the addition.


[Design Detail]:
module carry_save_adder(a,b,c,d, sum,cout);
  input [3:0] a, b,c,d;
output [4:0] sum;
output cout;
 
wire [3:0] s0,s1;
  wire [3:0] c0, c1;
 
//1st Statge
full_adder fa0( .a(a[0]), .b(b[0]), .cin(c[0]), .sum(s0[0]), .cout(c0[0]));
full_adder fa1( .a(a[1]), .b(b[1]), .cin(c[1]), .sum(s0[1]), .cout(c0[1]));
full_adder fa2( .a(a[2]), .b(b[2]), .cin(c[2]), .sum(s0[2]), .cout(c0[2]));
full_adder fa3( .a(a[3]), .b(b[3]), .cin(c[3]), .sum(s0[3]), .cout(c0[3]));
 
//2nd Stage
full_adder fa4( .a(d[0]), .b(s0[0]), .cin(1'b0), .sum(sum[0]), .cout(c1[0]));
full_adder fa5( .a(d[1]), .b(s0[1]), .cin(c0[0]), .sum(s1[0]), .cout(c1[1]));
full_adder fa6( .a(d[2]), .b(s0[2]), .cin(c0[1]), .sum(s1[1]), .cout(c1[2]));
full_adder fa7( .a(d[3]), .b(s0[3]), .cin(c0[2]), .sum(s1[2]), .cout(c1[3]));
 
 ripple_carry_4_bit rca1 (.a(c1[3:0]),.b({c0[3],s1[2:0]}), .cin(1'b0),.sum(sum[4:1]), .cout(cout));
 
endmodule

 
module ripple_carry_4_bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
wire c1,c2,c3;
output [3:0] sum;
output cout;
 
full_adder fa0(.a(a[0]), .b(b[0]),.cin(cin), .sum(sum[0]),.cout(c1));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]),.cout(c2));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]),.cout(c3));
full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]),.cout(cout));
endmodule
 
 
module full_adder(a,b,cin,sum, cout);
input a,b,cin;
output sum, cout;
wire x,y,z;
half_adder  h1(.a(a), .b(b), .sum(x), .cout(y));
half_adder  h2(.a(x), .b(cin), .sum(sum), .cout(z));
assign cout= y|z;
endmodule


module half_adder( a,b, sum, cout );
input a,b;
output sum,  cout;
assign sum= a^b;
assign cout= a & b;
endmodule

module carry_save_tb;
wire [4:0] sum;
wire cout;
reg [3:0] a,b,c,d;
 
 carry_save_adder uut(
.a(a),
.b(b),
.c(c),
 .d(d),
.sum(sum),
.cout(cout));
 
initial begin
$display($time, "" Starting the Simulation"");
     a=0; b=0; c=0; d=0;
  #100 a= 4'd10; b=4'd0; c=4'd0; d=4'd0;
  #100 a= 4'd10; b=4'd10; c=4'd0; d=4'd0;
  #100 a= 4'd4; b=4'd6; c=4'd12; d=4'd0;
  #100 a= 4'd11; b=4'd2; c=4'd4; d=4'd7;
  #100 a= 4'd20; b=4'd0; c=4'd20; d=4'd0;
  #100 a= 4'd12; b=4'd5; c=4'd10; d=4'd10;
  #100 a= 4'd7; b=4'd6; c=4'd12; d=4'd8;
  #100 a= 4'd15; b=4'd15; c=4'd15; d=4'd15;
 
end
 
initial
  $monitor(""A=%d, B=%d, C=%d,D=%d,Sum= %d, Cout=%d"",a,b,c,d,sum,cout);
endmodule
",carry_save_adder.txt,32-Verilog-Mini-Projects\carry_save_adder.txt
"[Keyword]: carry_select_adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a 16-bit carry select adder, which is an efficient adder architecture used to perform fast binary addition. It divides the addition process into smaller segments and uses multiple ripple carry adders and multiplexers to quickly determine the carry and sum outputs.

[Input Signal Description]:
- a[15:0]: A 16-bit input operand for the addition.
- b[15:0]: Another 16-bit input operand for the addition.
- cin: A single-bit input representing the initial carry-in for the least significant bit addition.

[Output Signal Description]:
- sum[15:0]: A 16-bit output representing the sum of the input operands a and b, including the carry-in.
- cout: A single-bit output representing the final carry-out from the most significant bit addition.


[Design Detail]:
module carry_select_adder_16bit(a, b, cin, sum, cout);
input [15:0] a,b;
input cin;
output [15:0] sum;
output cout;
 
wire [2:0] c;
 
ripple_carry_4_bit rca1(
.a(a[3:0]),
.b(b[3:0]),
.cin(cin),
.sum(sum[3:0]),
.cout(c[0]));
 

carry_select_adder_4bit_slice csa_slice1(
.a(a[7:4]),
.b(b[7:4]),
.cin(c[0]),
.sum(sum[7:4]),
.cout(c[1]));
 
carry_select_adder_4bit_slice csa_slice2(
.a(a[11:8]),
.b(b[11:8]),
.cin(c[1]),
.sum(sum[11:8]), 
.cout(c[2]));
 
carry_select_adder_4bit_slice csa_slice3(
.a(a[15:12]),
.b(b[15:12]),
.cin(c[2]),
.sum(sum[15:12]),
.cout(cout));
endmodule
 
 
module carry_select_adder_4bit_slice(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
 
wire [3:0] s0,s1;
wire c0,c1;
 
ripple_carry_4_bit rca1(
.a(a[3:0]),
.b(b[3:0]),
.cin(1'b0),
.sum(s0[3:0]),
.cout(c0));
 
ripple_carry_4_bit rca2(
.a(a[3:0]),
.b(b[3:0]),
.cin(1'b1),
.sum(s1[3:0]),
.cout(c1));
 
mux2X1 #(4) ms0(
.in0(s0[3:0]),
.in1(s1[3:0]),
.sel(cin),
.out(sum[3:0]));
 
mux2X1 #(1) mc0(
.in0(c0),
.in1(c1),
.sel(cin),
.out(cout));
endmodule
 
 
module mux2X1( in0,in1,sel,out);
parameter width=16; 
input [width-1:0] in0,in1;
input sel;
output [width-1:0] out;
assign out=(sel)?in1:in0;
endmodule
 

module ripple_carry_4_bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
 
wire c1,c2,c3;
 
full_adder fa0(
.a(a[0]),
.b(b[0]),
.cin(cin),
.sum(sum[0]),
.cout(c1));
 
full_adder fa1(
.a(a[1]),
.b(b[1]),
.cin(c1),
.sum(sum[1]),
.cout(c2));
 
full_adder fa2(
.a(a[2]),
.b(b[2]),
.cin(c2),
.sum(sum[2]),
.cout(c3));
 
full_adder fa3(
.a(a[3]),
.b(b[3]),
.cin(c3),
.sum(sum[3]),
.cout(cout));
endmodule

 
module full_adder(a,b,cin,sum, cout);
input a,b,cin;
output sum, cout;
 
wire x,y,z;
 
half_adder h1(.a(a), .b(b), .sum(x), .cout(y));
half_adder h2(.a(x), .b(cin), .sum(sum), .cout(z));
or or_1(cout,z,y);
endmodule

 
module half_adder( a,b, sum, cout );
input a,b;
output sum, cout;
xor xor_1 (sum,a,b);
and and_1 (cout,a,b);
endmodule

module carry_select_adder_16bit_tb;
reg [15:0] a,b;
reg cin;
wire [15:0] sum;
wire cout;
 
  carry_select_adder_16bit uut(.a(a), .b(b),.cin(cin),.sum(sum),.cout(cout));
 
initial begin
  a=0; b=0; cin=0;
  #10 a=16'd2; b=16'd2; cin=1'd1;
  #10 a=16'd2; b=16'd4; cin=1'd1;
  #10 a=16'd100; b=16'd0; cin=1'd0;
  #10 a=16'd12; b=16'd3; cin=1'd1;
end
 
initial
  $monitor( ""A=%d, B=%d, Cin= %d, Sum=%d, Cout=%d"", a,b,cin,sum,cout);
endmodule
",carry_select_adder.txt,32-Verilog-Mini-Projects\carry_select_adder.txt
"[Keyword]: carry_skip_adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a 16-bit carry-skip adder. This adder is composed of four 4-bit carry-skip adders, which are used to efficiently compute the sum of two 16-bit numbers along with a carry-in. The carry-skip adder is designed to improve the speed of addition by allowing the carry to skip over groups of bits when possible.

[Input Signal Description]:
- a[15:0]: A 16-bit input operand for the addition.
- b[15:0]: Another 16-bit input operand for the addition.
- cin: A single-bit input representing the carry-in for the least significant bit of the addition.

[Output Signal Description]:
- sum[15:0]: A 16-bit output representing the sum of the input operands a and b, including the carry-in.
- cout: A single-bit output representing the carry-out from the most significant bit of the addition.


[Design Detail]:
module carry_skip_16bit(a, b, cin, sum, cout);
input [15:0] a,b;
input cin;
output cout;
output [15:0] sum;
 
wire [2:0] c;
 
carry_skip_4bit csa1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c[0]));
carry_skip_4bit csa2 (.a(a[7:4]), .b(b[7:4]), .cin(c[0]), .sum(sum[7:4]), .cout(c[1]));
carry_skip_4bit csa3(.a(a[11:8]), .b(b[11:8]), .cin(c[1]), .sum(sum[11:8]), .cout(c[2]));
carry_skip_4bit csa4(.a(a[15:12]), .b(b[15:12]), .cin(c[2]), .sum(sum[15:12]), .cout(cout));
 
endmodule
 
module carry_skip_4bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
wire [3:0] p;
wire c0;
wire bp;
 
ripple_carry_4_bit rca1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c0));
generate_p p1(a,b,p,bp);
mux2X1 m0(.in0(c0),.in1(cin),.sel(bp),.out(cout));
 
endmodule
 
module generate_p(a,b,p,bp);
input [3:0] a,b;
output [3:0] p;
output bp;
assign p= a^b;
assign bp= &p;
endmodule
 

module ripple_carry_4_bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
wire c1,c2,c3;
output [3:0] sum;
output cout;
 
full_adder fa0(.a(a[0]), .b(b[0]),.cin(cin), .sum(sum[0]),.cout(c1));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]),.cout(c2));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]),.cout(c3));
full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]),.cout(cout));
endmodule
 
module full_adder(a,b,cin,sum, cout);
input a,b,cin;
output sum, cout;
wire x,y,z;
half_adder h1(.a(a), .b(b), .sum(x), .cout(y));
half_adder h2(.a(x), .b(cin), .sum(sum), .cout(z));
or or_1(cout,z,y);
endmodule


module half_adder( a,b, sum, cout );
input a,b;
output sum, cout;
xor xor_1 (sum,a,b);
and and_1 (cout,a,b);
endmodule
 

module mux2X1( in0,in1,sel,out);
input in0,in1;
input sel;
output out;
assign out=(sel)?in1:in0;
endmodule


module carry_skip_16bit_tb;
wire [15:0] sum;
wire cout;
reg [15:0] a,b;
reg cin;
 
carry_skip_16bit uut(.a(a),.b(b),.cin(cin),.sum(sum),.cout(cout));
 
initial begin
     a=0; b=0; cin=0;
#10 a= 16'b0000000000000101; b=16'b000000000000101; cin=1'b1;
#10 a= 16'b0000000000011111; b=16'b000000000001100; cin=1'b0;
#10 a= 16'b0000000000011111; b=16'b000000000001100; cin=1'b0;
#10 a= 16'b1100011000011111; b=16'b000000110001100; cin=1'b1;
#10 a= 16'b1111111111111111; b=16'b000000000000000; cin=1'b1;
#10 a =16'b0000000000000001; b=16'b000000000000001; cin=1'b1;
#10 a =16'b0000000000000010; b=16'b000000000000010; cin=1'b1;
end
 
initial
$monitor(""time= "", $time, ""A=%b, B=&b, Cin=%b : Sum= %b, Cout=%cout"",a,b,cin,sum,cout);
endmodule
",carry_skip_adder.txt,32-Verilog-Mini-Projects\carry_skip_adder.txt
"[Keyword]: cfsr

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a cyclic shift right register. It shifts an 8-bit register to the right by one bit position on each positive edge of the clock. The least significant bit is wrapped around to the most significant bit, creating a cyclic effect. The design also logs the shift operations to a file.

[Input Signal Description]:
- clk: Clock signal used to synchronize the shifting operation.
- rst: Asynchronous reset signal used to initialize the register and counter.

[Output Signal Description]:
- The design does not have explicit output ports, but it writes the shift operation results to a file named ""cfsr.vec"". The file logs the pass number and the current value of the register in hexadecimal format.


[Design Detail]:
module cfsr ();
reg clk, rst;
reg[7:0] x_q;
reg[7:0] x_d;
reg[4:0] q_cnt;

integer i;
integer out;
//clock
initial
begin
    clk = 0;
   forever #10 clk = ~clk;
end
//reset
initial begin
    rst = 0;
    # 50 rst = 1;
end
// Use positive edge of clock to shift the register value
// Implement cyclic shift right
always @(posedge clk or
    negedge rst)
begin
    if (!rst)
    begin
        x_q <= 'hed;
        q_cnt <= 0;
        out = $fopen(""cfsr.vec"",""w"");
    end
    else
    begin
        x_q <= x_d;
        q_cnt <= q_cnt + 1;
        $fdisplay(out, ""Pass %d Shift value in hex %b"", q_cnt, x_q);
    end
end
//shift logic
always @(*)
begin
    x_d = x_q;
    x_d[7] = x_q[0];
    for (i=0; i<7; i=i+1)
    begin
        x_d[i] = x_q[i+1];
    end
end
endmodule
",cfsr.txt,32-Verilog-Mini-Projects\cfsr.txt
"[Keyword]: cfsrec

[Design Category]: Sequential Logic

[Design Function Description]:
The design appears to be a sequence of shift operations applied over multiple passes. Each pass involves a specific shift value represented in hexadecimal. The sequence of operations suggests a repetitive or iterative process, possibly for data transformation or encryption purposes.

[Input Signal Description]:
The input signals are not explicitly provided in the user input, but it can be inferred that the design requires an initial data input that will be subjected to the shift operations. The shift values for each pass are given in hexadecimal format, which indicates the amount or pattern of shifting to be applied.

[Output Signal Description]:
The output signal is not explicitly described, but it would likely be the result of applying the series of shift operations to the input data. The output would reflect the transformed data after all specified passes have been completed.


[Design Detail]:
Pass  0 Shift value in hex 11101101
Pass  1 Shift value in hex 11110110
Pass  2 Shift value in hex 01111011
Pass  3 Shift value in hex 10111101
Pass  4 Shift value in hex 11011110
Pass  5 Shift value in hex 01101111
Pass  6 Shift value in hex 10110111
Pass  7 Shift value in hex 11011011
Pass  8 Shift value in hex 11101101
Pass  9 Shift value in hex 11110110
Pass 10 Shift value in hex 01111011
Pass 11 Shift value in hex 10111101
Pass 12 Shift value in hex 11011110
Pass 13 Shift value in hex 01101111
Pass 14 Shift value in hex 10110111
Pass 15 Shift value in hex 11011011
Pass 16 Shift value in hex 11101101
Pass 17 Shift value in hex 11110110
Pass 18 Shift value in hex 01111011
Pass 19 Shift value in hex 10111101
Pass 20 Shift value in hex 11011110
Pass 21 Shift value in hex 01101111
Pass 22 Shift value in hex 10110111
Pass 23 Shift value in hex 11011011
Pass 24 Shift value in hex 11101101
Pass 25 Shift value in hex 11110110
Pass 26 Shift value in hex 01111011
Pass 27 Shift value in hex 10111101
Pass 28 Shift value in hex 11011110
Pass 29 Shift value in hex 01101111
Pass 30 Shift value in hex 10110111
Pass 31 Shift value in hex 11011011
Pass  0 Shift value in hex 11101101
Pass  1 Shift value in hex 11110110
Pass  2 Shift value in hex 01111011
Pass  3 Shift value in hex 10111101
Pass  4 Shift value in hex 11011110
Pass  5 Shift value in hex 01101111
Pass  6 Shift value in hex 10110111
Pass  7 Shift value in hex 11011011
Pass  8 Shift value in hex 11101101
Pass  9 Shift value in hex 11110110
Pass 10 Shift value in hex 01111011
Pass 11 Shift value in hex 10111101
Pass 12 Shift value in hex 11011110
Pass 13 Shift value in hex 01101111
Pass 14 Shift value in hex 10110111
Pass 15 Shift value in hex 11011011
",cfsrec.txt,32-Verilog-Mini-Projects\cfsrec.txt
"[Keyword]: complex_multiplication

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a complex number multiplication circuit. It takes two 16-bit inputs, each representing a complex number with 8 bits for the real part and 8 bits for the imaginary part. The circuit outputs a 32-bit product, which is the result of multiplying the two complex numbers.

[Input Signal Description]:
- c1[15:0]: A 16-bit input signal representing the first complex number, where c1[15:8] is the real part and c1[7:0] is the imaginary part.
- c2[15:0]: A 16-bit input signal representing the second complex number, where c2[15:8] is the real part and c2[7:0] is the imaginary part.

[Output Signal Description]:
- product[31:0]: A 32-bit output signal representing the product of the two complex numbers. The real part of the product is calculated as (c1[15:8] * c2[15:8]) - (c1[7:0] * c2[7:0]), and the imaginary part is (c1[15:8] * c2[7:0]) + (c1[7:0] * c2[15:8]).


[Design Detail]:
module compmul(c1,c2,product);
input [15:0]c1,c2;
output [31:0]product;
assign product={((c1[15:8]*c2[15:8])-(c1[7:0]*c2[7:0])),((c1[15:8]*c2[7:0])+(c1[7:0]*c2[15:8]))};
endmodule

module compmul_tb();
 reg [15:0]c1,c2;
 wire [31:0]product;
 compmul a(c1,c2,product);
 initial
 begin
 c1<=16'b0000001000000010;
 c2<=16'b0000011000000010;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b00001111100001000;
 c2<=16'b00000000000010000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000101110001000;
 c2<=16'b0000000000001000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000100000001000;
 c2<=16'b0001111000001000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000100001101000;
 c2<=16'b0000001000001000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000100000001000;
 c2<=16'b0001111111101000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b1111111111111111;
 c2<=16'b1111111111111111;
 #50
 $display(""output for mul %b"",product);

 end
endmodule



",complex_multiplication.txt,32-Verilog-Mini-Projects\complex_multiplication.txt
"[Keyword]: counter

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple counter that counts clock cycles. It resets the count to zero when the reset signal is high and sets an output signal 'l' to high when the count reaches 7.

[Input Signal Description]:
- reset: A signal used to reset the counter to zero. When high, it initializes the counter.
- clk: The clock signal that drives the counter. The counter increments on each rising edge of the clock.

[Output Signal Description]:
- l: A signal that goes high when the counter reaches the value of 7, indicating that the count has completed a cycle.


[Design Detail]:
 //Counter 

module counter(reset,l,clk);

input reset,clk;
output reg l;
integer i;

always @(posedge clk)
begin
if(reset)
begin
i=0;
l=0;
end
else
begin
if(i==7)
l=1;
else
begin
i=i+1;
l=0;
end
end
end
endmodule
",counter.txt,32-Verilog-Mini-Projects\counter.txt
"[Keyword]: CRC_16_parallel

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a parallel CRC-16 (Cyclic Redundancy Check) generator. It processes an 8-bit input data stream to compute a 16-bit CRC value, which is commonly used for error-checking in digital networks and storage devices.

[Input Signal Description]:
- clk: Clock signal to synchronize the operations.
- rst: Reset signal to initialize the CRC computation process.
- load: Signal to start the CRC computation.
- d_finish: Signal indicating the end of data input for CRC computation.
- crc_in[7:0]: 8-bit input data for which the CRC is to be computed.

[Output Signal Description]:
- crc_out[7:0]: 8-bit output representing the computed CRC value.


[Design Detail]:
module CRC_16_parallel(clk,rst,load,d_finish,crc_in,crc_out); 

input clk; 
input rst; 
input load; 
input d_finish; 
input [7:0] crc_in; 
output [7:0] crc_out;
reg [7:0] crc_out; 
reg [15:0] crc_reg;
reg [1:0] count;  
reg [1:0] state; 
wire [15:0] next_crc_reg; //
parameter idle = 2'b00; //
parameter compute = 2'b01;//
parameter finish = 2'b10; //
//

assign next_crc_reg[0] = (^crc_in[7:0]) ^ (^crc_reg[15:8]); 
assign next_crc_reg[1] = (^crc_in[6:0]) ^ (^crc_reg[15:9]); 
assign next_crc_reg[2] = crc_in[7] ^ crc_in[6] ^ crc_reg[9] ^ crc_reg[8]; 
assign next_crc_reg[3] = crc_in[6] ^ crc_in[5] ^ crc_reg[10] ^ 
crc_reg[9]; 
assign next_crc_reg[4] = crc_in[5] ^ crc_in[4] ^ crc_reg[11] ^ 
crc_reg[10]; 
assign next_crc_reg[5] = crc_in[4] ^ crc_in[3] ^ crc_reg[12] ^ 
crc_reg[11]; 
assign next_crc_reg[6] = crc_in[3] ^ crc_in[2] ^ crc_reg[13] ^ 
crc_reg[12]; 
assign next_crc_reg[7] = crc_in[2] ^ crc_in[1] ^ crc_reg[14] ^ 
crc_reg[13]; 
assign next_crc_reg[8] = crc_in[1] ^ crc_in[0] ^ crc_reg[15] ^ crc_reg[14] 
^ crc_reg[0]; 
assign next_crc_reg[9] = crc_in[0] ^ crc_reg[15] ^ crc_reg[1]; 
assign next_crc_reg[14:10] = crc_reg[6:2]; 
assign next_crc_reg[15] = (^crc_in[7:0]) ^ (^crc_reg[15:7]); 
always@(posedge clk) //
begin 
case(state) //
 idle:begin // 
 if(load) //
 state <= compute; 
 else 
 state <= idle; 
 end 
 compute:begin 
 if(d_finish)//
 state <= finish; 
 else 
 state <= compute; 
 end 
 finish:begin 
 if(count==2)//
 state <= idle; 
 else 
 state <= finish; 
 end 
endcase 
end 
always@(posedge clk or negedge rst)//
 if(rst) 
 begin 
 crc_reg[15:0] <= 16'b0000_0000_0000_0000;//
 state <= idle; 
 count <= 2'b00; 
 end 
 else 
 case(state) 
 idle:begin // 
 crc_reg[15:0] <= 16'b0000_0000_0000_0000; 
 end 
 compute:begin // 
 crc_reg[15:0]<= next_crc_reg[15:0]; 
 crc_out[7:0] <= crc_in[7:0]; 
 end 
 finish:begin //
 crc_reg[15:0] <= {crc_reg[7:0],8'b0000_0000}; 
 crc_out[7:0] <= crc_reg[15:8]; 
 end 
 endcase 
endmodule 
",CRC_16_parallel.txt,32-Verilog-Mini-Projects\CRC_16_parallel.txt
"[Keyword]: CRC_16_serial

[Design Category]: Sequential Logic

[Design Function Description]:
This module implements a CRC-16 (Cyclic Redundancy Check) encoding circuit using a serial linear shift register. It processes input data serially and computes a 16-bit CRC code, which is commonly used for error-checking in digital networks and storage devices.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the circuit.
- `rst`: Reset signal, active low, used to initialize the circuit to a known state.
- `load`: Signal to start the encoding process.
- `d_finish`: Signal indicating the end of the encoding process.
- `crc_in`: Serial input data to be encoded.

[Output Signal Description]:
- `crc_out`: Serial output of the encoded CRC code. It outputs the CRC result after processing the input data.


[Design Detail]:
//module CRC_16_serial 
//Module function: The module is a coding circuit of crc-16 check code, which uses a serial linear shift stage
module CRC_16_serial(clk,rst,load,d_finish,crc_in,crc_out); 
input clk; //Clk signal
input rst; //Reset signal
input load; //Start encoding the signal
input d_finish; //Encode the end signal
input crc_in; //The word input to be encoded
output crc_out; //Code word output after encoding
reg crc_out; //Code word output staging, 1bit 
reg [15:0] crc_reg; //Linear shift staging, 16bits 
reg [1:0] state; //State staging, 2bit 
reg [4:0] count; //Count staging, 5bit 
parameter idle = 2'b00; //Wait state
parameter compute = 2'b01;//calculated status
parameter finish = 2'b10; //Calculate the end state
always@ (posedge clk) //executed each time the clk is triggered for a positive edge
begin // can be seen as the upper parenthesis in the c language, and end can be seen as the lower parenthesis
case (state) // Select case in state 
 idle: begin // is the wait state
 if (load) //load signal enters the compute state effectively
 state <= compute; 
 else
 state <= idle; 
 end
 compute:begin //d_finish signal enters the finish state effectively
 if(d_finish) 
 state <= finish; 
 else
 state <= compute; 
 end
 finish: begin // Determines whether the data in the 16 stagings is fully output
 if(count==16) 
 state <= idle; 
 else
 count <= count+1; 
 end
endcase
end 
always@ (posedge clk or negedge rst)//whenever the clk positive trigger or rst negative edge trigger is executed
 if(rst) 
 begin 
 //crc_reg the initial value < pre-installed b0000_0000_0000_0000 15:0, 15:0, 16'
 count <= 5'b0_0000; 
 state <= idle; 
 end
 else
 case(state) 
 idle:begin
 crc_reg[15:0] <= 16'b0000_0000_0000_0000; 
 end
 compute:begin 
 //Produces a polynomial x^16+x^15+x^2+1 
 crc_reg[0] <= crc_reg[15] ^ crc_in; 
 crc_reg[1] <= crc_reg[0]; 
 crc_reg[2] <= crc_reg[1] ^ crc_reg[15] ^ crc_in; 
 crc_reg[14:3] <= crc_reg[13:2]; 
 crc_reg[15] <= crc_reg[14] ^ crc_reg[15] ^ crc_in; 
 crc_out <= crc_in; // The input is the output
 end 
 finish:begin 
 crc_out <= crc_reg[15]; // Stager 15 as output
 crc_reg[15:0] <= {crc_reg[14:0],1'b0}; // Shift.
 end 
 endcase 
endmodule





",CRC_16_serial.txt,32-Verilog-Mini-Projects\CRC_16_serial.txt
"[Keyword]: CRC_32_parallel

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a parallel CRC-32 (Cyclic Redundancy Check) generator. It calculates a 32-bit CRC value for a given 8-bit input data stream. The CRC is used for error-checking purposes in digital networks and storage devices to detect accidental changes to raw data.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the circuit.
- `rst`: Reset signal to initialize the CRC register and state machine.
- `load`: Signal to start the CRC computation process.
- `d_finish`: Signal indicating the end of data input, transitioning the state machine to the finish state.
- `crc_in[7:0]`: 8-bit input data for which the CRC is being calculated.

[Output Signal Description]:
- `crc_out[7:0]`: 8-bit output representing the current CRC value or the final CRC value after computation.


[Design Detail]:
//
module CRC_32_parallel(clk,rst,load,d_finish,crc_in,crc_out); 
input clk; //
input rst; //
input load; //
input d_finish; //
input [7:0] crc_in; //
output [7:0] crc_out; // 
reg [7:0] crc_out; //
reg [31:0] crc_reg; //
reg [1:0] count; //
reg [1:0] state; //
wire [31:0] next_crc_reg; //
parameter idle = 2'b00; //
parameter compute = 2'b01; //
parameter finish = 2'b10; //
//
assign next_crc_reg[0] = crc_reg[24] ^ crc_reg[30] ^ crc_in[0] ^ 
crc_in[6]; 
assign next_crc_reg[1] = crc_reg[24] ^ crc_reg[25] ^ crc_reg[30] ^ 
crc_reg[31] ^ crc_in[0] ^ crc_in[1] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[2] = crc_reg[24] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[30] ^ crc_reg[31] ^ crc_in[0] ^ crc_in[1] ^ crc_in[2] ^ crc_in[6] 
^ crc_in[7]; 
assign next_crc_reg[3] = crc_reg[25] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[31] ^ crc_in[1] ^ crc_in[2] ^ crc_in[3] ^ crc_in[7]; 
assign next_crc_reg[4] = crc_reg[24] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[30] ^ crc_in[0] ^ crc_in[2] ^ crc_in[3] ^ crc_in[4] 
^ crc_in[6]; 
assign next_crc_reg[5] = crc_reg[24] ^ crc_reg[25] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[29] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[0] ^ 
crc_in[1] ^ crc_in[3] ^ crc_in[4] ^ crc_in[5] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[6] = crc_reg[25] ^ crc_reg[26] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[1] ^ crc_in[2] ^ crc_in[4] 
^ crc_in[5] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[7] = crc_reg[24] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[29] ^ crc_reg[31] ^ crc_in[0] ^ crc_in[2] ^ crc_in[3] ^ crc_in[5] 
^ crc_in[7]; 
assign next_crc_reg[8] = crc_reg[0] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[27] ^ crc_reg[28] ^ crc_in[0] ^ crc_in[1] ^ crc_in[3] ^ crc_in[4]; 
assign next_crc_reg[9] = crc_reg[1] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[28] ^ crc_reg[29] ^ crc_in[1] ^ crc_in[2] ^ crc_in[4] ^ crc_in[5]; 
assign next_crc_reg[10] = crc_reg[2] ^ crc_reg[24] ^ crc_reg[26] ^ 
crc_reg[27] ^ crc_reg[29] ^ crc_in[0] ^ crc_in[2] ^ crc_in[3] ^ crc_in[5]; 
assign next_crc_reg[11] = crc_reg[3] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[27] ^ crc_reg[28] ^ crc_in[0] ^ crc_in[1] ^ crc_in[3] ^ crc_in[4]; 
assign next_crc_reg[12] = crc_reg[4] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[26] ^ crc_reg[28] ^ crc_reg[29] ^ crc_reg[30] ^ crc_in[0] ^ 
crc_in[1] ^ crc_in[2] ^ crc_in[4] ^ crc_in[5] ^ crc_in[6]; 
assign next_crc_reg[13] = crc_reg[5] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[27] ^ crc_reg[29] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[1] ^ 
crc_in[2] ^ crc_in[3] ^ crc_in[5] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[14] = crc_reg[6] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[2] ^ crc_in[3] ^ crc_in[4] 
^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[15] = crc_reg[7] ^ crc_reg[27] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_reg[31] ^ crc_in[3] ^ crc_in[4] ^ crc_in[5] ^ crc_in[7]; 
assign next_crc_reg[16] = crc_reg[8] ^ crc_reg[24] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_in[0] ^ crc_in[4] ^ crc_in[5]; 
assign next_crc_reg[17] = crc_reg[9] ^ crc_reg[25] ^ crc_reg[29] ^ 
crc_reg[30] ^ crc_in[1] ^ crc_in[5] ^ crc_in[6]; 
assign next_crc_reg[18] = crc_reg[10] ^ crc_reg[26] ^ crc_reg[30] ^ 
crc_reg[31] ^ crc_in[2] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[19] = crc_reg[11] ^ crc_reg[27] ^ crc_reg[31] ^ 
crc_in[3] ^ crc_in[7]; 
assign next_crc_reg[20] = crc_reg[12] ^ crc_reg[28] ^ crc_in[4]; 
assign next_crc_reg[21] = crc_reg[13] ^ crc_reg[29] ^ crc_in[5]; 
assign next_crc_reg[22] = crc_reg[14] ^ crc_reg[24] ^ crc_in[0]; 
assign next_crc_reg[23] = crc_reg[15] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[30] ^ crc_in[0] ^ crc_in[1] ^ crc_in[6]; 
assign next_crc_reg[24] = crc_reg[16] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[31] ^ crc_in[1] ^ crc_in[2] ^ crc_in[7]; 
assign next_crc_reg[25] = crc_reg[17] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_in[2] ^ crc_in[3]; 
assign next_crc_reg[26] = crc_reg[18] ^ crc_reg[24] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[30] ^ crc_in[0] ^ crc_in[3] ^ crc_in[4] ^ crc_in[6]; 
assign next_crc_reg[27] = crc_reg[19] ^ crc_reg[25] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_reg[31] ^ crc_in[1] ^ crc_in[4] ^ crc_in[5] ^ crc_in[7]; 
assign next_crc_reg[28] = crc_reg[20] ^ crc_reg[26] ^ crc_reg[29] ^ 
crc_reg[30] ^ crc_in[2] ^ crc_in[5] ^ crc_in[6]; 
assign next_crc_reg[29] = crc_reg[21] ^ crc_reg[27] ^ crc_reg[30] ^ 
crc_reg[31] ^ crc_in[3] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[30] = crc_reg[22] ^ crc_reg[28] ^ crc_reg[31] ^ 
crc_in[4] ^ crc_in[7]; 
assign next_crc_reg[31] = crc_reg[23] ^ crc_reg[29] ^ crc_in[5]; 
//
always@(posedge clk) 
begin 
case(state) //
 idle:begin //
 if(load) //l
 state <= compute; 
 else 
 state <= idle; 
 end 
 compute:begin 
 if(d_finish) // 
 state <= finish; 
 else 
 state <= compute; 
 end 
 finish:begin 
 if(count==2) //
 state <= idle; 
 else 
 state <= finish; 
 end 
endcase 
end 
always@(posedge clk or negedge rst) // 
 if(rst) 
 begin 
 crc_reg[31:0] <= 32'b0000_0000_0000_0000_0000_0000_0000_0000; //

 state <= idle; 
 count <= 2'b00; 
 end 
 else 
 case(state) 
 idle:begin //
 crc_reg[31:0] <= 
32'b0000_0000_0000_0000_0000_0000_0000_0000; 
 end 
 compute:begin // 
 crc_reg[31:0]<= next_crc_reg[31:0]; 
 crc_out[7:0] <= crc_in[7:0]; 
 end 
 finish:begin //
 crc_reg[31:0] <= {crc_reg[23:0],8'b0000_0000}; 
 crc_out[7:0] <= crc_reg[31:24]; 
 end 
 endcase 
endmodule 
",CRC_32_parallel.txt,32-Verilog-Mini-Projects\CRC_32_parallel.txt
"[Keyword]: CRC_32_serial

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a serial CRC (Cyclic Redundancy Check) generator for a 32-bit polynomial. The circuit processes input data serially and computes the CRC value, which is commonly used for error-checking in digital networks and storage devices.

[Input Signal Description]:
- clk: Clock signal used to synchronize the operations of the circuit.
- rst: Reset signal to initialize the circuit to a known state.
- load: Signal to start the CRC computation process.
- d_finish: Signal indicating the end of data input, transitioning the state to finalize the CRC computation.
- crc_in: Serial input data for which the CRC is being computed.

[Output Signal Description]:
- crc_out: Serial output of the CRC computation. During the compute phase, it outputs the current input bit, and during the finish phase, it outputs the final CRC value.


[Design Detail]:
module CRC_32_serial(clk,rst,load,d_finish,crc_in,crc_out); 
input clk; //
input rst; //
input load; //
input d_finish; //
input crc_in; //
output crc_out; // 
reg crc_out; //
reg [31:0] crc_reg; //
reg [1:0] state; //
reg [4:0] count; //
parameter idle = 2'b00; //
parameter compute = 2'b01; //
parameter finish = 2'b10; //
  always@ (posedge clk) //
begin // 
case (state) // 
 idle: begin // 
 if (load) //
 state <= compute; 
 else
 state <= idle; 
 end
 compute:begin //
 if(d_finish) 
 state <= finish; 
 else
 state <= compute; 
 end
 finish: begin // 
   if(count==32) 
 state <= idle; 
 else
 count <= count+1; 
 end
endcase
end 
always@ (posedge clk or negedge rst)//
 if(rst) 
 begin 
 count <= 5'b0_0000; 
 state <= idle; 
 end
 else
 case(state) 
 idle:begin
   crc_reg[31:0] <= 32'b0000_0000_0000_0000_0000_0000_0000_0000; 
 end
 compute:begin 
 //Produces a polynomial x^16+x^15+x^2+1 
   crc_reg[0] <= crc_reg[31] ^ crc_in; 
 crc_reg[1] <= crc_reg[0]; 
   crc_reg[2] <= crc_reg[1] ^ crc_reg[31] ^ crc_in; 
   crc_reg[30:3] <= crc_reg[29:2]; 
   crc_reg[31] <= crc_reg[30] ^ crc_reg[31] ^ crc_in; 
 crc_out <= crc_in; //
 end 
 finish:begin 
   crc_out <= crc_reg[31]; 
   crc_reg[31:0] <= {crc_reg[30:0],1'b0}; 
 end 
 endcase 
endmodule
",CRC_32_serial.txt,32-Verilog-Mini-Projects\CRC_32_serial.txt
"[Keyword]: division

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a floating-point arithmetic unit capable of performing addition, subtraction, multiplication, and division operations on 32-bit floating-point numbers. It includes a priority encoder for normalization, an addition/subtraction module, a multiplication module, and a division module using iterative approximation.

[Input Signal Description]:
- `significand[24:0]`: Input to the priority encoder, representing the significand of a floating-point number.
- `exp_a[7:0]`: Exponent input to the priority encoder.
- `a[31:0]`, `b[31:0]`: 32-bit floating-point numbers for arithmetic operations.
- `add_sub_signal`: Control signal for addition (1) or subtraction (0).
- `operand_1[31:0]`, `operand_2[31:0]`: Inputs for the Iteration module.
- `clk`: Clock signal for the testbench.

[Output Signal Description]:
- `Significand[24:0]`: Normalized significand output from the priority encoder.
- `exp_sub[7:0]`: Adjusted exponent output from the priority encoder.
- `exception`: Indicates an exception condition (e.g., overflow, underflow) in arithmetic operations.
- `res[31:0]`: Result of the arithmetic operation (addition, subtraction, multiplication, or division).
- `overflow`, `underflow`: Flags indicating overflow or underflow conditions in multiplication.
- `solution[31:0]`: Result of the Iteration module.


[Design Detail]:
// Priority Encoder

module priority_encoder(
			input [24:0] significand,
			input [7:0] exp_a,
			output reg [24:0] Significand,
			output [7:0] exp_sub
			);

reg [4:0] shift;

always @(significand)
begin
	casex (significand)
		25'b1_1xxx_xxxx_xxxx_xxxx_xxxx_xxxx :	begin
													Significand = significand;
									 				shift = 5'd0;
								 			  	end
		25'b1_01xx_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 1;
									 				shift = 5'd1;
								 			  	end

		25'b1_001x_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 2;
									 				shift = 5'd2;
								 				end

		25'b1_0001_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin 							
													Significand = significand << 3;
								 	 				shift = 5'd3;
								 				end

		25'b1_0000_1xxx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 4;
								 	 				shift = 5'd4;
								 				end

		25'b1_0000_01xx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 5;
								 	 				shift = 5'd5;
								 				end

		25'b1_0000_001x_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h020000
									 				Significand = significand << 6;
								 	 				shift = 5'd6;
								 				end

		25'b1_0000_0001_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h010000
									 				Significand = significand << 7;
								 	 				shift = 5'd7;
								 				end

		25'b1_0000_0000_1xxx_xxxx_xxxx_xxxx : 	begin						// 24'h008000
									 				Significand = significand << 8;
								 	 				shift = 5'd8;
								 				end

		25'b1_0000_0000_01xx_xxxx_xxxx_xxxx : 	begin						// 24'h004000
									 				Significand = significand << 9;
								 	 				shift = 5'd9;
								 				end

		25'b1_0000_0000_001x_xxxx_xxxx_xxxx : 	begin						// 24'h002000
									 				Significand = significand << 10;
								 	 				shift = 5'd10;
								 				end

		25'b1_0000_0000_0001_xxxx_xxxx_xxxx : 	begin						// 24'h001000
									 				Significand = significand << 11;
								 	 				shift = 5'd11;
								 				end

		25'b1_0000_0000_0000_1xxx_xxxx_xxxx : 	begin						// 24'h000800
									 				Significand = significand << 12;
								 	 				shift = 5'd12;
								 				end

		25'b1_0000_0000_0000_01xx_xxxx_xxxx : 	begin						// 24'h000400
									 				Significand = significand << 13;
								 	 				shift = 5'd13;
								 				end

		25'b1_0000_0000_0000_001x_xxxx_xxxx : 	begin						// 24'h000200
									 				Significand = significand << 14;
								 	 				shift = 5'd14;
								 				end

		25'b1_0000_0000_0000_0001_xxxx_xxxx  : 	begin						// 24'h000100
									 				Significand = significand << 15;
								 	 				shift = 5'd15;
								 				end

		25'b1_0000_0000_0000_0000_1xxx_xxxx : 	begin						// 24'h000080
									 				Significand = significand << 16;
								 	 				shift = 5'd16;
								 				end

		25'b1_0000_0000_0000_0000_01xx_xxxx : 	begin						// 24'h000040
											 		Significand = significand << 17;
										 	 		shift = 5'd17;
												end

		25'b1_0000_0000_0000_0000_001x_xxxx : 	begin						// 24'h000020
									 				Significand = significand << 18;
								 	 				shift = 5'd18;
								 				end

		25'b1_0000_0000_0000_0000_0001_xxxx : 	begin						// 24'h000010
									 				Significand = significand << 19;
								 	 				shift = 5'd19;
												end

		25'b1_0000_0000_0000_0000_0000_1xxx :	begin						// 24'h000008
									 				Significand = significand << 20;
								 					shift = 5'd20;
								 				end

		25'b1_0000_0000_0000_0000_0000_01xx : 	begin						// 24'h000004
									 				Significand = significand << 21;
								 	 				shift = 5'd21;
								 				end

		25'b1_0000_0000_0000_0000_0000_001x : 	begin						// 24'h000002
									 				Significand = significand << 22;
								 	 				shift = 5'd22;
								 				end

		25'b1_0000_0000_0000_0000_0000_0001 : 	begin						// 24'h000001
									 				Significand = significand << 23;
								 	 				shift = 5'd23;
								 				end

		25'b1_0000_0000_0000_0000_0000_0000 : 	begin						// 24'h000000
								 					Significand = significand << 24;
							 	 					shift = 5'd24;
								 				end
		default : 	begin
						Significand = (~significand) + 1'b1;
						shift = 8'd0;
					end

	endcase
end
assign exp_sub = exp_a - shift;

endmodule

//Addition and Subtraction

module Addition_Subtraction(
input [31:0] a,b,
input add_sub_signal,														// If 1 then addition otherwise subtraction
output exception,
output [31:0] res      
);

wire operation_add_sub_signal;
wire enable;
wire output_sign;

wire [31:0] op_a,op_b;
wire [23:0] significand_a,significand_b;
wire [7:0] exponent_diff;


wire [23:0] significand_b_add_sub;
wire [7:0] exp_b_add_sub;

wire [24:0] significand_add;
wire [30:0] add_sum;

wire [23:0] significand_sub_complement;
wire [24:0] significand_sub;
wire [30:0] sub_diff;
wire [24:0] subtraction_diff; 
wire [7:0] exp_sub;

assign {enable,op_a,op_b} = (a[30:0] < b[30:0]) ? {1'b1,b,a} : {1'b0,a,b};							// For operations always op_a must not be less than b

assign exp_a = op_a[30:23];
assign exp_b = op_b[30:23];

assign exception = (&op_a[30:23]) | (&op_b[30:23]);										// Exception flag sets 1 if either one of the exponent is 255.

assign output_sign = add_sub_signal ? enable ? !op_a[31] : op_a[31] : op_a[31] ;

assign operation_add_sub_signal = add_sub_signal ? op_a[31] ^ op_b[31] : ~(op_a[31] ^ op_b[31]);				// Assign significand values according to Hidden Bit.

assign significand_a = (|op_a[30:23]) ? {1'b1,op_a[22:0]} : {1'b0,op_a[22:0]};							// If exponent is zero,hidden bit = 0,else 1
assign significand_b = (|op_b[30:23]) ? {1'b1,op_b[22:0]} : {1'b0,op_b[22:0]};

assign exponent_diff = op_a[30:23] - op_b[30:23];										// Exponent difference calculation

assign significand_b_add_sub = significand_b >> exponent_diff;

assign exp_b_add_sub = op_b[30:23] + exponent_diff; 

assign perform = (op_a[30:23] == exp_b_add_sub);										// Checking if exponents are same

// Add Block //
assign significand_add = (perform & operation_add_sub_signal) ? (significand_a + significand_b_add_sub) : 25'd0; 

assign add_sum[22:0] = significand_add[24] ? significand_add[23:1] : significand_add[22:0];					// res will be most 23 bits if carry generated, else least 22 bits.

assign add_sum[30:23] = significand_add[24] ? (1'b1 + op_a[30:23]) : op_a[30:23];						// If carry generates in sum value then exponent is added with 1 else feed as it is.

// Sub Block //
assign significand_sub_complement = (perform & !operation_add_sub_signal) ? ~(significand_b_add_sub) + 24'd1 : 24'd0 ; 

assign significand_sub = perform ? (significand_a + significand_sub_complement) : 25'd0;

priority_encoder pe(significand_sub,op_a[30:23],subtraction_diff,exp_sub);

assign sub_diff[30:23] = exp_sub;

assign sub_diff[22:0] = subtraction_diff[22:0];


// Output //
assign res = exception ? 32'b0 : ((!operation_add_sub_signal) ? {output_sign,sub_diff} : {output_sign,add_sum});

endmodule


// Multiplication
module Multiplication(
		input [31:0] a,
		input [31:0] b,
		output exception,overflow,underflow,
		output [31:0] res
		);

wire sign,product_round,normalised,zero;
wire [8:0] exponent,sum_exponent;
wire [22:0] product_mantissa;
wire [23:0] op_a,op_b;
wire [47:0] product,product_normalised; //48 Bits


assign sign = a[31] ^ b[31];   													// XOR of 32nd bit

assign exception = (&a[30:23]) | (&b[30:23]);											// Execption sets to 1 when exponent of any a or b is 255
																// If exponent is 0, hidden bit is 0



assign op_a = (|a[30:23]) ? {1'b1,a[22:0]} : {1'b0,a[22:0]};

assign op_b = (|b[30:23]) ? {1'b1,b[22:0]} : {1'b0,b[22:0]};

assign product = op_a * op_b;													// Product

assign product_round = |product_normalised[22:0];  									        // Last 22 bits are ORed for rounding off purpose

assign normalised = product[47] ? 1'b1 : 1'b0;	

assign product_normalised = normalised ? product : product << 1;								// Normalized value based on 48th bit

assign product_mantissa = product_normalised[46:24] + {21'b0,(product_normalised[23] & product_round)};				// Mantissa

assign zero = exception ? 1'b0 : (product_mantissa == 23'd0) ? 1'b1 : 1'b0;

assign sum_exponent = a[30:23] + b[30:23];

assign exponent = sum_exponent - 8'd127 + normalised;

assign overflow = ((exponent[8] & !exponent[7]) & !zero) ;									// Overall exponent is greater than 255 then Overflow

assign underflow = ((exponent[8] & exponent[7]) & !zero) ? 1'b1 : 1'b0; 							// Sum of exponents is less than 255 then Underflow 

assign res = exception ? 32'd0 : zero ? {sign,31'd0} : overflow ? {sign,8'hFF,23'd0} : underflow ? {sign,31'd0} : {sign,exponent[7:0],product_mantissa};


endmodule


// Iteration
module Iteration(
	input [31:0] operand_1,
	input [31:0] operand_2,
	output [31:0] solution
	);

wire [31:0] Intermediate_Value1,Intermediate_Value2;

Multiplication M1(operand_1,operand_2,,,,Intermediate_Value1);

//32'h4000_0000 -> 2.
Addition_Subtraction A1(32'h4000_0000,{1'b1,Intermediate_Value1[30:0]},1'b0,,Intermediate_Value2);

Multiplication M2(operand_1,Intermediate_Value2,,,,solution);

endmodule

// Division
module division(
	input [31:0] a,
	input [31:0] b,
	output exception,
	output [31:0] res
);

wire sign;
wire [7:0] shift;
wire [7:0] exp_a;
wire [31:0] divisor;
wire [31:0] op_a;
wire [31:0] Intermediate_X0;
wire [31:0] Iteration_X0;
wire [31:0] Iteration_X1;
wire [31:0] Iteration_X2;
wire [31:0] Iteration_X3;
wire [31:0] solution;

wire [31:0] denominator;
wire [31:0] op_a_change;

assign exception = (&a[30:23]) | (&b[30:23]);

assign sign = a[31] ^ b[31];

assign shift = 8'd126 - b[30:23];

assign divisor = {1'b0,8'd126,b[22:0]};

assign denominator = divisor;

assign exp_a = a[30:23] + shift;

assign op_a = {a[31],exp_a,a[22:0]};

assign op_a_change = op_a;

//32'hC00B_4B4B = (-37)/17
Multiplication x0(32'hC00B_4B4B,divisor,,,,Intermediate_X0);

//32'h4034_B4B5 = 48/17
Addition_Subtraction X0(Intermediate_X0,32'h4034_B4B5,1'b0,,Iteration_X0);

Iteration X1(Iteration_X0,divisor,Iteration_X1);

Iteration X2(Iteration_X1,divisor,Iteration_X2);

Iteration X3(Iteration_X2,divisor,Iteration_X3);

Multiplication END(Iteration_X3,op_a,,,,solution);

assign res = {sign,solution[30:0]};
endmodule

`define N_TESTS 100000

module division_tb;

	reg clk = 0;
	reg [31:0] a;
	reg [31:0] b;
	
	wire [31:0] res;
	wire exception;

	reg [31:0] expected_res;

	reg [95:0] testVector [`N_TESTS-1:0];

	reg test_stop_enable;

	integer mcd;
	integer test_n = 0;
	integer pass   = 0;
	integer error  = 0;

	division DUT(a,b,exception,res);

	always #5 clk = ~clk;

	initial  
	begin 
		$readmemh(""Test.txt"", testVector);
		mcd = $fopen(""Error_Results.txt"");
	end 

	always @(posedge clk) 
	begin
			{a,b,expected_res} = testVector[test_n];
			test_n = test_n + 1'b1;

			#2;
			if (res[31:12] == expected_res[31:12])
				begin
					//$fdisplay (mcd,""TestPassed Test Number -> %d"",test_n);
					pass = pass + 1'b1;
				end

			if (res[31:12] != expected_res[31:12])
				begin
					$fdisplay (mcd,""Test Failed Expected res = %h,Obtained res = %h,Test Number-> %d"",expected_res,res,test_n);
					$display (""Zero Division Error or some other error"",mcd,""Test Failed Expected res = %h,Obtained res = %h,Test Number-> %d"",expected_res,res,test_n);
					error = error + 1'b1;
				end
			
			if (test_n >= `N_TESTS) 
			begin
				$fdisplay(mcd,""Completed %d tests, %d passes and %d fails."", test_n, pass, error);
				test_stop_enable = 1'b1;
			end
	end

always @(posedge test_stop_enable)
begin
$fclose(mcd);
$finish;
end

endmodule

",division.txt,32-Verilog-Mini-Projects\division.txt
"[Keyword]: dual_address_ram

[Design Category]: Memory Circuits

[Design Function Description]:
The design implements a dual-port RAM with separate read and write ports. It allows simultaneous read and write operations on different addresses. Port 0 is used for writing data into the RAM when enabled, and both ports can be used for reading data from the RAM when enabled.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize write operations.
- `wr_en`: Write enable signal for port 0, allowing data to be written to the RAM when high.
- `data_in[7:0]`: 8-bit input data to be written into the RAM at the address specified by `addr_in_0`.
- `addr_in_0[3:0]`: 4-bit address input for port 0, specifying the location in RAM to write data.
- `addr_in_1[3:0]`: 4-bit address input for port 1, specifying the location in RAM to read data.
- `port_en_0`: Enable signal for port 0, allowing read and write operations when high.
- `port_en_1`: Enable signal for port 1, allowing read operations when high.

[Output Signal Description]:
- `data_out_0[7:0]`: 8-bit output data from port 0, providing the data stored at the address specified by `addr_in_0` when port 0 is enabled.
- `data_out_1[7:0]`: 8-bit output data from port 1, providing the data stored at the address specified by `addr_in_1` when port 1 is enabled.


[Design Detail]:
module dual_port_ram 
    (   input clk, 		 //clock
        input wr_en,   		 //write enable for port 0
        input [7:0] data_in,     //Input data to port 0.
        input [3:0] addr_in_0,   //address for port 0
        input [3:0] addr_in_1,   //address for port 1
        input port_en_0,    	 //enable port 0.
        input port_en_1,    	 //enable port 1.
        output [7:0] data_out_0, //output data from port 0.
        output [7:0] data_out_1  //output data from port 1.
    );

//memory declaration.
reg [7:0] ram[0:15];

//writing to the RAM
always@(posedge clk)
begin
    if(port_en_0 == 1 && wr_en == 1)    // check enable signal and if write enable is ON
        ram[addr_in_0] <= data_in;
end

//always reading from the ram, irrespective of clock.
assign data_out_0 = port_en_0 ? ram[addr_in_0] : 'dZ;   
assign data_out_1 = port_en_1 ? ram[addr_in_1] : 'dZ;   

endmodule 


module dual_port_ram_tb;

    // Inputs
    reg clk;
    reg wr_en;
    reg [7:0] data_in;
    reg [3:0] addr_in_0;
    reg [3:0] addr_in_1;
    reg port_en_0;
    reg port_en_1;

    // Outputs
    wire [7:0] data_out_0;
    wire [7:0] data_out_1;
    
    integer i;

    // Instantiate the Unit Under Test (UUT)
    dual_port_ram uut (
        .clk(clk), 
        .wr_en(wr_en), 
        .data_in(data_in), 
        .addr_in_0(addr_in_0), 
        .addr_in_1(addr_in_1), 
        .port_en_0(port_en_0), 
        .port_en_1(port_en_1), 
        .data_out_0(data_out_0), 
        .data_out_1(data_out_1)
    );
    
    always
        #5 clk = ~clk;

    initial begin
        // Initialize Inputs
        clk = 1;
        addr_in_1 = 0;
        port_en_0 = 0;
        port_en_1 = 0;
        wr_en = 0;
        data_in = 0;
        addr_in_0 = 0;  
        #20;
        //Write all the locations of RAM
        port_en_0 = 1;  
        wr_en = 1;
      for(i=1; i <= 16; i = i + 1) begin
            data_in = i;
            addr_in_0 = i-1;
            #10;
        end
        wr_en = 0;
        port_en_0 = 0;  
        //Read from port 1, all the locations of RAM.
        port_en_1 = 1;  
        for(i=1; i <= 16; i = i + 1) begin
            addr_in_1 = i-1;
            #10;
        end
        port_en_1 = 0;
    end
      
endmodule
",dual_address_ram.txt,32-Verilog-Mini-Projects\dual_address_ram.txt
"[Keyword]: dual_address_rom

[Design Category]: Memory Circuits

[Design Function Description]:
The design is a dual-port ROM (Read-Only Memory) module that allows reading from two separate addresses simultaneously. It includes a testbench to verify its functionality. The ROM is initialized with predefined data values, and the module supports enabling and disabling of each port independently.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations within the ROM.
- `wr_en`: Write enable signal, although typically ROMs do not support writing; this signal is used here to control the address loading.
- `addr_in_0`: 4-bit address input for port 0, used to select which data to read from the ROM.
- `addr_in_1`: 4-bit address input for port 1, used to select which data to read from the ROM.
- `port_en_0`: Enable signal for port 0, allowing data to be read from the ROM when high.
- `port_en_1`: Enable signal for port 1, allowing data to be read from the ROM when high.

[Output Signal Description]:
- `data_out_0`: 8-bit data output from port 0, providing the data stored at the address specified by `addr_in_0` when `port_en_0` is high.
- `data_out_1`: 8-bit data output from port 1, providing the data stored at the address specified by `addr_in_1` when `port_en_1` is high.


[Design Detail]:
module dual_port_rom 
	(input clk,
	 input wr_en,
	 input [3:0] addr_in_0,
	 input [3:0] addr_in_1,
	 input port_en_0,
	 input port_en_1,
	 output [7:0] data_out_0,
	 output [7:0] data_out_1);

reg   [4:0] raddr;
reg[7:0] rom [7:0];

 always @(posedge clk)
 begin
    if (port_en_0 == 1 && wr_en == 1)
       raddr <= addr_in_0;
 end

 always @(raddr) 
 begin
    if (port_en_0 == 1 && wr_en == 1)
       case(raddr)
   4'b0000: rom[raddr] = 8'b00100100;
   4'b0001: rom[raddr] = 8'b00100011;
   4'b0010: rom[raddr] = 8'b11100010;
   4'b0011: rom[raddr] = 8'b00100001;
   4'b0100: rom[raddr] = 8'b01000101;
   4'b0101: rom[raddr] = 8'b10101110;
   4'b0110: rom[raddr] = 8'b11001011;
   4'b0111: rom[raddr] = 8'b00000000;
   4'b1000: rom[raddr] = 8'b10100011;
   4'b1001: rom[raddr] = 8'b00101010;
   4'b1010: rom[raddr] = 8'b11101100;
   4'b1011: rom[raddr] = 8'b00100010;
   4'b1100: rom[raddr] = 8'b01000000;
   4'b1101: rom[raddr] = 8'b10100000;
   4'b1110: rom[raddr] = 8'b00001100;
   4'b1111: rom[raddr] = 8'b00000000;
   default: rom[raddr] = 8'bXXXXXXXX;
       endcase
 end
assign data_out_0 = port_en_0 ? rom[addr_in_0] : 'dZ;   
assign data_out_1 = port_en_1 ? rom[addr_in_1] : 'dZ;  
endmodule

module dual_port_rom_tb;

    // Inputs
    reg clk;
    reg wr_en;
    reg [3:0] addr_in_0;
    reg [3:0] addr_in_1;
    reg port_en_0;
    reg port_en_1;

    // Outputs
    wire [7:0] data_out_0;
    wire [7:0] data_out_1;
    
    integer i;

    // Instantiate the Unit Under Test (UUT)
    dual_port_rom uut (
        .clk(clk), 
        .wr_en(wr_en),  
        .addr_in_0(addr_in_0), 
        .addr_in_1(addr_in_1), 
        .port_en_0(port_en_0), 
        .port_en_1(port_en_1), 
        .data_out_0(data_out_0), 
        .data_out_1(data_out_1)
    );
    
    always
        #5 clk = ~clk;

    initial begin
        // Initialize Inputs
        clk = 1;
        addr_in_1 = 0;
        port_en_0 = 0;
        port_en_1 = 0;
        wr_en = 0;
        addr_in_0 = 0;  
        #20
        port_en_0 = 1;  
        wr_en = 1;
      for(i=1; i <= 16; i = i + 1) begin
            addr_in_0 = i-1;
            #10;
        end
        wr_en = 0;
        port_en_0 = 0;  
        //Read from port 1, all the locations of ROM.
        port_en_1 = 1;  
        for(i=1; i <= 16; i = i + 1) begin
            addr_in_1 = i-1;
            #10;
        end
        port_en_1 = 0;
    end
      
endmodule
",dual_address_rom.txt,32-Verilog-Mini-Projects\dual_address_rom.txt
"[Keyword]: D_FlipFlop

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a D Flip-Flop with an asynchronous clear. It captures the value of the input D on the rising edge of the clock signal (clk) and outputs it on O. If the clear signal is asserted (active low), the output O is reset to 0 regardless of the clock.

[Input Signal Description]:
- D: Data input signal. The value of D is captured on the rising edge of the clock if the clear signal is not active.
- clk: Clock input signal. The rising edge of this signal triggers the capturing of the D input.
- clear: Asynchronous clear input signal. When this signal is low, it resets the output O to 0 immediately, regardless of the clock.

[Output Signal Description]:
- O: Output signal. It holds the value of the D input captured on the rising edge of the clock, unless the clear signal is active, in which case it is reset to 0.


[Design Detail]:
`timescale 1ns / 1ps

module D_FlipFlop(O , D , clk , clear);

input D , clk , clear;
output reg O;

always@(posedge clk , negedge clear)
begin
	
	if(clear == 1'b0)
		O <= 1'b0;
	else
		O <= D;
	
end
endmodule
",D_FlipFlop.txt,32-Verilog-Mini-Projects\D_FlipFlop.txt
"[Keyword]: fifo

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements a FIFO (First-In-First-Out) buffer with a depth of 8 and a width of 32 bits. It allows for data to be written into the buffer and read out in the order it was received. The buffer provides status signals to indicate whether it is empty or full.

[Input Signal Description]:
- Clk: Clock signal for synchronizing the read and write operations.
- dataIn[31:0]: 32-bit input data to be written into the FIFO buffer.
- RD: Read enable signal; when high, it allows data to be read from the buffer.
- WR: Write enable signal; when high, it allows data to be written into the buffer.
- EN: Enable signal; when high, it allows the FIFO operations to proceed.
- Rst: Reset signal; when high, it resets the read and write counters.

[Output Signal Description]:
- dataOut[31:0]: 32-bit output data read from the FIFO buffer.
- EMPTY: Status signal indicating whether the FIFO buffer is empty (high when empty).
- FULL: Status signal indicating whether the FIFO buffer is full (high when full).


[Design Detail]:
module FIFObuffer( Clk, 

                   dataIn, 

                   RD, 

                   WR, 

                   EN, 

                   dataOut, 

                   Rst,

                   EMPTY, 

                   FULL 

                   ); 

input  Clk, 

       RD, 

       WR, 

       EN, 

       Rst;

output  EMPTY, 

        FULL;

input   [31:0]    dataIn;

output reg [31:0] dataOut; // internal registers 

reg [2:0]  Count = 0; 

reg [31:0] FIFO [0:7]; 

reg [2:0]  readCounter = 0, 

           writeCounter = 0; 

assign EMPTY = (Count==0)? 1'b1:1'b0; 

assign FULL = (Count==8)? 1'b1:1'b0; 

always @ (posedge Clk) 

begin 

 if (EN==0); 

 else begin 

  if (Rst) begin 

   readCounter = 0; 

   writeCounter = 0; 

  end 

  else if (RD ==1'b1 && Count!=0) begin 

   dataOut  = FIFO[readCounter]; 

   readCounter = readCounter+1; 

  end 

  else if (WR==1'b1 && Count<8) begin
   FIFO[writeCounter]  = dataIn; 

   writeCounter  = writeCounter+1; 

  end 

  else; 

 end 

 if (writeCounter==8) 

  writeCounter=0; 

 else if (readCounter==8) 

  readCounter=0; 

 else;

 if (readCounter > writeCounter) begin 

  Count=readCounter-writeCounter; 

 end 

 else if (writeCounter > readCounter) 

  Count=writeCounter-readCounter; 

 else;

end 

endmodule
",fifo.txt,32-Verilog-Mini-Projects\fifo.txt
"[Keyword]: fixed_point_adder

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a parameterized fixed-point adder/subtractor. It performs addition or subtraction on two N-bit fixed-point numbers, where the most significant bit (MSB) is used as the sign bit. The operation is determined based on the sign bits of the inputs. If both inputs have the same sign, they are added; if they have different signs, subtraction is performed.

[Input Signal Description]:
- a[N-1:0]: An N-bit input operand, where the MSB is the sign bit and the remaining bits represent the magnitude.
- b[N-1:0]: Another N-bit input operand, similarly structured with the MSB as the sign bit.

[Output Signal Description]:
- c[N-1:0]: The N-bit result of the addition or subtraction operation, with the MSB as the sign bit and the remaining bits representing the magnitude.


[Design Detail]:
module qadd #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
    input [N-1:0] a,
    input [N-1:0] b,
    output [N-1:0] c
    );

reg [N-1:0] res;

assign c = res;

always @(a,b) begin
	// both negative or both positive
	if(a[N-1] == b[N-1]) begin				
		res[N-2:0] = a[N-2:0] + b[N-2:0];	 	
		res[N-1] = a[N-1];				
															
															  
		end												
	//	one of them is negative...
	else if(a[N-1] == 0 && b[N-1] == 1) begin		
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] - b[N-2:0];			
			res[N-1] = 0;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] - a[N-2:0];			
			if (res[N-2:0] == 0)
				res[N-1] = 0;										
			else
				res[N-1] = 1;										
			end
		end
	else begin												
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] - b[N-2:0];			
			if (res[N-2:0] == 0)
				res[N-1] = 0;										
			else
				res[N-1] = 1;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] - a[N-2:0];			
			res[N-1] = 0;										
			end
		end
	end
endmodule

module Test_add;

	// Inputs
	reg [31:0] a;
	reg [31:0] b;

	// Outputs
	wire [31:0] c;

	// Instantiate the Unit Under Test (UUT)
	qadd #(19,32) uut (
		.a(a), 
		.b(b), 
		.c(c)
	);

	//	These are to monitor the values...
	wire	[30:0]	c_out;
	wire	[30:0]	a_in;
	wire	[30:0]	b_in;
	wire				a_sign;
	wire				b_sign;
	wire				c_sign;
	
	
	assign	a_in = a[30:0];
	assign	b_in = b[30:0];
	assign	c_out = c[30:0];
	assign	a_sign = a[31];
	assign	b_sign = b[31];
	assign	c_sign = c[31];
	
	
	initial begin
		// Initialize Inputs
		a[30:0] = 0;
		a[31] = 0;
		b[31] = 1;
		b[30:0] = 0;

		// Wait 100 ns for global reset to finish
		#100;
        
		// Add stimulus here
		forever begin
			#1 a = a+5179347;			
			a[31] = 0;					// a is negative...
			b[31] = 1;
			
			
			if (a[30:0] > 2.1E9)				// input will always be ""positive""
				begin
					a = 0;
					b[31] = 1;			// b is negative...
					b[30:0] = b[30:0] + 3779351;
				end
		end

	end
      
endmodule
",fixed_point_adder.txt,32-Verilog-Mini-Projects\fixed_point_adder.txt
"[Keyword]: fixed_point_divider

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a parameterized division circuit that performs division of two N-bit numbers, producing a quotient and detecting overflow. The circuit is designed to handle signed division and provides a complete signal to indicate when the operation is finished.

[Input Signal Description]:
- `i_dividend[N-1:0]`: The dividend input for the division operation, which is an N-bit wide signal.
- `i_divisor[N-1:0]`: The divisor input for the division operation, also an N-bit wide signal.
- `i_start`: A control signal to start the division operation.
- `i_clk`: The clock signal used to synchronize the operations within the circuit.

[Output Signal Description]:
- `o_quotient_out[N-1:0]`: The output signal representing the quotient of the division operation. The most significant bit indicates the sign of the quotient.
- `o_complete`: A signal that indicates when the division operation is complete.
- `o_overflow`: A signal that indicates if an overflow occurred during the division operation.


[Design Detail]:
module qdiv #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
	input 	[N-1:0] i_dividend,
	input 	[N-1:0] i_divisor,
	input 	i_start,
	input 	i_clk,
	output 	[N-1:0] o_quotient_out,
	output 	o_complete,
	output	o_overflow
	);
 
	reg [2*N+Q-3:0]	reg_working_quotient;	
	reg [N-1:0] 		reg_quotient;				
	reg [N-2+Q:0] 		reg_working_dividend;	
	reg [2*N+Q-3:0]	reg_working_divisor;		
 
	reg [N-1:0] 			reg_count; 		
													
										 
	reg					reg_done;			
	reg					reg_sign;			
	reg					reg_overflow;		
 
	initial reg_done = 1'b1;				
	initial reg_overflow = 1'b0;			
	initial reg_sign = 1'b0;				

	initial reg_working_quotient = 0;	
	initial reg_quotient = 0;				
	initial reg_working_dividend = 0;	
	initial reg_working_divisor = 0;		
 	initial reg_count = 0; 		

 
	assign o_quotient_out[N-2:0] = reg_quotient[N-2:0];	
	assign o_quotient_out[N-1] = reg_sign;						
	assign o_complete = reg_done;
	assign o_overflow = reg_overflow;
 
	always @( posedge i_clk ) begin
		if( reg_done && i_start ) begin										
			
			reg_done <= 1'b0;														
			reg_count <= N+Q-1;											
			reg_working_quotient <= 0;									
			reg_working_dividend <= 0;									
			reg_working_divisor <= 0;									
			reg_overflow <= 1'b0;										

			reg_working_dividend[N+Q-2:Q] <= i_dividend[N-2:0];				
			reg_working_divisor[2*N+Q-3:N+Q-1] <= i_divisor[N-2:0];		

			reg_sign <= i_dividend[N-1] ^ i_divisor[N-1];		
			end 
		else if(!reg_done) begin
			reg_working_divisor <= reg_working_divisor >> 1;	
			reg_count <= reg_count - 1;								

			//	If the dividend is greater than the divisor
			if(reg_working_dividend >= reg_working_divisor) begin
				reg_working_quotient[reg_count] <= 1'b1;										
				reg_working_dividend <= reg_working_dividend - reg_working_divisor;	
				end
 
			//stop condition
			if(reg_count == 0) begin
				reg_done <= 1'b1;										
				reg_quotient <= reg_working_quotient;			
				if (reg_working_quotient[2*N+Q-3:N]>0)
					reg_overflow <= 1'b1;
					end
			else
				reg_count <= reg_count - 1;	
			end
		end
endmodule

module Test_Div;

	// Inputs
	reg [31:0] i_dividend;
	reg [31:0] i_divisor;
	reg i_start;
	reg i_clk;

	// Outputs
	wire [31:0] o_quotient_out;
	wire o_complete;
	wire o_overflow;

	// Instantiate the Unit Under Test (UUT)
	qdiv uut (
		.i_dividend(i_dividend), 
		.i_divisor(i_divisor), 
		.i_start(i_start), 
		.i_clk(i_clk), 
		.o_quotient_out(o_quotient_out), 
		.o_complete(o_complete), 
		.o_overflow(o_overflow)
	);

	reg [10:0]	count;

	initial begin
		// Initialize Inputs
		i_dividend = 1;
		i_divisor = 1;
		i_start = 0;
		i_clk = 0;
		
		count <= 0;

		// Wait 100 ns for global reset to finish
		#100;

		// Add stimulus here
		forever #2 i_clk = ~i_clk;
	end
        
		always @(posedge i_clk) begin
			if (count == 47) begin
				count <= 0;
				i_start <= 1'b1;
				end
			else begin				
				count <= count + 1;
				i_start <= 1'b0;
				end
			end

		always @(count) begin
			if (count == 47) begin
				if ( i_divisor > 32'h1FFFFFFF ) begin
					i_divisor <= 1;
					i_dividend = (i_dividend << 1) + 3;
					end
				else
					i_divisor = (i_divisor << 1) + 1;
				end
			end
			
	always @(posedge o_complete)
		$display (""%b,%b,%b, %b"", i_dividend, i_divisor, o_quotient_out, o_overflow);		

endmodule
",fixed_point_divider.txt,32-Verilog-Mini-Projects\fixed_point_divider.txt
"[Keyword]: fixed_point_multiplier

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a fixed-point multiplier using parameterized bit-widths for the multiplicand and multiplier. It performs multiplication on the fractional parts of the inputs and provides the result as a fixed-point number. The design also checks for overflow conditions during the multiplication process.

[Input Signal Description]:
- i_multiplicand[N-1:0]: The multiplicand input, a fixed-point number with a total bit-width of N.
- i_multiplier[N-1:0]: The multiplier input, also a fixed-point number with a total bit-width of N.

[Output Signal Description]:
- o_result[N-1:0]: The output result of the multiplication, represented as a fixed-point number with a total bit-width of N.
- ovr: A flag indicating whether an overflow occurred during the multiplication process.


[Design Detail]:
module qmult #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
	 input			[N-1:0]	i_multiplicand,
	 input			[N-1:0]	i_multiplier,
	 output			[N-1:0]	o_result,
	 output	reg				ovr
	 );
	 
	
	
	reg [2*N-1:0]	r_result;		
											
	reg [N-1:0]		r_RetVal;
	

	assign o_result = r_RetVal;	
	
	always @(i_multiplicand, i_multiplier)	begin						
		r_result <= i_multiplicand[N-2:0] * i_multiplier[N-2:0];	
																
		ovr <= 1'b0;															
		end
	
		
	always @(r_result) begin													
		r_RetVal[N-1] <= i_multiplicand[N-1] ^ i_multiplier[N-1];	
		r_RetVal[N-2:0] <= r_result[N-2+Q:Q];								
																						
		if (r_result[2*N-2:N-1+Q] > 0)										
			ovr <= 1'b1;
		end

endmodule
module Test_mult;

	// Inputs
	reg [31:0] i_multiplicand;
	reg [31:0] i_multiplier;

	// Outputs
	wire [31:0] o_result;
	wire			ovr;
	
	// Instantiate the Unit Under Test (UUT)
	qmult #(19,32) uut (
		.i_multiplicand(i_multiplicand), 
		.i_multiplier(i_multiplier), 
		.o_result(o_result),
		.ovr(ovr)
	);

	initial begin
		$monitor (""%b,%b,%b,%b"", i_multiplicand, i_multiplier, o_result, ovr);		
		
		// Initialize Inputs
 		i_multiplicand = 32'b00000000000110010010000111111011;	//pi = 3.141592
		i_multiplicand[31] = 0;												
		i_multiplier[31] = 0;												
		i_multiplier[30:0] = 0;

		// Wait 100 ns for global reset to finish
		#100;
		#100 i_multiplier[0] = 1;		//	1.91E-6
  	end

	// Add stimulus here
	always begin
		#10 i_multiplier[30:0] = (i_multiplier[30:0] << 1) + 1;		
	end
      
endmodule
",fixed_point_multiplier.txt,32-Verilog-Mini-Projects\fixed_point_multiplier.txt
"[Keyword]: fixed_point_subtractor

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a parameterized subtraction operation for fixed-point numbers represented in two's complement format. It handles subtraction between two N-bit numbers, `a` and `b`, and outputs the result `c`. The subtraction logic considers the sign bits to correctly handle both positive and negative numbers.

[Input Signal Description]:
- `a[N-1:0]`: N-bit input signal representing the first operand in two's complement format.
- `b[N-1:0]`: N-bit input signal representing the second operand in two's complement format.

[Output Signal Description]:
- `c[N-1:0]`: N-bit output signal representing the result of the subtraction operation between `a` and `b`, also in two's complement format.


[Design Detail]:
module qsubtract #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
    input [N-1:0] a,
    input [N-1:0] b,
    output [N-1:0] c
    );

reg [N-1:0] res;

assign c = res;

always @(a,b) begin
	// both negative or both positive
	if(a[N-1] == b[N-1]) begin					
		res[N-2:0] = a[N-2:0] - b[N-2:0];		
		res[N-1] = a[N-1];							
														
															
		end												
	//	one of them is negative...
	else if(a[N-1] == 0 && b[N-1] == 1) begin		
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] + b[N-2:0];			
			res[N-1] = 0;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] + a[N-2:0];		
			if (res[N-2:0] == 0)
				res[N-1] = 0;									
			else
				res[N-1] = 1;									
			end
		end
	else begin												
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] + b[N-2:0];			
			if (res[N-2:0] == 0)
				res[N-1] = 0;										
			else
				res[N-1] = 1;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] + a[N-2:0];			
			res[N-1] = 0;										
			end
		end
	end
endmodule

module Test_subtract;

	// Inputs
	reg [31:0] a;
	reg [31:0] b;

	// Outputs
	wire [31:0] c;

	// Instantiate the Unit Under Test (UUT)
	qsubtract #(19,32) uut (
		.a(a), 
		.b(b), 
		.c(c)
	);

	//	These are to monitor the values...
	wire	[30:0]	c_out;
	wire	[30:0]	a_in;
	wire	[30:0]	b_in;
	wire				a_sign;
	wire				b_sign;
	wire				c_sign;
	
	
	assign	a_in = a[30:0];
	assign	b_in = b[30:0];
	assign	c_out = c[30:0];
	assign	a_sign = a[31];
	assign	b_sign = b[31];
	assign	c_sign = c[31];
	
	
	initial begin
		// Initialize Inputs
		a[30:0] = 0;
		a[31] = 0;
		b[31] = 1;
		b[30:0] = 0;

		// Wait 100 ns for global reset to finish
		#100;
        
		// Add stimulus here
		forever begin
			#1 a = a+5179347;			
			a[31] = 0;					// a is negative...
			b[31] = 1;
			
			
			if (a[30:0] > 2.1E9)			       // input will always be ""positive""
				begin
					a = 0;
					b[31] = 1;		       // b is negative...
					b[30:0] = b[30:0] + 3779351;
				end
		end

	end
      
endmodule
",fixed_point_subtractor.txt,32-Verilog-Mini-Projects\fixed_point_subtractor.txt
"[Keyword]: fraction_multiplication

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a sequential logic circuit for multiplying two 4-bit binary numbers, `Mplier` and `Mcand`, using a shift-and-add algorithm. The result is a 7-bit product. The multiplication process is controlled by a state machine that progresses through several states to perform the necessary operations.

[Input Signal Description]:
- `CLK`: Clock signal that synchronizes the state transitions and operations.
- `St`: Start signal that initiates the multiplication process when set to 1.
- `Mplier[3:0]`: 4-bit multiplier input.
- `Mcand[3:0]`: 4-bit multiplicand input.

[Output Signal Description]:
- `Product[6:0]`: 7-bit output representing the product of the multiplication.
- `Done`: Signal indicating the completion of the multiplication process, set to 1 when the operation is complete.


[Design Detail]:
`define M B[0]
 module fraction_multiplication (CLK, St, Mplier, Mcand, Product, Done);
 input CLK;
 input St;
 input[3:0] Mplier;
 input[3:0] Mcand;
 output[6:0] Product;
 output Done;
 reg[2:0] State;
 reg[3:0] A;
 reg[3:0] B;
 reg[3:0] addout;
 initial
 begin
 State = 0;
 end
 
 always @(posedge CLK)
 begin
 case (State)
 0 :
 begin
 if (St == 1'b1)
 begin
 A <= 4'b0000 ;
 B <= Mplier ;
   State <= 1 ;
 end
 else
 State <= 0;
 end
 1, 2, 3 :
 begin
 if (`M == 1'b1)
 begin
 addout = A + Mcand;
 A <= {Mcand[3], addout[3:1]} ;
 B <= {addout[0], B[3:1]} ;
 end
 else
 begin
 A <= {A[3], A[3:1]} ;
 B <= {A[0], B[3:1]} ;
 end
 State <= State + 1 ;
 end
 4 :
 begin
 if (`M == 1'b1)
 begin
 addout = A + ~Mcand + 1;
 A <= {~Mcand[3], addout[3:1]} ;
 B <= {addout[0], B[3:1]} ;
 end
 else
 begin
 A <= {A[3], A[3:1]} ;
 B <= {A[0], B[3:1]} ;
 end
 State <= 5 ;
 end
 5 :
 begin
 State <= 0 ;
 end
 
 default :
 begin
 State <= 0 ;
 end
 endcase
 end
 assign Done = (State == 5) ? 1'b1 : 1'b0 ;
 assign Product = {A[2:0], B} ;
endmodule
",fraction_multiplication.txt,32-Verilog-Mini-Projects\fraction_multiplication.txt
"[Keyword]: high_radix_multiplication

[Design Category]: Arithmetic Circuits

[Design Function Description]: 
This design implements a multiplier circuit using a sequential approach. It multiplies two 16-bit signed integers, `x` and `y`, to produce a 32-bit signed product, `out`. The multiplication is performed using a technique similar to Booth's algorithm, which involves generating partial products and accumulating them to form the final product.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations within the multiplier.
- `reset`: Reset signal to initialize the circuit and clear the outputs and internal registers.
- `x[15:0]`: 16-bit signed integer input, one of the multiplicands.
- `y[15:0]`: 16-bit signed integer input, the other multiplicand.

[Output Signal Description]:
- `out[31:0]`: 32-bit signed integer output representing the product of the inputs `x` and `y`.


[Design Detail]:


module multiplier (clk,reset,x,y,out);
input clk,reset;
input  [15:0] x,y;
output reg [31:0] out;

reg [2:0] c=0 ;
 
reg   [31:0] pp=0; //partial products
reg   [31:0] spp=0; //shifted partial products
reg   [31:0] prod=0;
reg [15:0] i=0,j=0;
reg flag=0, temp=0 ;
wire [15:0] inv_x ;
//assign x= (~x) +1'b1;
assign inv_x = (~x) +1'b1;
always@(posedge clk)
begin
if(reset)
begin
out=0;
c=0;
pp=0;
flag=0;
spp=0;
i=0;
j=0;
prod=0;
end
else begin
 
if(!flag)
c={y[1],y[0],1'b0};
flag=1;
case(c)
////////////////////////
3'b000,3'b111: begin
if(i<8)
begin  i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]}; end
else
c=3'bxxx;
end
////////////////////////////
3'b001,3'b010:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{16{x[15]}},x};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
///////////////////////////
3'b011:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{15{x[15]}},x,1'b0};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
///////////////////////////
3'b100:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{15{inv_x[15]}},inv_x,1'b0};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
////////////////////////////////////
3'b101, 3'b110:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{16{inv_x[15]}},inv_x};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
////////////////
default:
out= prod;
endcase
end
end
 
endmodule
",high_radix_multiplication.txt,32-Verilog-Mini-Projects\high_radix_multiplication.txt
"[Keyword]: lfsr

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 4-bit Linear Feedback Shift Register (LFSR). An LFSR is a shift register whose input bit is a linear function of its previous state. In this case, the feedback is generated by XORing the two most significant bits of the register, and the result is inverted before being fed back into the least significant bit.

[Input Signal Description]:
- clk: Clock signal that triggers the shift operation on the rising edge.
- rst: Asynchronous reset signal that initializes the LFSR output to 0 when high.

[Output Signal Description]:
- out[3:0]: 4-bit output representing the current state of the LFSR.


[Design Detail]:
module lfsr (out, clk, rst);

  output reg [3:0] out;
  input clk, rst;

  wire feedback;

  assign feedback = ~(out[3] ^ out[2]);

always @(posedge clk, posedge rst)
  begin
    if (rst)
      out = 4'b0;
    else
      out = {out[2:0],feedback};
  end
endmodule
",lfsr.txt,32-Verilog-Mini-Projects\lfsr.txt
"[Keyword]: log

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design calculates the natural logarithm and the base-10 logarithm of two 32-bit input numbers, `a` and `b`, respectively. The results are scaled by a factor of 1,000,000,000 and output as 128-bit numbers.

[Input Signal Description]:
- `a[31:0]`: A 32-bit input signal representing the number for which the natural logarithm (ln) is to be calculated.
- `b[31:0]`: A 32-bit input signal representing the number for which the base-10 logarithm (log10) is to be calculated.

[Output Signal Description]:
- `a_out[127:0]`: A 128-bit output signal representing the scaled natural logarithm of `a` (ln(a) * 1,000,000,000).
- `b_out[127:0]`: A 128-bit output signal representing the scaled base-10 logarithm of `b` (log10(b) * 1,000,000,000).


[Design Detail]:
module logarithm(input [31:0] a,b,output [127:0] a_out, b_out);
  assign a_out = 1000000000 * $ln(a);
  assign b_out = 1000000000 * $log10(b);
endmodule

module logarithm_tb;
  reg [31:0] a;
  reg [31:0] b;
  wire [127:0] a_out;
  wire [127:0] b_out;
  logarithm uut(a,b,a_out,b_out);
initial begin
a=0;b=0;
#20 a= 123;b=123;
#20 a =4;b=4; 
#20 a=234;b=34;
end

initial 
  $monitor("" a = %d, b = %d, ln(a) = %d, log10(b) = %d"",a,b,a_out,b_out);

endmodule
",log.txt,32-Verilog-Mini-Projects\log.txt
"[Keyword]: Loopback

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements an SPI (Serial Peripheral Interface) loopback system. It consists of an SPI master and an SPI slave module. The master sends data to the slave, and the slave sends data back to the master, effectively creating a loopback configuration. This setup is often used for testing and verifying SPI communication.

[Input Signal Description]:
- `clk`: System clock input signal.
- `rst_n`: Active-low reset signal to initialize the system.
- `data_m_in[DATA_WIDTH-1:0]`: Data input for the SPI master.
- `data_s_in[DATA_WIDTH-1:0]`: Data input for the SPI slave.
- `start_m`: Signal to start the SPI master transmission.

[Output Signal Description]:
- `finish_m`: Signal indicating the completion of the SPI master transmission.
- `data_m_out[DATA_WIDTH-1:0]`: Data output from the SPI master.
- `data_s_out[DATA_WIDTH-1:0]`: Data output from the SPI slave.
- `data_valid_s`: Signal indicating that the data from the SPI slave is valid.


[Design Detail]:
`timescale 1ns/1ps

module SPI_loopback
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 0					,	//SPI mode selection (mode 0 default)
				CPHA			= 0					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input							clk			,
	input							rst_n		,
	input		[DATA_WIDTH-1:0]	data_m_in	,
	input		[DATA_WIDTH-1:0]	data_s_in	,
	input							start_m		,
	output							finish_m	,
	output		[DATA_WIDTH-1:0]	data_m_out	,
	output		[DATA_WIDTH-1:0]	data_s_out	,
	output							data_valid_s	 
);

wire				miso	;
wire				mosi	;
wire				cs_n	;
wire				sclk	;

spi_master 
#(
	.CLK_FREQUENCE (CLK_FREQUENCE ),
	.SPI_FREQUENCE (SPI_FREQUENCE ),
	.DATA_WIDTH    (DATA_WIDTH    ),
	.CPOL          (CPOL          ),
	.CPHA          (CPHA          ) 
)
u_spi_master(
	.clk      (clk      ),
	.rst_n    (rst_n    ),
	.data_in  (data_m_in  ),
	.start    (start_m    ),
	.miso     (miso     ),
	.sclk     (sclk     ),
	.cs_n     (cs_n     ),
	.mosi     (mosi     ),
	.finish   (finish_m   ),
	.data_out (data_m_out )
);

SPI_Slave 
#(
	.CLK_FREQUENCE (CLK_FREQUENCE ),
	.SPI_FREQUENCE (SPI_FREQUENCE ),
	.DATA_WIDTH    (DATA_WIDTH    ),
	.CPOL          (CPOL          ),
	.CPHA          (CPHA          ) 
)
u_SPI_Slave(
	.clk        (clk        ),
	.rst_n      (rst_n      ),
	.data_in    (data_s_in    ),
	.sclk       (sclk       ),
	.cs_n       (cs_n       ),
	.mosi       (mosi       ),
	.miso       (miso       ),
	.data_valid (data_valid_s ),
	.data_out   (data_s_out   )
);

endmodule
",Loopback.txt,32-Verilog-Mini-Projects\Loopback.txt
"[Keyword]: Master

[Design Category]: Interface Circuits

[Design Function Description]:
The design is an SPI (Serial Peripheral Interface) master module. It facilitates communication with SPI slave devices by generating the necessary clock signals, managing data transmission and reception, and controlling the chip select line. The module supports configurable clock frequency, data width, and SPI modes (CPOL and CPHA).

[Input Signal Description]:
- `clk`: System clock input used to drive the SPI master operations.
- `rst_n`: Active-low reset signal to initialize the module.
- `data_in[DATA_WIDTH-1:0]`: Data to be sent out via the MOSI line.
- `start`: A pulse signal to initiate the SPI transmission.
- `miso`: Master In Slave Out line for receiving data from the SPI slave.

[Output Signal Description]:
- `sclk`: SPI clock signal generated by the master.
- `cs_n`: Chip select signal to enable communication with the SPI slave.
- `mosi`: Master Out Slave In line for sending data to the SPI slave.
- `finish`: A pulse signal indicating the completion of the SPI transmission and the validity of `data_out`.
- `data_out[DATA_WIDTH-1:0]`: Data received from the SPI slave via the MISO line.



[Design Detail]:
`timescale 1ns/1ps

module spi_master
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 0					,	//SPI mode selection (mode 0 default)
				CPHA			= 0					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by mosi
	input								start		,	//a pluse to start the SPI transmission
	input								miso		,	//spi bus miso input
	output	reg							sclk		,	//spi bus sclk
	output	reg							cs_n		,	//spi bus slave select line
	output								mosi		,	//spi bus mosi output
	output	reg							finish		,	//a pluse to indicate the SPI transmission finish and the data_out valid
	output	reg [DATA_WIDTH-1:0]		data_out	 	//the data received by miso,valid when the finish is high
);

localparam	FREQUENCE_CNT	= CLK_FREQUENCE/SPI_FREQUENCE - 1	,
			SHIFT_WIDTH		= log2(DATA_WIDTH)					,
			CNT_WIDTH		= log2(FREQUENCE_CNT)				;

localparam	IDLE	=	3'b000	,
			LOAD	=	3'b001	,
			SHIFT	=	3'b010	,
			DONE	=	3'b100	;

reg		[2:0]				cstate		;	//FSM current state
reg		[2:0]				nstate		;	//FSM next state
reg							clk_cnt_en	;	//start clk_cnt to generate sclk
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso
reg		[CNT_WIDTH-1:0]		clk_cnt		;	//the counter to generate sclk
reg		[SHIFT_WIDTH-1:0]	shift_cnt	;	//the counter to count the number of shifts
reg		[DATA_WIDTH-1:0]	data_reg	;	//the register to latch the data_in,also the shift register
//the counter to generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		clk_cnt <= 'd0;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT) 
			clk_cnt <= 'd0;
		else
			clk_cnt <= clk_cnt + 1'b1;
	else
		clk_cnt <= 'd0;
end
//generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sclk <= CPOL;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT)  	
			sclk <= ~sclk; 
		else 
			sclk <= sclk;
	else
		sclk <= CPOL;
end
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (clk_cnt_en) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;
//----------------------------------------
//==============================================
//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate
//=============================================
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		cstate <= IDLE;
	else 
		cstate <= nstate;
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE	: nstate = start ? LOAD : IDLE;
		LOAD	: nstate = SHIFT;
		SHIFT	: nstate = (shift_cnt == DATA_WIDTH) ? DONE : SHIFT;
		DONE	: nstate = IDLE;
		default: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		clk_cnt_en	<= 1'b0	;
		data_reg	<= 'd0	;
		cs_n		<= 1'b1	;
		shift_cnt	<= 'd0	;
		finish <= 1'b0	;
	end else begin
		case (nstate)
			IDLE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				shift_cnt	<= 'd0	;
				finish 		<= 1'b0	;
			end
			LOAD	: begin
				clk_cnt_en	<= 1'b1		;
				data_reg	<= data_in	;
				cs_n		<= 1'b0		;
				shift_cnt	<= 'd0		;
				finish 		<= 1'b0		;
			end
			SHIFT	: begin
				if (shift_en) begin
					shift_cnt	<= shift_cnt + 1'b1 ;
					data_reg	<= {data_reg[DATA_WIDTH-2:0],1'b0};
				end else begin
					shift_cnt	<= shift_cnt	;
					data_reg	<= data_reg		;
				end
				clk_cnt_en	<= 1'b1	;
				cs_n		<= 1'b0	;
				finish 		<= 1'b0	;
			end
			DONE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b1	;
			end
			default	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b0	;
			end
		endcase
	end
end
//mosi output MSB first
assign mosi = data_reg[DATA_WIDTH-1];
//sample data from the miso line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (sampl_en) 
		data_out <= {data_out[DATA_WIDTH-1:0],miso};
	else
		data_out <= data_out;
end
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
",Master.txt,32-Verilog-Mini-Projects\Master.txt
"[Keyword]: mealy

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a Mealy state machine that detects a sequence of two consecutive '1's in the input stream. The state machine transitions through states based on the input and produces an output of '1' when the sequence ""11"" is detected.

[Input Signal Description]:
- clk: Clock signal used to synchronize the state transitions.
- reset: Asynchronous reset signal to initialize the state machine to the initial state (zero).
- in: Input signal that the state machine monitors to detect the sequence of two consecutive '1's.

[Output Signal Description]:
- out: Output signal that becomes '1' when the state machine detects the sequence ""11"" in the input stream. Otherwise, it remains '0'.


[Design Detail]:
module state_machine_mealy(clk, reset, in, out);
parameter zero=0, one1=1, two1s=2;
output out; input clk, reset, in;
reg out; reg [1:0] state, next_state;
// Implement the state register
always @(posedge clk or posedge reset) begin
 if (reset)
 state <= zero;
 else
 state <= next_state;
 end
always @(state or in) begin
 case (state)
 zero: begin //last input was a zero out = 0;
 if (in)
 next_state=one1;
 else
 next_state=zero;
 end
 one1: begin //we've seen one 1 out = 0;
 if (in)
 next_state=two1s;
 else
 next_state=zero;
 end
 two1s: begin //we've seen at least 2 ones out = 1;
 if (in) 
 next_state=two1s;
 else
 next_state=zero;
 end
 default: //in case we reach a bad state out = 0;
 next_state=zero;
 endcase
end
// output logic
always @(state) begin
 case (state)
 zero: out <= 0;
 one1: out <= 0;
 two1s: out <= 1;
 default : out <= 0;
 endcase
end
endmodule

module state_machine_mealy_tb();
reg clk, reset, in;
wire out;
integer i;

state_machine_mealy dut(clk, reset, in, out);
initial 
forever #5 clk = ~clk;

initial begin
reset = 1'b1;
clk = 1'b0;
in = 0 ;
#6;
reset = 1'b0;

for (i = 0; i<10 ; i = i+1)
begin 
	@(negedge clk); #1;
in = $random;
if (out == 1'b1)
$display(""PASS: Sequence 11 detected i = %d\n"", i);
end
#50;
$finish;
end
endmodule
",mealy.txt,32-Verilog-Mini-Projects\mealy.txt
"[Keyword]: modified_booth

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The circuit implements a modified Booth's algorithm for multiplication. It takes two 8-bit inputs and produces a 16-bit product. The algorithm uses a lookup table and specific operations to efficiently compute the product by handling different bit patterns in the multiplier.

[Input Signal Description]:
- a[7:0]: 8-bit multiplicand input.
- b[7:0]: 8-bit multiplier input.
- clock: Clock signal used to trigger the computation on the negative edge.

[Output Signal Description]:
- p[15:0]: 16-bit output representing the product of the inputs a and b.


[Design Detail]:
module MBA_module(p,a,b,clock);
    output [15:0] p;
    input [7:0]  a, b;
    input clock;
    reg [15:0] p,ans;

    integer i, lookup_tbl;
    integer operate;

    initial
    begin
        p=16'b0;
        ans=16'b0;
    end

    always @(negedge clock)
    begin
        p=16'b0;
        for(i=1;i<=7;i=i+2)
        begin
            if(i==1)
                lookup_tbl = 0;
            else
                lookup_tbl = b[i-2];

            lookup_tbl = lookup_tbl + 4*b[i] + 2*b[i-1]; 

            if(lookup_tbl == 0 || lookup_tbl == 7)
                operate = 0;
            else if(lookup_tbl == 3 || lookup_tbl == 4)
                operate = 2;
            else
                operate = 1;
            if(b[i] == 1)
                operate = -1*operate;

            case(operate)
            1:
                begin
                    ans=a;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            2:
                begin
                    ans=a<<1;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            -1:
                begin
                    ans=~a+1;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            -2:
                begin
                    ans=a<<1;
                    ans=~ans+1;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            endcase
        end
    end
endmodule

",modified_booth.txt,32-Verilog-Mini-Projects\modified_booth.txt
"[Keyword]: moore

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a Moore state machine that detects a sequence of two consecutive '1's in the input stream. The state machine has three states: `zero`, `one1`, and `two1s`. The output is asserted when the state machine reaches the `two1s` state, indicating that the sequence ""11"" has been detected.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions.
- `reset`: Asynchronous reset signal to initialize the state machine to the `zero` state.
- `in`: Input signal that the state machine monitors for the sequence ""11"".

[Output Signal Description]:
- `out`: Output signal that is asserted (set to 1) when the state machine detects the sequence ""11"" in the input stream. It remains 0 otherwise.


[Design Detail]:
module state_machine_moore(clk, reset, in, out);
parameter zero=0, one1=1, two1s=2;
output out; input clk, reset, in;
reg out; reg [1:0] state, next_state;
// Implement the state register
always @(posedge clk or posedge reset) begin
 if (reset)
 state <= zero;
 else
 state <= next_state;
 end
always @(state or in) begin
 case (state)
 zero: begin //last input was a zero out = 0;
 if (in)
 next_state=one1;
 else
 next_state=zero;
 end
 one1: begin //we've seen one 1 out = 0;
 if (in)
 next_state=two1s;
 else
 next_state=zero;
 end
 two1s: begin //we've seen at least 2 ones out = 1;
 if (in)
 next_state=two1s;
 else
 next_state=zero;
 end
 default: //in case we reach a bad state out = 0;
 next_state=zero;
 endcase
end
// output logic
always @(state) begin
 case (state)
 zero: out <= 0;
 one1: out <= 0;
 two1s: out <= 1;
 default : out <= 0;
 endcase
end
endmodule

module state_machine_moore_tb();
reg clk, reset, in;
wire out;
integer i;

state_machine_moore dut(clk, reset, in, out);
initial 
forever #5 clk = ~clk;

initial begin
reset = 1'b1;
clk = 1'b0;
in = 0 ;
#6;
reset = 1'b0;

for (i = 0; i<10 ; i = i+1)
begin 
	@(negedge clk); #1;
in = $random;
if (out == 1'b1)
$display(""PASS: Sequence 11 detected i = %d\n"", i);
end
#50;
$finish;
end
endmodule
",moore.txt,32-Verilog-Mini-Projects\moore.txt
"[Keyword]: Multiplication

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a floating-point multiplication circuit for two 32-bit inputs, `a` and `b`. It calculates the product of these two inputs and handles special cases such as exceptions, overflow, and underflow. The result is output as a 32-bit floating-point number, with additional signals indicating if an exception, overflow, or underflow occurred during the multiplication.

[Input Signal Description]:
- `a[31:0]`: A 32-bit floating-point input operand.
- `b[31:0]`: A 32-bit floating-point input operand.

[Output Signal Description]:
- `exception`: A signal that indicates if an exception occurred, such as when the exponent of either input is 255.
- `overflow`: A signal that indicates if the result of the multiplication exceeds the maximum representable value.
- `underflow`: A signal that indicates if the result of the multiplication is too small to be represented.
- `res[31:0]`: The 32-bit floating-point result of the multiplication.


[Design Detail]:
module Multiplication(input [31:0] a,input [31:0] b,output exception,overflow,underflow,output [31:0] res);

wire sign,round,normalised,zero;
wire [8:0] exponent,sum_exponent;
wire [22:0] product_mantissa;
wire [23:0] op_a,op_b;
wire [47:0] product,product_normalised; 


assign sign = a[31] ^ b[31];   													// XOR of 32nd bit
assign exception = (&a[30:23]) | (&b[30:23]);											// Execption sets to 1 when exponent of any a or b is 255
																// If exponent is 0, hidden bit is 0

assign op_a = (|a[30:23]) ? {1'b1,a[22:0]} : {1'b0,a[22:0]};
assign op_b = (|b[30:23]) ? {1'b1,b[22:0]} : {1'b0,b[22:0]};

assign product = op_a * op_b;													// Product
assign round = |product_normalised[22:0];  											// Last 22 bits are ORed for rounding off purpose
assign normalised = product[47] ? 1'b1 : 1'b0;	
assign product_normalised = normalised ? product : product << 1;								// Normalized value based on 48th bit
assign product_mantissa = product_normalised[46:24] + (product_normalised[23] & round); 					// Mantissa
assign zero = exception ? 1'b0 : (product_mantissa == 23'd0) ? 1'b1 : 1'b0;
assign sum_exponent = a[30:23] + b[30:23];
assign exponent = sum_exponent - 8'd127 + normalised;
assign overflow = ((exponent[8] & !exponent[7]) & !zero) ; 									// Overall exponent is greater than 255 then Overflow
assign underflow = ((exponent[8] & exponent[7]) & !zero) ? 1'b1 : 1'b0; 							// Sum of exponents is less than 255 then Underflow
assign res = exception ? 32'd0 : zero ? {sign,31'd0} : overflow ? {sign,8'hFF,23'd0} : underflow ? {sign,31'd0} : {sign,exponent[7:0],product_mantissa};

endmodule



module multiplication_tb;

reg [31:0] a,b;
wire exception,overflow,underflow;
wire [31:0] res;

reg clk = 1'b1;

Multiplication dut(a,b,exception,overflow,underflow,res);

always clk = #5 ~clk;

initial
begin
iteration (32'h0200_0000,32'h0200_0000,1'b0,1'b0,1'b0,32'h0000_0000,`__LINE__);

iteration (32'h4234_851F,32'h427C_851F,1'b0,1'b0,1'b0,32'h4532_10E9,`__LINE__); // 45.13 * 63.13 = 2849.0569;

iteration (32'h4049_999A,32'hC166_3D71,1'b0,1'b0,1'b0,32'hC235_5062,`__LINE__); //3.15 * -14.39 = -45.3285

iteration (32'hC152_6666,32'hC240_A3D7,1'b0,1'b0,1'b0,32'h441E_5375,`__LINE__); //-13.15 * -48.16 = 633.304

iteration (32'h4580_0000,32'h4580_0000,1'b0,1'b0,1'b0,32'h4B80_0000,`__LINE__); //4096 * 4096 = 16777216

iteration (32'h3ACA_62C1,32'h3ACA_62C1,1'b0,1'b0,1'b0,32'h361F_FFE7,`__LINE__); //0.00154408081 * 0.00154408081 = 0.00000238418

iteration (32'h0000_0000,32'h0000_0000,1'b0,1'b0,1'b0,32'h0000_0000,`__LINE__); // 0 * 0 = 0;

iteration (32'hC152_6666,32'h0000_0000,1'b0,1'b0,1'b0,32'h441E_5375,`__LINE__); //-13.15 * 0 = 0;

iteration (32'h7F80_0000,32'h7F80_0000,1'b1,1'b1,1'b0,32'h0000_0000,`__LINE__); 

$stop;

end

task iteration(
input [31:0] op_a,op_b,
input Expected_Exception,Expected_Overflow,Expected_Underflow,
input [31:0] Expected_result,
input integer linenum 
);
begin
@(negedge clk)
begin
	a = op_a;
	b = op_b;
end

@(posedge clk)
begin
if ((Expected_result == res) && (Expected_Exception == exception) && (Expected_Overflow == overflow) && (Expected_Underflow == underflow))
	$display (""Success : %d"",linenum);

else
	$display (""Failed : Expected_result = %h, Result = %h, \n Expected_Exception = %d, Exception = %d,\n Expected_Overflow = %d, Overflow = %d, \n Expected_Underflow = %d, Underflow = %d - %d \n "",Expected_result,res,Expected_Exception,exception,Expected_Overflow,overflow,Expected_Underflow,underflow,linenum);
end
end
endtask
endmodule
",Multiplication.txt,32-Verilog-Mini-Projects\Multiplication.txt
"[Keyword]: mux2X1

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 2-to-1 multiplexer. It selects one of the two input signals (in0 or in1) based on the value of the selection signal (sel) and outputs the selected input.

[Input Signal Description]:
- in0: First input signal to the multiplexer.
- in1: Second input signal to the multiplexer.
- sel: Selection signal that determines which input (in0 or in1) is passed to the output. If sel is 1, in1 is selected; if sel is 0, in0 is selected.

[Output Signal Description]:
- out: The output signal of the multiplexer, which is either in0 or in1 based on the value of the sel signal.


[Design Detail]:
module mux2X1( in0,in1,sel,out);
input in0,in1;
input sel;
output out;
assign out=(sel)?in1:in0;
endmodule
",mux2X1.txt,32-Verilog-Mini-Projects\mux2X1.txt
"[Keyword]: Mux_8_to_1

[Design Category]: Combinational Logic

[Design Function Description]:  
This design implements an 8-to-1 multiplexer. It selects one of the eight input signals (in0 to in7) based on a 3-bit selection signal (S) and outputs the selected input through Mux_Out.

[Input Signal Description]:  
- S[2:0]: A 3-bit selection signal that determines which one of the eight inputs (in0 to in7) is routed to the output.  
- in0, in1, in2, in3, in4, in5, in6, in7: These are the eight input signals to the multiplexer. Each input is a single bit.

[Output Signal Description]:  
- Mux_Out: The output signal of the multiplexer, which is the selected input based on the value of the selection signal S.


[Design Detail]:
`timescale 1ns / 1ps

module Mux_8_to_1(Mux_Out , S , in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7);

output reg Mux_Out;
input [2:0] S;
input in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7;

always@(*)
begin
	case(S)
		
		3'b000 : Mux_Out = in0;
		3'b001 : Mux_Out = in1;
		3'b010 : Mux_Out = in2;
		3'b011 : Mux_Out = in3;
		3'b100 : Mux_Out = in4;
		3'b101 : Mux_Out = in5;
		3'b110 : Mux_Out = in6;
		3'b111 : Mux_Out = in7;
	endcase
end

endmodule
",Mux_8_to_1.txt,32-Verilog-Mini-Projects\Mux_8_to_1.txt
"[Keyword]: non_restoring_div_R2

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a non-restoring division algorithm. It calculates the quotient and remainder of a division operation between a 64-bit dividend and a 64-bit divisor. The algorithm iteratively shifts and subtracts to determine the quotient and remainder.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations.
- `reset`: Active-low reset signal to initialize the quotient and remainder to zero.
- `Dividend[63:0]`: 64-bit input representing the number to be divided.
- `Divisor[63:0]`: 64-bit input representing the number by which the dividend is divided.

[Output Signal Description]:
- `Quotient[63:0]`: 64-bit output representing the result of the division.
- `Remainder[63:0]`: 64-bit output representing the remainder after the division.


[Design Detail]:
module non_restoring_div(clk, reset, Dividend, Divisor, Quotient, Remainder);
	input clk, reset;
	input [63:0] Dividend, Divisor;
	output [63:0] Quotient, Remainder;
	reg [63:0] Quotient, Remainder;
	reg [63:0] p, a, temp;
	integer i;

	always @(posedge clk, negedge reset)
	begin
		if( !reset )
		begin
			Quotient <= 0;
			Remainder <= 0;
		end
		else
		begin
			Quotient <= a;
			Remainder <= p;
		end
	end

	always @(*)
	begin
		a = Dividend;
		p = 0;

		for(i = 0; i < 64; i = i+1)
		begin
			//Shift Left carrying a's MSB into p's LSB
			p = (p << 1) | a[63];
			a = a << 1;

			//Check the old value of p
			if( p[63] ) //if p is negative
				temp = Divisor; //add divisor
			else
				temp = ~Divisor+1; //subtract divisor

			//this will do the appropriate add or subtract
			//depending on the value of temp
			p = p + temp;

			//Check the new value of p
			if( p[63] ) // if p is negative
				a = a | 0; //no change to quotient
			else
				a = a | 1; 
		end

		//Correction is needed if remainder is negative
		if( p[63] ) //if p is negative
			p = p + Divisor;
	end
				
endmodule

module non_restoring_div_tb;
	reg clk, reset;
	reg [63:0] dividend, divisor;
	wire [63:0] quotient, remainder;

	non_restoring_div divider(clk, reset, dividend, divisor, quotient, remainder);

	initial
		forever #1 clk = ~clk;

	initial
		$monitor(""%0d / %0d: q = %0d, r = %0d"", dividend, divisor, quotient, remainder);

	initial
	begin
		clk = 0;
		reset = 0;

		#1;
		reset = 1;
		dividend = 87;
		divisor = 5;

		#5;
		dividend = 59;
		divisor = 20;

		#5;
		dividend = 64'hFFFF_FFFF_FFFF_FFFF;
		divisor = 2;

		#5;
		dividend = 32'h1234_5678;
		divisor = 1;

		#5;
		divisor = dividend;
	
		#5;
		$finish;
	end

endmodule
",non_restoring_div_R2.txt,32-Verilog-Mini-Projects\non_restoring_div_R2.txt
"[Keyword]: pipelined_multiplier

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 32-bit floating-point multiplier using a pipeline architecture. It takes two 32-bit floating-point numbers as inputs and produces a 32-bit floating-point result. The design handles the sign, exponent, and mantissa separately and uses a series of pipeline registers to manage the intermediate results across clock cycles.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the pipeline stages.
- `rst`: Reset signal to initialize the pipeline registers.
- `A[31:0]`: 32-bit floating-point input operand A.
- `B[31:0]`: 32-bit floating-point input operand B.

[Output Signal Description]:
- `F[31:0]`: 32-bit floating-point output representing the product of inputs A and B.


[Design Detail]:
module MULTI_32bit(clk, rst,A, B, F);
   `define BIAS 8'b01111111
   input clk, rst;
   input [31:0]A;
   input [31:0]B;

   output [31:0]F;
   reg [31:0]F;
	

//   reg [1:0]sign;
//   reg [49:0]mantissa;


//////////////// PIPE-LINE REGISTERS /////////////////
reg [62:0] P1;
reg [66:0] P2;
reg [31:0] P3;
//////////////////////////////////////////////////////

initial
begin	
	P1 = 0;
	P2 = 0;
	P3 = 0;
end


wire [1:0]sign;
wire [49:0]mantissa;

assign sign = A[31]+B[31];

//always @ ( F or A or B )
always @ ( posedge clk )
begin
	//solve for the sign bit part
	/////////////////////////////////////////////////////////
	P1[0] <= (sign == 1'b1) ? 1'b1 : 1'b0;
	P1[31:1] <= A[30:0];
	P1[62:32] <= B[30:0];

	///////////////////////////////////////////////////////////
	P2[0] <= P1[0];
	P2[50:1] <= P1[23:1] * P1[54:32];

	P2[58:51] <= P1[31:24];
	P2[66:59] <= P1[62:55];

///////////////////////////////////////////////////////////
	P3[0] <= P2[0];

	if(P2[50:24] == 0) begin
	   P3[23:1] = P2[23:1];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h00;
	end
	else if(P2[50] == 1) begin
	   P3[23:1] = P2[49:27];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h1a;
	end
	else if(P2[49] == 1) begin
	   P3[23:1] = P2[48:26];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h19;
	end
	else if(P2[48] == 1) begin
	   P3[23:1] = P2[47:25];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h18;
	end
	else if(P2[47] == 1) begin
	   P3[23:1] = P2[46:24];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h17;
	end			
	else if(P2[46] == 1) begin
	   P3[23:1] = P2[45:23];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h16;
	end	
	else if(P2[45] == 1) begin
	   P3[23:1] = P2[44:22];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h15;
	end	
	else if(P2[44] == 1) begin
	   P3[23:1] = P2[43:21];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h14;
	end
	else if(P2[43] == 1) begin
	   P3[23:1] = P2[42:20];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h13;
	end
	else if(P2[42] == 1) begin
	   P3[23:1] = P2[41:19];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h12;
	end
	else if(P2[41] == 1) begin
	   P3[23:1] = P2[40:18];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h11;
	end
	else if(P2[40] == 1) begin
	   P3[23:1] = P2[39:17];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h10;
	end
	else if(P2[39] == 1) begin
	   P3[23:1] = P2[38:16];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0f;
	end
	else if(P2[38] == 1) begin
	   P3[23:1] = P2[37:15];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0e;
	end
	else if(P2[37] == 1) begin
	   P3[23:1] = P2[36:14];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0d;
	end
	else if(P2[36] == 1) begin
	   P3[23:1] = P2[35:13];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0c;
	end
	else if(P2[35] == 1) begin
	   P3[23:1] = P2[34:12];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0b;
	end
	else if(P2[34] == 1) begin
	   P3[23:1] = P2[33:11];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0a;
	end
	else if(P2[33] == 1) begin
	   P3[23:1] = P2[32:10];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h09;
	end
	else if(P2[32] == 1) begin
	   P3[23:1] = P2[31:09];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h08;
	end
	else if(P2[31] == 1) begin
	   P3[23:1] = P2[30:08];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h07;
	end
	else if(P2[30] == 1) begin
	   P3[23:1] = P2[29:07];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h06;
	end
	else if(P2[29] == 1) begin
	   P3[23:1] = P2[28:06];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h05;
	end
	else if(P2[28] == 1) begin
	   P3[23:1] = P2[27:05];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h04;
	end
	else if(P2[27] == 1) begin
	   P3[23:1] = P2[26:04];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h03;
	end
	else if(P2[26] == 1) begin
	   P3[23:1] = P2[25:03];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h02;
	end
	else begin
	   P3[23:1] = P2[24:02];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h01;
	end

///////////////////////////////////////////////////////////
	F[31] <= P3[0];
	F[30:0] <= P3[31:1];

////////////////////////////////////////////////////////////
end

endmodule



",pipelined_multiplier.txt,32-Verilog-Mini-Projects\pipelined_multiplier.txt
"[Keyword]: pipo

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a Parallel In Parallel Out (PIPO) shift register. It captures an 8-bit input data and outputs it in parallel. The register can be reset to zero or loaded with new data based on control signals.

[Input Signal Description]:
- clk: Clock signal that triggers the data capture on its rising edge.
- rst: Reset signal that, when high, resets the output q to zero.
- l: Load signal that, when high, allows the input data d to be loaded into the output q.
- d[7:0]: 8-bit input data that is loaded into the register when the load signal is active.

[Output Signal Description]:
- q[7:0]: 8-bit output that holds the data captured from the input d when the load signal is active. It is reset to zero when the reset signal is high.


[Design Detail]:
//PIPO
module s1(rst,d,clk,q,l);

input clk,l,rst;
input [7:0] d;
output reg [7:0] q;

always @(posedge clk)
begin
if(rst)
q=0;
else if(l)
q=d;
end
endmodule
",pipo.txt,32-Verilog-Mini-Projects\pipo.txt
"[Keyword]: prod1

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements an 8-bit shift register. The shift register shifts its contents to the right on the negative edge of the clock signal. The input 'd' is shifted into the most significant bit of the register. The register can be reset to zero using the 'rst' signal, and it can hold its current value if the 'l' signal is active.

[Input Signal Description]:
- clk: Clock signal used to synchronize the shifting operation.
- rst: Reset signal, when active, resets the shift register to zero.
- l: Load signal, when active, holds the current value of the shift register.
- d: Data input signal, which is shifted into the most significant bit of the register.

[Output Signal Description]:
- q3: An 8-bit output register that holds the current state of the shift register.


[Design Detail]:
//Prod1
module s4(clk,rst,d,l,q3);

input clk,rst,l,d;
output reg [7:0] q3;

always @(negedge clk)
begin
if(rst)
q3<=7'd0;
else if(l)
q3<=q3;
else
begin
q3[0]<=q3[1];
q3[1]<=q3[2];
q3[2]<=q3[3];
q3[3]<=q3[4];
q3[4]<=q3[5];
q3[5]<=q3[6];
q3[6]<=q3[7];
q3[7]<=d;
end
end
endmodule
",prod1.txt,32-Verilog-Mini-Projects\prod1.txt
"[Keyword]: restoring_div_R2

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a 64-bit restoring division algorithm. It calculates the quotient and remainder when a 64-bit dividend is divided by a 64-bit divisor. The algorithm uses a series of shifts and subtractions to perform the division operation.

[Input Signal Description]:
- clk: Clock signal used to synchronize the operations.
- reset: Active low reset signal to initialize the quotient and remainder.
- Dividend [63:0]: 64-bit input representing the number to be divided.
- Divisor [63:0]: 64-bit input representing the number by which the dividend is divided.

[Output Signal Description]:
- Quotient [63:0]: 64-bit output representing the result of the division (the number of times the divisor fits into the dividend).
- Remainder [63:0]: 64-bit output representing the remainder of the division (what is left after the division).


[Design Detail]:
module restoring_div_R2(clk, reset, Dividend, Divisor, Quotient, Remainder);
	input clk, reset;
	input [63:0] Dividend, Divisor;

	output [63:0] Quotient, Remainder;
	reg [63:0] Quotient, Remainder;

	reg [63:0] p, a, temp;
	integer i;

	always @(posedge clk, negedge reset)
	begin
		if( !reset )
		begin
			Quotient <= 0;
			Remainder <= 0;
		end
		else
		begin
			Quotient <= a;
			Remainder <= p;
		end
	end

	always @(*)
	begin
		a = Dividend;
		p = 0;

		for(i = 0; i < 64; i = i+1)
		begin
			//Shift Left carrying a's MSB into p's LSB
			p = (p << 1) | a[63];
			a = a << 1;

			//store value in case we have to restore
			temp = p;

			//Subtract
			p = p - Divisor;

			if( p[63] ) // if p < 0
				p = temp; //restore value
			else
				a = a | 1;
		end	
	end
				
endmodule
	
module restoring_div_R2_tb;
	reg clk, reset;
	reg [63:0] dividend, divisor;
	wire [63:0] quotient, remainder;

	restoring_div_R2 divider(clk, reset, dividend, divisor, quotient, remainder);

	initial
		forever #1 clk = ~clk;

	initial
		$monitor(""%0d / %0d: q = %0d, r = %0d"", dividend, divisor, quotient, remainder);

	initial
	begin
		clk = 0;
		reset = 0;

		#1;
		reset = 1;
		dividend = 87;
		divisor = 5;

		#5;
		dividend = 59;
		divisor = 20;

		#5;
		dividend = 64'hFFFF_FFFF_FFFF_FFFF;
		divisor = 2;

		#5;
		dividend = 32'h1234_5678;
		divisor = 1;

		#5;
		divisor = dividend;
	
		#5;
		$finish;
	end

endmodule
",restoring_div_R2.txt,32-Verilog-Mini-Projects\restoring_div_R2.txt
"[Keyword]: restoring_div_R4

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a restoring division algorithm for dividing a 64-bit dividend by a 64-bit divisor. It calculates both the quotient and the remainder of the division operation. The algorithm uses a radix-4 approach, which processes two bits of the dividend at a time, making it more efficient than a simple bit-by-bit division.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations.
- `reset`: Active-low reset signal to initialize the quotient and remainder to zero.
- `Dividend[63:0]`: 64-bit input representing the number to be divided.
- `Divisor[63:0]`: 64-bit input representing the number by which the dividend is divided.

[Output Signal Description]:
- `Quotient[63:0]`: 64-bit output representing the result of the division (the number of times the divisor fits into the dividend).
- `Remainder[63:0]`: 64-bit output representing the remainder of the division (what is left of the dividend after division).


[Design Detail]:
module restoring_div_R4(clk, reset, Dividend, Divisor, Quotient, Remainder);
	input clk, reset;
	input [63:0] Dividend, Divisor;

	output [63:0] Quotient, Remainder;
	reg [63:0] Quotient, Remainder;
	reg [63:0] p, a;
	reg [63:0] Result1, Result2, Result3;
	reg [63:0] DivisorX2, DivisorX3;
	integer i;

	always @(posedge clk, negedge reset)
	begin
		if( !reset )
		begin
			Quotient <= 0;
			Remainder <= 0;
		end
		else
		begin
			Quotient <= a;
			Remainder <= p;
		end
	end

	always @(*)
	begin
		a = Dividend;
		p = 0;
		DivisorX2 = Divisor << 1; //Divisor*2
		DivisorX3 = (Divisor << 1) + Divisor; //Divisor*3

		for(i = 0; i < 32; i = i+1)
		begin
			//Shift Left carrying a's MSB into p's LSB
			p = (p << 2) | a[63:62];
			a = a << 2;

			//Subtract
			Result1 = p - Divisor;
			Result2 = p - DivisorX2;
			Result3 = p - DivisorX3;

			if( Result1[63] ) //Divisor is too big
			begin
				a = a | 0;
			end
			else if( Result2[63] )//Divisor*2 is too big, but Divisor*1 is OK
			begin
				p = Result1;
				a = a | 1;
			end
			else if( Result3[63] ) //Divisor*3 is too big, but Divisor*2 is OK
			begin
				p = Result2;
				a = a | 2;
			end
			else
			begin //Divisor*3 is OK
				p = Result3;
				a = a | 3;
			end
		end	
	end
				
endmodule

module restoring_div_R4_tb;
	reg clk, reset;
	reg [63:0] dividend, divisor;
	wire [63:0] quotient, remainder;

	restoring_div_R4 divider(clk, reset, dividend, divisor, quotient, remainder);

	initial
		forever #1 clk = ~clk;

	initial
		$monitor(""%0d / %0d: q = %0d, r = %0d"", dividend, divisor, quotient, remainder);

	initial
	begin
		clk = 0;
		reset = 0;

		#1;
		reset = 1;
		dividend = 87;
		divisor = 5;

		#5;
		dividend = 59;
		divisor = 20;

		#5;
		dividend = 64'hFFFF_FFFF_FFFF_FFFF;
		divisor = 2;

		#5;
		dividend = 32'h1234_5678;
		divisor = 1;

		#5;
		divisor = dividend;
	
		#5;
		$finish;
	end

endmodule
",restoring_div_R4.txt,32-Verilog-Mini-Projects\restoring_div_R4.txt
"[Keyword]: sequential_multiplication

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a sequential multiplier circuit that multiplies two 8-bit numbers, `a` and `b`, and produces a 16-bit product `op`. The circuit uses a series of registers and combinational logic to perform the multiplication over several clock cycles. The `valid` signal indicates when the multiplication result is ready.

[Input Signal Description]:
- `a[7:0]`: 8-bit input operand.
- `b[7:0]`: 8-bit input operand.
- `clk`: Clock signal used to synchronize the operations.
- `reset`: Resets the circuit to its initial state.
- `load`: Signal to load the input operands into the circuit.

[Output Signal Description]:
- `op[15:0]`: 16-bit output representing the product of `a` and `b`.
- `valid`: Output signal indicating that the multiplication result is ready and valid.


[Design Detail]:

module final12 (a,b,op,load,reset,clk,valid);
input [7:0] a,b;
output [15:0] op;
output valid;
input clk,reset,load;
wire [7:0] x,y,z,s,po,lo;
wire c,v1,l,t;

s1 u1 (reset,a,clk,x,load);
s2 u2 (reset,load,clk,z,b);
assign y=x & {8{z[0]}};
counter u5 (t,l,clk);
assign valid=l;
adder u3 (y,po,c,s);
s3 u4 (clk,v1,{c,s[7:1]},l,po);
 s4 e1 (clk,v,s[0],l,lo);
assign op={po,lo};
assign v1= reset|load;
assign t=reset|load;

always @(l)
begin
if(op==a*b)
$display(""the product of a=%d ,b=%d  is p=%d"",a,b,op);
else
$display(""Incorrect operation"");
end
endmodule
",sequential_multiplication.txt,32-Verilog-Mini-Projects\sequential_multiplication.txt
"[Keyword]: shift_add_multiplication

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements an 8-bit by 8-bit binary multiplier using a combination of an adder, a shifter, and a controller. The multiplier takes two 8-bit inputs and produces a 16-bit output, representing the product of the two inputs. The design uses a sequential approach to perform multiplication by iteratively adding and shifting.

[Input Signal Description]:
- `D [7:0]`: An 8-bit input representing one of the multiplicands.
- `Q [7:0]`: An 8-bit input representing the other multiplicand.
- `clk`: Clock signal used to synchronize the operations.
- `rst`: Reset signal to initialize the system.

[Output Signal Description]:
- `out [15:0]`: A 16-bit output representing the product of the two 8-bit inputs `D` and `Q`.


[Design Detail]:
module adder(
    D,A,add_out,c_out
    );
    parameter m=8,n=8;
    input [m-1:0] D,A;
    output [m-1:0] add_out;
    output c_out;
    wire [m:0] add_result, data1, data2;
    assign data1 = {1'b0,D};
    assign data2 = {1'b0,A};
    assign add_result = data1+data2;
    assign add_out = add_result[m-1:0];
    assign c_out = add_result[m];
endmodule

module controller(clk,rst,lsb,load_cmd,add_cmd,shift_cmd,out_cmd);
    input clk, rst,lsb;
    output load_cmd,add_cmd,shift_cmd,out_cmd;
    reg load_cmd,add_cmd,shift_cmd, out_cmd;
    reg [2:0] state;
    reg start;
    integer count;
    parameter m=8;
    parameter n=8;
    parameter idle=3'b000, init=3'b001, test=3'b010, add=3'b011, shift=3'b100;
    always@(posedge clk or posedge rst)
        if (rst)
            begin
                state<=idle;
                count<=0;
                start<=1;
                out_cmd<=0;
            end
        else 
            case (state)
                idle: begin
                    load_cmd<=0;
                    add_cmd<=0;
                    shift_cmd<=0;
                    if (start) begin
                        state<=init;
                        out_cmd<=0;
                    end
                    else begin
                        state<=idle;
                        out_cmd<=1;
                    end
                end
                init: begin
                    load_cmd<=1;
                    add_cmd<=0;
                    shift_cmd<=0;
                    out_cmd<=0;
                    state<=test;
                end
                test: begin
                    load_cmd<=0;
                    add_cmd<=0;
                    shift_cmd<=0;
                    out_cmd<=0;
                    if (lsb) begin
                        state<=add;
                        end
                    else state<=shift;
                end 
                add: begin
                    load_cmd<=0;
                    add_cmd<=1;
                    shift_cmd<=0;
                    out_cmd<=0;
                    state<=shift;
                end
                shift: begin
                    load_cmd<=0;
                    add_cmd<=0;
                    shift_cmd<=1;
                    out_cmd<=0;
                    if (count<m) begin
                        state<=test;
                        count<=count+1;
                    end
                    else begin
                        count<=0;
                        state<=idle;
                        start<=0;
                    end
                end 
            endcase                
endmodule

module shifter(
    add_out,c_out,load_cmd,add_cmd,shift_cmd,clk,rst,out_cmd,Q,A,lsb,out   
 );
 parameter m=8,n=8;
 input [m-1:0] add_out;
 input c_out,load_cmd,add_cmd,shift_cmd,clk,rst,out_cmd;
 input [n-1:0] Q;
 output [m-1:0] A;
 output lsb;
 output reg [m+n-1:0] out; 
 reg [m+n:0] temp;
 reg add_temp;
 
 assign A = temp[m+n-1:n];
 assign lsb = temp[0];
 always@(posedge clk or posedge rst)
 begin
    if (rst)
    begin
        add_temp<=0;
        temp<=0;
    end
    else
    begin
        if (load_cmd)
        begin
            temp[m+n:n]<=0;
            temp[n-1:0]<=Q;
        end
        else if (add_cmd)
            add_temp<=1;
        else if (shift_cmd && add_temp)
        begin
            temp<={1'b0, c_out, add_out, temp[n-1:1]};
            add_temp<=0;
        end
        else if (shift_cmd && !add_temp)
            temp<={1'b0, temp[m+n:1]}; 
    end
 end
 always@(out_cmd)
 begin
    if (!out_cmd)
        out<=0;
    else
        out<=temp[m+n-1:0];
 end
 endmodule

module multiplier(clk, rst, D, Q, out);
parameter m=8, n=8;
input clk, rst;
input [m-1:0] D;
input [n-1:0] Q;
output [m+n-1:0] out;

wire c_out,load_cmd,add_cmd,shift_cmd,lsb,out_cmd;
wire [m-1:0] A,add_out;
adder adder(.D(D), .A(A), .add_out(add_out), .c_out(c_out));
shifter shifter(add_out,c_out,load_cmd,add_cmd,shift_cmd,clk,rst,out_cmd,Q,A,lsb,out);
controller controller(clk,rst,lsb,load_cmd,add_cmd,shift_cmd,out_cmd);
endmodule

module multiplier_tb;
parameter m=8, n=8;
reg clk, rst;
reg [m-1:0] D;
reg [n-1:0] Q;
wire [m+n-1:0] out;

multiplier multiplier(clk, rst, D, Q, out);

initial 
begin
    clk = 1'b1;
    forever #5 clk = ~clk;
end
initial
begin

    rst = 1;
    #20;
    rst = 0;
    D = 8'b11111111;
    Q = 8'b11111111;
    #2000;
    rst = 1;
    #20;
    rst = 0;
    D = 8'b00011111;
    Q = 8'b00011111;
    #2000;
    rst = 1;
    #20;
    rst = 0;
    D = 8'b00000001;
    Q = 8'b00000001;
    #2000;
end
endmodule
",shift_add_multiplication.txt,32-Verilog-Mini-Projects\shift_add_multiplication.txt
"[Keyword]: Slave

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements an SPI (Serial Peripheral Interface) Slave module. It is responsible for receiving data from an SPI master device via the MOSI (Master Out Slave In) line and sending data back to the master via the MISO (Master In Slave Out) line. The module supports configurable clock polarity (CPOL) and clock phase (CPHA) to accommodate different SPI modes.

[Input Signal Description]:
- `clk`: System clock signal.
- `rst_n`: Active-low system reset signal.
- `data_in[DATA_WIDTH-1:0]`: Data to be sent to the master via the MISO line.
- `sclk`: SPI clock signal from the master.
- `cs_n`: Active-low chip select signal from the master, indicating when the slave is selected.
- `mosi`: SPI data line from the master to the slave.

[Output Signal Description]:
- `miso`: SPI data line from the slave to the master, transmitting the most significant bit (MSB) of `data_reg`.
- `data_valid`: Signal indicating that the data received from the MOSI line is valid.
- `data_out[DATA_WIDTH-1:0]`: Data received from the master via the MOSI line, valid when `data_valid` is high.



[Design Detail]:
`timescale 1ns/1ps

module SPI_Slave
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 1					,	//SPI mode selection (mode 0 default)
				CPHA			= 1					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by miso
	input								sclk		,	//spi bus sclk
	input								cs_n		,	//spi bus slave select line
	input								mosi		,	//spi bus mosi input
	output								miso		,	//spi bus miso output
	output								data_valid	,	//the data received by mosi valid
	output	reg	[DATA_WIDTH-1:0]		data_out	 	//the data received by mosi,valid when data_valid is high
);

localparam	SFIFT_NUM = log2(DATA_WIDTH);

reg	[DATA_WIDTH-1:0]		data_reg	;	//the register to latch the data_in,also the shift register
reg	[ SFIFT_NUM-1:0]		sampl_num	;	//the counter to count the number of sample
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
reg							cs_n_a		;	//cs_n register to capture the edge of cs_n
reg							cs_n_b		;	//cs_n register to capture the edge of cs_n
wire						cs_n_negedge;	//negedge of cs_n to latch the data
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso

//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (!cs_n) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;

//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cs_n_a	<= 1'b1;
		cs_n_b	<= 1'b1;
	end else begin
		cs_n_a	<= cs_n		;
		cs_n_b	<= cs_n_a	;
	end
end

assign cs_n_negedge = ~cs_n_a & cs_n_b;

//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate

//the register to latch the data_in
//also the shift register to generate the miso
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_reg <= 'd0;
	else if(cs_n_negedge)
		data_reg <= data_in;
	else if (!cs_n & shift_en) 
		data_reg <= {data_reg[DATA_WIDTH-2:0],1'b0};
	else
		data_reg <= data_reg;
end
//miso output MSB first
assign miso = !cs_n ? data_reg[DATA_WIDTH-1] : 1'd0;

//sample data from the mosi line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (!cs_n & sampl_en) 
		data_out <= {data_out[DATA_WIDTH-2:0],mosi};
	else
		data_out <= data_out;
end
//the counter to count the number of sampled data bit
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sampl_num <= 'd0;
	else if (cs_n)
		sampl_num <= 'd0;
	else if (!cs_n & sampl_en) 
		if (sampl_num == DATA_WIDTH)
			sampl_num <= 'd1;
		else
			sampl_num <= sampl_num + 1'b1;
	else
		sampl_num <= sampl_num;
end
//the received data valid
assign data_valid = sampl_num == DATA_WIDTH;
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
",Slave.txt,32-Verilog-Mini-Projects\Slave.txt
"[Keyword]: SR1

[Design Category]: Sequential Logic

[Design Function Description]:
This design is an 8-bit shift register with synchronous reset and load capabilities. It can load an 8-bit input value or shift its current value to the right by one bit position on each clock cycle.

[Input Signal Description]:
- rst: A reset signal that, when high, resets the output `q1` to 0.
- l_s: A load/shift control signal. When high, the input `d` is loaded into `q1`. When low, `q1` is shifted right by one bit.
- clk: A clock signal that triggers the operations on the rising edge.
- d[7:0]: An 8-bit data input that is loaded into `q1` when `l_s` is high.

[Output Signal Description]:
- q1[7:0]: An 8-bit output register that holds the current state of the shift register. It can be reset, loaded with a new value, or shifted right based on the control signals.


[Design Detail]:
//SR

module s2(rst,l_s,clk,q1,d);

input l_s,clk,rst;
input [7:0] d;
output reg [7:0] q1;

always @(posedge clk)
begin
if(rst)
q1=0;
else if(l_s)
q1=d;
else
q1=q1>>1;
end
endmodule
",SR1.txt,32-Verilog-Mini-Projects\SR1.txt
"[Keyword]: SR2

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple 8-bit register with synchronous reset and load enable functionality. It captures the input data `d` on the rising edge of the clock when the load enable `l` is low. If the reset `rst` is high, the register is reset to zero.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the data capture.
- `rst`: Synchronous reset signal. When high, it resets the output `q2` to zero on the rising edge of the clock.
- `l`: Load enable signal. When low, it allows the data `d` to be loaded into the register `q2`.
- `d[7:0]`: 8-bit data input that is captured into the register when `l` is low.

[Output Signal Description]:
- `q2[7:0]`: 8-bit output register that holds the captured data. It retains its value when `l` is high and resets to zero when `rst` is high.


[Design Detail]:
//SR

module s3(clk,rst,d,l,q2);

input clk,rst,l;
input [7:0] d;
output reg [7:0] q2;

always @(posedge clk)
begin
if(rst)
q2=0;
else if(l)
q2=q2;
else
q2=d;
end
endmodule
",SR2.txt,32-Verilog-Mini-Projects\SR2.txt
"[Keyword]: traffic_light

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a traffic light controller for a two-way intersection. It manages the traffic lights for two directions (A and B) by cycling through states that control the red, yellow, and green lights based on the current state and sensor inputs.

[Input Signal Description]:
- clk: Clock signal used to synchronize the state transitions.
- Sa: Sensor input for direction A, indicating the presence of vehicles.
- Sb: Sensor input for direction B, indicating the presence of vehicles.

[Output Signal Description]:
- Ra, Rb: Red light control signals for directions A and B, respectively.
- Ga, Gb: Green light control signals for directions A and B, respectively.
- Ya, Yb: Yellow light control signals for directions A and B, respectively.


[Design Detail]:
module traffic_light (clk, Sa, Sb, Ra, Rb, Ga, Gb, Ya, Yb);
input clk;
input Sa;
input Sb;
inout Ra;
inout Rb;
inout Ga;
inout Gb; 
inout Ya;
inout Yb;
reg Ra_tmp;
reg Rb_tmp;
reg Ga_tmp;
reg Gb_tmp;
reg Ya_tmp;
reg Yb_tmp;
reg[3:0] state;
reg[3:0] nextstate;
parameter[1:0] R = 0;
parameter[1:0] Y = 1;
parameter[1:0] G = 2;
wire[1:0] lightA;
wire[1:0] lightB;
assign Ra = Ra_tmp;
assign Rb = Rb_tmp;
assign Ga = Ga_tmp;
assign Gb = Gb_tmp;
assign Ya = Ya_tmp;
assign Yb = Yb_tmp;
initial
begin
 state = 0;
end
always @(state or Sa or Sb)
begin
 Ra_tmp = 1'b0 ;
 Rb_tmp = 1'b0 ;
 Ga_tmp = 1'b0 ;
 Gb_tmp = 1'b0 ;
 Ya_tmp = 1'b0 ;
 Yb_tmp = 1'b0 ;
 nextstate = 0;
 case (state)
 0, 1, 2, 3, 4 :
 begin Ga_tmp = 1'b1 ;
 Rb_tmp = 1'b1 ;
 nextstate = state + 1 ;
 end
 5 :
 begin
 Ga_tmp = 1'b1 ;
 Rb_tmp = 1'b1 ;
 if (Sb == 1'b1)
 begin
 nextstate = 6 ;
 end
 else
 begin
 nextstate = 5 ;
 end 
 end
 6 :
 begin
 Ya_tmp = 1'b1 ;
 Rb_tmp = 1'b1 ;
 nextstate = 7 ;
 end
 7, 8, 9, 10 :
 begin
 Ra_tmp = 1'b1 ;
 Gb_tmp = 1'b1 ;
 nextstate = state + 1 ;
 end
 11 :
 begin
 Ra_tmp = 1'b1 ;
 Gb_tmp = 1'b1 ;
 if (Sa == 1'b1 | Sb == 1'b0)
 begin
 nextstate = 12 ;
 end 
 else
 begin
 nextstate = 11 ;
 end 
 end
 12 :
 begin
 Ra_tmp = 1'b1 ;
 Yb_tmp = 1'b1 ;
 nextstate = 0 ;
 end
 endcase
end always @(posedge clk)
begin
 state <= nextstate ;
end
assign lightA = (Ra==1'b1) ? R : (Ya==1'b1) ? Y : (Ga==1'b1) ? G : lightA;
assign lightB = (Rb==1'b1) ? R : (Yb==1'b1) ? Y : (Gb==1'b1) ? G : lightB;
endmodule
",traffic_light.txt,32-Verilog-Mini-Projects\traffic_light.txt
"[Keyword]: Universal_shift_reg

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a 4-bit universal shift register. It can perform various operations such as hold, shift left, shift right, parallel load, and more, based on the control signals. The shift register uses multiplexers to select the operation and D flip-flops to store the state.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the shift register.
- `clear`: Asynchronous clear signal to reset the output to a known state.
- `S[2:0]`: 3-bit control signal that determines the operation of the shift register (e.g., hold, shift left, shift right, parallel load).
- `I[3:0]`: 4-bit input data used for parallel loading into the shift register.

[Output Signal Description]:
- `O[3:0]`: 4-bit output of the shift register, representing the current state of the register.


[Design Detail]:
`timescale 1ns / 1ps
module Universal_shift_reg(O , clk , clear , S , I);

input clk , clear ;
input [2 : 0] S ; 
input [3 : 0] I; 
output [3 : 0] O;
wire [3 : 0] D_temp;

Mux_8_to_1 inst1(D_temp[0] , S , O[0] , 1'b0 , O[1] , I[0] , ~O[0] , O[3] , O[1] , O[2]);
Mux_8_to_1 inst2(D_temp[1] , S , O[1] , O[0] , O[2] , I[1] , ~O[1] , O[0] , O[2] , O[3]);
Mux_8_to_1 inst3(D_temp[2] , S , O[2] , O[1] , O[3] , I[2] , ~O[2] , O[1] , O[3] , O[0]);
Mux_8_to_1 inst4(D_temp[3] , S , O[3] , O[2] , 1'b0 , I[3] , ~O[3] , O[2] , O[0] , O[1]);

D_FlipFlop D_inst1(O[0] , D_temp[0] , clk , clear);
D_FlipFlop D_inst2(O[1] , D_temp[1] , clk , clear);
D_FlipFlop D_inst3(O[2] , D_temp[2] , clk , clear);
D_FlipFlop D_inst4(O[3] , D_temp[3] , clk , clear);

endmodule
",Universal_shift_reg.txt,32-Verilog-Mini-Projects\Universal_shift_reg.txt
"[Keyword]: addr_decode.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design is an address decoder that maps an input address to an index based on a set of rules. The rules are defined in a packed array of structures, where each structure specifies a range of addresses and the corresponding index. The decoder can handle overlapping address ranges, with the rule at the higher position taking precedence. It also supports a default mapping for addresses that do not match any rule, and can operate in a mode that uses naturally-aligned power of two (NAPOT) regions.

[Input Signal Description]:
- `addr_i`: The address input that needs to be decoded.
- `addr_map_i`: An array of rules that define the address ranges and corresponding indices.
- `en_default_idx_i`: A signal to enable default mapping for unmatched addresses.
- `default_idx_i`: The default index to use when no rule matches and default mapping is enabled.

[Output Signal Description]:
- `idx_o`: The decoded index corresponding to the input address.
- `dec_valid_o`: A signal indicating whether the decoding was successful and valid.
- `dec_error_o`: A signal indicating an error in decoding, such as no matching rule found.


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Authors:
// - Wolfgang Roenninger <wroennin@ethz.ch>
// - Thomas Benz <tbenz@iis.ee.ethz.ch>

/// Address Decoder: Maps the input address combinatorially to an index.
/// The address map `addr_map_i` is a packed array of rule_t structs.
/// The ranges of any two rules may overlap. If so, the rule at the higher (more significant)
/// position in `addr_map_i` prevails.
///
/// There can be an arbitrary number of address rules. There can be multiple
/// ranges defined for the same index. The start address has to be less than the end address.
///
/// There is the possibility to add a default mapping:
/// `en_default_idx_i`: Driving this port to `1'b1` maps all input addresses
/// for which no rule in `addr_map_i` exists to the default index specified by
/// `default_idx_i`. In this case, `dec_error_o` is always `1'b0`.
///
/// The `Napot` parameter allows using naturally-aligned power of two (NAPOT) regions,
/// using base addresses and masks instead of address ranges to specify rules.
///
/// Assertions: The module checks every time there is a change in the address mapping
/// if the resulting map is valid. It fatals if `start_addr` is higher than `end_addr` (non-NAPOT
/// only) or if a mapping targets an index that is outside the number of allowed indices.
/// It issues warnings if the address regions of any two mappings overlap (non-NAPOT only).
module addr_decode #(
  /// Highest index which can happen in a rule.
  parameter int unsigned NoIndices = 32'd0,
  /// Total number of rules.
  parameter int unsigned NoRules   = 32'd0,
  /// Address type inside the rules and to decode.
  parameter type         addr_t    = logic,
  /// Rule packed struct type.
  /// The address decoder expects three fields in `rule_t`:
  ///
  /// typedef struct packed {
  ///   int unsigned idx;
  ///   addr_t       start_addr;
  ///   addr_t       end_addr;
  /// } rule_t;
  ///
  ///  - `idx`:        index of the rule, has to be < `NoIndices`
  ///  - `start_addr`: start address of the range the rule describes, value is included in range
  ///  - `end_addr`:   end address of the range the rule describes, value is NOT included in range
  ///                  if `end_addr == '0` end of address space is assumed
  ///
  /// If `Napot` is 1, The field names remain the same, but the rule describes a naturally-aligned
  /// power of two (NAPOT) region instead of an address range: `start_addr` becomes the base address
  /// and `end_addr` the mask. See the wrapping module `addr_decode_napot` for details.
  parameter type         rule_t    = logic,
  // Whether this is a NAPOT (base and mask) or regular range decoder
  parameter bit          Napot     = 0,
  /// Dependent parameter, do **not** overwite!
  ///
  /// Width of the `idx_o` output port.
  parameter int unsigned IdxWidth  = cf_math_pkg::idx_width(NoIndices),
  /// Dependent parameter, do **not** overwite!
  ///
  /// Type of the `idx_o` output port.
  parameter type         idx_t     = logic [IdxWidth-1:0]
) (
  /// Address to decode.
  input  addr_t               addr_i,
  /// Address map: rule with the highest array position wins on collision
  input  rule_t [NoRules-1:0] addr_map_i,
  /// Decoded index.
  output idx_t                idx_o,
  /// Decode is valid.
  output logic                dec_valid_o,
  /// Decode is not valid, no matching rule found.
  output logic                dec_error_o,
  /// Enable default port mapping.
  ///
  /// When not used, tie to `0`.
  input  logic                en_default_idx_i,
  /// Default port index.
  ///
  /// When `en_default_idx_i` is `1`, this will be the index when no rule matches.
  ///
  /// When not used, tie to `0`.
  input  idx_t                default_idx_i
);

  // wraps the dynamic configuration version of the address decoder
  addr_decode_dync #(
    .NoIndices ( NoIndices ),
    .NoRules   ( NoRules   ),
    .addr_t    ( addr_t    ),
    .rule_t    ( rule_t    ),
    .Napot     ( Napot     )
  ) i_addr_decode_dync (
    .addr_i,
    .addr_map_i,
    .idx_o,
    .dec_valid_o,
    .dec_error_o,
    .en_default_idx_i,
    .default_idx_i,
    .config_ongoing_i ( 1'b0 )
  );

endmodule
",addr_decode.sv.txt,common_cells\addr_decode.sv.txt
"[Keyword]: addr_decode_dync.sv

[Design Category]: Control Circuits

[Design Function Description]:
The module is an address decoder that maps an input address to an index based on a set of rules. It supports dynamic configuration and can handle overlapping address ranges, with the rule at the higher position prevailing. The module also supports a default mapping for addresses that do not match any rule. It can operate in two modes: regular range decoding and NAPOT (naturally-aligned power of two) region decoding.

[Input Signal Description]:
- `addr_i`: The address input that needs to be decoded.
- `addr_map_i`: An array of rules that define the address mapping. Each rule includes a start address, an end address, and an index.
- `en_default_idx_i`: A signal to enable default index mapping for unmatched addresses.
- `default_idx_i`: The default index to use when no rule matches and `en_default_idx_i` is enabled.
- `config_ongoing_i`: A signal indicating if the module is currently being configured, which deactivates its output and assertions.

[Output Signal Description]:
- `idx_o`: The decoded index corresponding to the input address.
- `dec_valid_o`: A signal indicating if the decoding was successful and valid.
- `dec_error_o`: A signal indicating if there was an error in decoding, such as no matching rule found.


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Authors:
// - Wolfgang Roenninger <wroennin@ethz.ch>
// - Paul Scheffler <paulsc@iis.ee.ethz.ch>
// - Michael Rogenmoser <michaero@iis.ee.ethz.ch>
// - Thomas Benz <tbenz@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

/// Address Decoder: Maps the input address combinatorially to an index.
/// DYNamic Configuration (DYNC) version
/// The address map `addr_map_i` is a packed array of rule_t structs.
/// The ranges of any two rules may overlap. If so, the rule at the higher (more significant)
/// position in `addr_map_i` prevails.
///
/// There can be an arbitrary number of address rules. There can be multiple
/// ranges defined for the same index. The start address has to be less than the end address.
///
/// There is the possibility to add a default mapping:
/// `en_default_idx_i`: Driving this port to `1'b1` maps all input addresses
/// for which no rule in `addr_map_i` exists to the default index specified by
/// `default_idx_i`. In this case, `dec_error_o` is always `1'b0`.
///
/// The `Napot` parameter allows using naturally-aligned power of two (NAPOT) regions,
/// using base addresses and masks instead of address ranges to specify rules.
///
/// Assertions: The module checks every time there is a change in the address mapping
/// if the resulting map is valid. It fatals if `start_addr` is higher than `end_addr` (non-NAPOT
/// only) or if a mapping targets an index that is outside the number of allowed indices.
/// It issues warnings if the address regions of any two mappings overlap (non-NAPOT only).
module addr_decode_dync #(
  /// Highest index which can happen in a rule.
  parameter int unsigned NoIndices = 32'd0,
  /// Total number of rules.
  parameter int unsigned NoRules   = 32'd0,
  /// Address type inside the rules and to decode.
  parameter type         addr_t    = logic,
  /// Rule packed struct type.
  /// The address decoder expects three fields in `rule_t`:
  ///
  /// typedef struct packed {
  ///   int unsigned idx;
  ///   addr_t       start_addr;
  ///   addr_t       end_addr;
  /// } rule_t;
  ///
  ///  - `idx`:        index of the rule, has to be < `NoIndices`
  ///  - `start_addr`: start address of the range the rule describes, value is included in range
  ///  - `end_addr`:   end address of the range the rule describes, value is NOT included in range
  ///                  if `end_addr == '0` end of address space is assumed
  ///
  /// If `Napot` is 1, The field names remain the same, but the rule describes a naturally-aligned
  /// power of two (NAPOT) region instead of an address range: `start_addr` becomes the base address
  /// and `end_addr` the mask. See the wrapping module `addr_decode_napot` for details.
  parameter type         rule_t    = logic,
  // Whether this is a NAPOT (base and mask) or regular range decoder
  parameter bit          Napot     = 0,
  /// Dependent parameter, do **not** overwite!
  ///
  /// Width of the `idx_o` output port.
  parameter int unsigned IdxWidth  = cf_math_pkg::idx_width(NoIndices),
  /// Dependent parameter, do **not** overwite!
  ///
  /// Type of the `idx_o` output port.
  parameter type         idx_t     = logic [IdxWidth-1:0]
) (
  /// Address to decode.
  input  addr_t               addr_i,
  /// Address map: rule with the highest array position wins on collision
  input  rule_t [NoRules-1:0] addr_map_i,
  /// Decoded index.
  output idx_t                idx_o,
  /// Decode is valid.
  output logic                dec_valid_o,
  /// Decode is not valid, no matching rule found.
  output logic                dec_error_o,
  /// Enable default port mapping.
  ///
  /// When not used, tie to `0`.
  input  logic                en_default_idx_i,
  /// Default port index.
  ///
  /// When `en_default_idx_i` is `1`, this will be the index when no rule matches.
  ///
  /// When not used, tie to `0`.
  input  idx_t                default_idx_i,
  /// The module is dynamically configured, this deactivates its output and the integrated
  /// assertions.
  input  logic                config_ongoing_i
);

  logic [NoRules-1:0] matched_rules; // purely for address map debugging

  always_comb begin
    // default assignments
    matched_rules = '0;
    dec_valid_o   = 1'b0;
    dec_error_o   = (en_default_idx_i) ? 1'b0 : 1'b1;
    idx_o         = (en_default_idx_i) ? default_idx_i : '0;

    // match the rules
    for (int unsigned i = 0; i < NoRules; i++) begin
      if (
        !Napot && (addr_i >= addr_map_i[i].start_addr) &&
        ((addr_i < addr_map_i[i].end_addr) || (addr_map_i[i].end_addr == '0)) ||
        Napot && (addr_map_i[i].start_addr & addr_map_i[i].end_addr) ==
                 (addr_i & addr_map_i[i].end_addr)
      ) begin
        matched_rules[i] = ~config_ongoing_i;
        dec_valid_o      = ~config_ongoing_i;
        dec_error_o      = 1'b0;
        idx_o            = config_ongoing_i ? default_idx_i : idx_t'(addr_map_i[i].idx);
      end
    end
  end

  // Assumptions and assertions
  `ifndef COMMON_CELLS_ASSERTS_OFF
  initial begin : proc_check_parameters
    `ASSUME_I(addr_width_mismatch, $bits(addr_i) == $bits(addr_map_i[0].start_addr),
             $sformatf(""Input address has %d bits and address map has %d bits."",
                       $bits(addr_i), $bits(addr_map_i[0].start_addr)))
    `ASSUME_I(norules_0, NoRules > 0, $sformatf(""At least one rule needed""))
    `ASSUME_I(noindices_0, NoIndices > 0, $sformatf(""At least one index needed""))
  end

  `ASSERT_FINAL(more_than_1_bit_set, $onehot0(matched_rules) || config_ongoing_i,
                ""More than one bit set in the one-hot signal, matched_rules"")

  // These following assumptions check the validity of the address map.
  // The assumptions gets generated for each distinct pair of rules.
  // Each assumption is present two times, as they rely on one rules being
  // effectively ordered. Only one of the rules with the same function is
  // active at a time for a given pair.
  // check_start:        Enforces a smaller start than end address.
  // check_idx:          Enforces a valid index in the rule.
  // check_overlap:      Warns if there are overlapping address regions.
  `ifndef SYNTHESIS
  always_comb begin : proc_check_addr_map
    if (!$isunknown(addr_map_i) && ~config_ongoing_i) begin
      for (int unsigned i = 0; i < NoRules; i++) begin
        `ASSUME_I(check_start, Napot || addr_map_i[i].start_addr < addr_map_i[i].end_addr ||
          addr_map_i[i].end_addr == '0,
          $sformatf(""This rule has a higher start than end address!!!\n\
              Violating rule %d.\n\
              Rule> IDX: %h START: %h END: %h\n\
              #####################################################"",
              i ,addr_map_i[i].idx, addr_map_i[i].start_addr, addr_map_i[i].end_addr))
        // check the SLV ids
        `ASSUME_I(check_idx, addr_map_i[i].idx < NoIndices,
            $sformatf(""This rule has a IDX that is not allowed!!!\n\
            Violating rule %d.\n\
            Rule> IDX: %h START: %h END: %h\n\
            Rule> MAX_IDX: %h\n\
            #####################################################"",
            i, addr_map_i[i].idx, addr_map_i[i].start_addr, addr_map_i[i].end_addr,
            (NoIndices-1)))
        for (int unsigned j = i + 1; j < NoRules; j++) begin
          // overlap check
          `ASSUME_I(check_overlap, Napot ||
                                  !((addr_map_i[j].start_addr < addr_map_i[i].end_addr) &&
                                    (addr_map_i[j].end_addr > addr_map_i[i].start_addr)) ||
                                  !((addr_map_i[i].end_addr == '0) &&
                                    (addr_map_i[j].end_addr > addr_map_i[i].start_addr)) ||
                                  !((addr_map_i[j].start_addr < addr_map_i[i].end_addr) &&
                                    (addr_map_i[j].end_addr == '0)),
              $sformatf(""Overlapping address region found!!!\n\
              Rule %d: IDX: %h START: %h END: %h\n\
              Rule %d: IDX: %h START: %h END: %h\n\
              #####################################################"",
              i, addr_map_i[i].idx, addr_map_i[i].start_addr, addr_map_i[i].end_addr,
              j, addr_map_i[j].idx, addr_map_i[j].start_addr, addr_map_i[j].end_addr))
        end
      end
    end
  end
  `endif
  `endif

endmodule
",addr_decode_dync.sv.txt,common_cells\addr_decode_dync.sv.txt
"[Keyword]: addr_decode_napot.sv

[Design Category]: Control Circuits

[Design Function Description]:
The module `addr_decode_napot` is a naturally-aligned power of two (NAPOT) address decoder. It is designed to decode an input address (`addr_i`) against a set of rules (`addr_map_i`) to determine a matching index (`idx_o`). The module outputs whether the decoding is valid or if there was an error due to no matching rule. It also supports a default index when no rule matches, controlled by an enable signal.

[Input Signal Description]:
- `addr_i`: The address input that needs to be decoded.
- `addr_map_i`: An array of rules that define the address map. Each rule contains an index, a base address, and a mask to determine matching conditions.
- `en_default_idx_i`: A logic signal to enable the use of a default index when no rule matches.
- `default_idx_i`: The default index to be used when `en_default_idx_i` is set to 1 and no rule matches.

[Output Signal Description]:
- `idx_o`: The decoded index output, indicating which rule matched the input address.
- `dec_valid_o`: A logic signal indicating if the decoding was successful and valid.
- `dec_error_o`: A logic signal indicating if there was an error in decoding, such as no matching rule found.


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Author: Paul Scheffler <paulsc@iis.ee.ethz.ch>

/// This module wraps `addr_decode_dync` in its naturally-aligned power of two (NAPOT) variant,
/// alleviating the need to set the `Napot` parameter and using more descriptive `rule_t`
/// field names. See the `addr_decode`documentation for details.
module addr_decode_napot #(
  /// Highest index which can happen in a rule.
  parameter int unsigned NoIndices = 32'd0,
  /// Total number of rules.
  parameter int unsigned NoRules   = 32'd0,
  /// Address type inside the rules and to decode.
  parameter type         addr_t    = logic,
  /// Rule packed struct type.
  /// The NAPOT address decoder expects three fields in `rule_t`:
  ///
  /// typedef struct packed {
  ///   int unsigned idx;
  ///   addr_t       base;
  ///   addr_t       mask;
  /// } rule_t;
  ///
  ///  - `idx`:   index of the rule, has to be < `NoIndices`.
  ///  - `base`:  base address whose specified bits should match `addr_i`.
  ///  - `mask`:  set for bits which are to be checked to determine a match.
  parameter type         rule_t    = logic,
  /// Dependent parameter, do **not** overwite!
  ///
  /// Width of the `idx_o` output port.
  parameter int unsigned IdxWidth  = cf_math_pkg::idx_width(NoIndices),
  /// Dependent parameter, do **not** overwite!
  ///
  /// Type of the `idx_o` output port.
  parameter type         idx_t     = logic [IdxWidth-1:0]
) (
  /// Address to decode.
  input  addr_t               addr_i,
  /// Address map: rule with the highest array position wins on collision
  input  rule_t [NoRules-1:0] addr_map_i,
  /// Decoded index.
  output idx_t                idx_o,
  /// Decode is valid.
  output logic                dec_valid_o,
  /// Decode is not valid, no matching rule found.
  output logic                dec_error_o,
  /// Enable default port mapping.
  ///
  /// When not used, tie to `0`.
  input  logic                en_default_idx_i,
  /// Default port index.
  ///
  /// When `en_default_idx_i` is `1`, this will be the index when no rule matches.
  ///
  /// When not used, tie to `0`.
  input  idx_t                default_idx_i
);

  // Rename struct field names to those expected by `addr_decode`
  typedef struct packed {
    int unsigned  idx;
    addr_t        start_addr;
    addr_t        end_addr;
  } rule_range_t;

  addr_decode_dync #(
    .NoIndices ( NoIndices    ) ,
    .NoRules   ( NoRules      ),
    .addr_t    ( addr_t       ),
    .rule_t    ( rule_range_t ),
    .Napot     ( 1            )
  ) i_addr_decode_dync (
    .addr_i,
    .addr_map_i,
    .idx_o,
    .dec_valid_o,
    .dec_error_o,
    .en_default_idx_i,
    .default_idx_i,
    .config_ongoing_i ( 1'b0 )
);

endmodule
",addr_decode_napot.sv.txt,common_cells\addr_decode_napot.sv.txt
"[Keyword]: binary_to_gray.sv

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is a binary to Gray code converter. It takes an N-bit binary number as input and converts it to its equivalent N-bit Gray code representation. Gray code is a binary numeral system where two successive values differ in only one bit.

[Input Signal Description]:
A[N-1:0]: An N-bit input signal representing the binary number that needs to be converted to Gray code.

[Output Signal Description]:
Z[N-1:0]: An N-bit output signal representing the Gray code equivalent of the input binary number.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>

/// A binary to gray code converter.
module binary_to_gray #(
    parameter int N = -1
)(
    input  logic [N-1:0] A,
    output logic [N-1:0] Z
);
    assign Z = A ^ (A >> 1);
endmodule
",binary_to_gray.sv.txt,common_cells\binary_to_gray.sv.txt
"[Keyword]: cb_filter.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design implements a counting bloom filter, which is a probabilistic data structure used for set membership testing. It allows for efficient set lookups with the possibility of false positives but no false negatives. The filter uses multiple hash functions to map input data to an array of counters (buckets). The design supports operations to add data to the filter, remove data from the filter, and check if data is present in the filter. It also provides status signals indicating the filter's usage, whether it is full or empty, and if any errors have occurred due to counter overflows.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronous operations.
- `rst_ni`: Active low reset signal to initialize the filter.
- `look_data_i`: Input data for lookup operations to check membership in the filter.
- `incr_data_i`: Input data for increment operations to add data to the filter.
- `incr_valid_i`: Valid signal indicating when `incr_data_i` is valid for processing.
- `decr_data_i`: Input data for decrement operations to remove data from the filter.
- `decr_valid_i`: Valid signal indicating when `decr_data_i` is valid for processing.
- `filter_clear_i`: Signal to clear the filter and reset all counters to zero.

[Output Signal Description]:
- `look_valid_o`: Output signal indicating if the `look_data_i` was previously added to the filter.
- `filter_usage_o`: Output signal indicating the number of data items currently in the filter.
- `filter_full_o`: Output signal indicating if the filter is full and cannot hold more items.
- `filter_empty_o`: Output signal indicating if the filter is empty.
- `filter_error_o`: Output signal indicating if there is an error due to counter overflow.


[Design Detail]:
// Copyright (c) 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Wolfgang Roenninger <wroennin@ethz.ch>

// `cb_filter`: This module implements a counting bloom filter with parameterizable hash functions.
//
// Functionality: A counting bloom filter is a data structure to efficiently implement
//                set lookups. It does so by hashing its data inputs onto multiple pointers
//                which serve as indicators for an array of buckets. For lookups can be
//                false positives, but no false negatives.
// - Seeding:     The pseudo random generators need seeds at elaboration time to generate
//                different hashes. In principle any combination of seeds can be used.
//                But one should look that the hash outputs give sufficient different patterns,
//                such that the resulting collision rate is low. The package `cb_filter_pkg`
//                contains the struct for seeding the PRG's in the hash functions.
// - Lookup:
//   - Ports:       `look_data_i`, `look_valid_o`
//   - Description: Lookup combinational, `look_valid_o` is high, when `look_data_i` was
//                  previously put into the filter.
// - Increment:
//   - Ports:       `incr_data_i`, `incr_valid_i`
//   - Description: Put data into the counting bloom filter, when valid is high.
// - Decrement:
//   - Ports:       `decr_data_i`, `decr_valid_i`
//   - Description: Remove data from the counting bloom filter. Only remove data that was
//                  previously put in, otherwise will go in a wrong state.
// - Status:
//   - `filter_clear_i`:  Clears the filter and sets all counters to 0.
//   - `filter_ussage_o`: How many data items are currently in the filter.
//   - `filter_full_o`:   Filter is full, can no longer hold more items.
//   - `filter_empty_o`:  Filter is empty.
//   - `filter_error_o`:  One of the internal counters or buckets overflowed.

`include ""common_cells/assertions.svh""

/// This is a counting bloom filter
module cb_filter #(
  parameter int unsigned KHashes     =  32'd3,  // Number of hash functions
  parameter int unsigned HashWidth   =  32'd4,  // Number of counters is 2**HashWidth
  parameter int unsigned HashRounds  =  32'd1,  // Number of permutation substitution rounds
  parameter int unsigned InpWidth    =  32'd32, // Input data width
  parameter int unsigned BucketWidth =  32'd4,  // Width of Bucket counters
  // the seeds used for seeding the PRG's inside each hash, one `cb_seed_t` per hash function.
  parameter cb_filter_pkg::cb_seed_t [KHashes-1:0] Seeds = cb_filter_pkg::EgSeeds
) (
  input  logic                 clk_i,   // Clock
  input  logic                 rst_ni,  // Active low reset
  // data lookup
  input  logic [InpWidth-1:0]  look_data_i,
  output logic                 look_valid_o,
  // data increment
  input  logic [InpWidth-1:0]  incr_data_i,
  input  logic                 incr_valid_i,
  // data decrement
  input  logic [InpWidth-1:0]  decr_data_i,
  input  logic                 decr_valid_i,
  // status signals
  input  logic                 filter_clear_i,
  output logic [HashWidth-1:0] filter_usage_o,
  output logic                 filter_full_o,
  output logic                 filter_empty_o,
  output logic                 filter_error_o
);

  localparam int unsigned NoCounters  = 2**HashWidth;

  // signal declarations
  logic [NoCounters-1:0] look_ind; // hash function pointers
  logic [NoCounters-1:0] incr_ind; // hash function pointers
  logic [NoCounters-1:0] decr_ind; // hash function pointers
  // bucket (counter signals)
  logic [NoCounters-1:0] bucket_en;
  logic [NoCounters-1:0] bucket_down;
  logic [NoCounters-1:0] bucket_occupied;
  logic [NoCounters-1:0] bucket_overflow;
  logic [NoCounters-1:0] bucket_full;
  logic [NoCounters-1:0] bucket_empty;
  // membership lookup signals
  logic [NoCounters-1:0] data_in_bucket;
  // tot count signals (filter usage)
  logic cnt_en;
  logic cnt_down;
  logic cnt_overflow;

  // -----------------------------------------
  // Lookup Hash - Membership Detection
  // -----------------------------------------
  hash_block #(
    .NoHashes     ( KHashes      ),
    .InpWidth     ( InpWidth     ),
    .HashWidth    ( HashWidth    ),
    .NoRounds     ( HashRounds   ),
    .Seeds        ( Seeds        )
  ) i_look_hashes (
    .data_i       ( look_data_i  ),
    .indicator_o  ( look_ind     )
  );
  assign data_in_bucket = look_ind & bucket_occupied;
  assign look_valid_o   = (data_in_bucket == look_ind) ? 1'b1 : 1'b0;

  // -----------------------------------------
  // Increment Hash - Add Member to Set
  // -----------------------------------------
  hash_block #(
    .NoHashes     ( KHashes      ),
    .InpWidth     ( InpWidth     ),
    .HashWidth    ( HashWidth    ),
    .NoRounds     ( HashRounds   ),
    .Seeds        ( Seeds        )
  ) i_incr_hashes (
    .data_i       ( incr_data_i  ),
    .indicator_o  ( incr_ind     )
  );

  // -----------------------------------------
  // Decrement Hash - Remove Member from Set
  // -----------------------------------------
  hash_block #(
    .NoHashes     ( KHashes      ),
    .InpWidth     ( InpWidth     ),
    .HashWidth    ( HashWidth    ),
    .NoRounds     ( HashRounds   ),
    .Seeds        ( Seeds        )
  ) i_decr_hashes (
    .data_i       ( decr_data_i  ),
    .indicator_o  ( decr_ind     )
  );

  // -----------------------------------------
  // Control the incr/decr of buckets
  // -----------------------------------------
  assign bucket_down = decr_valid_i ? decr_ind : '0;

  always_comb begin : proc_bucket_control
    case ({incr_valid_i, decr_valid_i})
      2'b00 : bucket_en = '0;
      2'b10 : bucket_en = incr_ind;
      2'b01 : bucket_en = decr_ind;
      2'b11 : bucket_en = incr_ind ^ decr_ind;
      default: bucket_en = '0; // unreachable
    endcase
  end

  // -----------------------------------------
  // Counters
  // -----------------------------------------
  for (genvar i = 0; i < NoCounters; i++) begin : gen_buckets
    logic [BucketWidth-1:0] bucket_content;
    counter #(
      .WIDTH( BucketWidth )
    ) i_bucket (
      .clk_i      ( clk_i             ),
      .rst_ni     ( rst_ni            ),
      .clear_i    ( filter_clear_i    ),
      .en_i       ( bucket_en[i]      ),
      .load_i     ( '0                ),
      .down_i     ( bucket_down[i]    ),
      .d_i        ( '0                ),
      .q_o        ( bucket_content    ),
      .overflow_o ( bucket_overflow[i])
    );
    assign bucket_full[i]     =  bucket_overflow[i] | (&bucket_content);
    assign bucket_occupied[i] = |bucket_content;
    assign bucket_empty[i]    = ~bucket_occupied[i];
  end

  // -----------------------------------------
  // Filter tot item counter
  // -----------------------------------------
  assign cnt_en   = incr_valid_i ^ decr_valid_i;
  assign cnt_down = decr_valid_i;
  counter #(
    .WIDTH ( HashWidth )
  ) i_tot_count (
    .clk_i     ( clk_i          ),
    .rst_ni    ( rst_ni         ),
    .clear_i   ( filter_clear_i ),
    .en_i      ( cnt_en         ),
    .load_i    ( '0             ),
    .down_i    ( cnt_down       ),
    .d_i       ( '0             ),
    .q_o       ( filter_usage_o ),
    .overflow_o( cnt_overflow   )
  );

  // -----------------------------------------
  // Filter Output Flags
  // -----------------------------------------
  assign filter_full_o  = |bucket_full;
  assign filter_empty_o = &bucket_empty;
  assign filter_error_o = |bucket_overflow | cnt_overflow;
endmodule

// gives out the or 'onehots' of all hash functions
module hash_block #(
  parameter int unsigned NoHashes                         = 32'd3,
  parameter int unsigned InpWidth                         = 32'd11,
  parameter int unsigned HashWidth                        = 32'd5,
  parameter int unsigned NoRounds                         = 32'd1,
  parameter cb_filter_pkg::cb_seed_t [NoHashes-1:0] Seeds = cb_filter_pkg::EgSeeds
) (
  input  logic [InpWidth-1:0]     data_i,
  output logic [2**HashWidth-1:0] indicator_o
);

  logic [NoHashes-1:0][2**HashWidth-1:0] hashes;

  for (genvar i = 0; i < NoHashes; i++) begin : gen_hashes
    sub_per_hash #(
      .InpWidth   ( InpWidth             ),
      .HashWidth  ( HashWidth            ),
      .NoRounds   ( NoRounds             ),
      .PermuteKey ( Seeds[i].PermuteSeed ),
      .XorKey     ( Seeds[i].XorSeed     )
    ) i_hash (
      .data_i        ( data_i    ),
      .hash_o        (           ), // not used, because we want the onehot
      .hash_onehot_o ( hashes[i] )
    );
  end

  // output assignment
  always_comb begin : proc_hash_or
    indicator_o = '0;
    for (int unsigned i = 0; i < (2**HashWidth); i++) begin
      for (int unsigned j = 0; j < NoHashes; j++) begin
        indicator_o[i] = indicator_o[i] | hashes[j][i];
      end
    end
  end

`ifndef COMMON_CELLS_ASSERTS_OFF
  // assertions
  initial begin
    `ASSUME_I(hash_conf, InpWidth > HashWidth,
      $sformatf(""%m:\nA Hash Function reduces the width of the input>\nInpWidth: %s\nOUT_WIDTH: %s"",
          InpWidth, HashWidth))
  end
`endif
endmodule
",cb_filter.sv.txt,common_cells\cb_filter.sv.txt
"[Keyword]: cb_filter_pkg.sv

[Design Category]: Combinational Logic

[Design Function Description]:
This package defines a structure for seeds used in a combinational logic context, specifically for permutation and XOR operations. It provides a template for how seeds can be organized and includes an example of seed initialization.

[Input Signal Description]:
There are no direct input signals in this package as it primarily defines a data structure. However, the structure `cb_seed_t` includes two unsigned integer fields: `PermuteSeed` and `XorSeed`, which are intended to be used as seeds for permutation and XOR operations, respectively.

[Output Signal Description]:
There are no direct output signals in this package. The package provides a structured way to handle seed data, which can be used in other modules or functions that perform operations requiring these seeds.


[Design Detail]:
// Copyright (c) 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Wolfgang Roenninger <wroennin@ethz.ch>

/// Package with the struct definition for the seeds and an example.
package cb_filter_pkg;
  typedef struct packed {
    int unsigned PermuteSeed;
    int unsigned XorSeed;
  } cb_seed_t;

  // example seeding struct
  localparam cb_seed_t [2:0] EgSeeds = '{
    '{PermuteSeed: 32'd299034753, XorSeed: 32'd4094834  },
    '{PermuteSeed: 32'd19921030,  XorSeed: 32'd995713   },
    '{PermuteSeed: 32'd294388,    XorSeed: 32'd65146511 }
  };
endpackage
",cb_filter_pkg.sv.txt,common_cells\cb_filter_pkg.sv.txt
"[Keyword]: cc_onehot.sv

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a hardware version of the SystemVerilog `$onehot()` function. It checks if exactly one bit in the input vector is set to '1'. The implementation uses a tree of half adders to compute the sum and carry, and a separate OR reduction tree to determine if there is more than one '1' in the input.

[Input Signal Description]:
d_i[Width-1:0]: A logic vector input of configurable width (default is 4 bits). This input is checked to determine if it is a one-hot encoded signal, meaning only one bit is set to '1'.

[Output Signal Description]:
is_onehot_o: A logic output that indicates whether the input vector `d_i` is one-hot encoded. It outputs '1' if exactly one bit in `d_i` is '1', otherwise it outputs '0'.


[Design Detail]:
// Copyright 2021 ETH Zurich.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// Hardware implementation of SystemVerilog's `$onehot()` function.
/// It uses a tree of half adders and a separate
/// or reduction tree for the carry.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Author: Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Author: Stefan Mach <smach@iis.ee.ethz.ch>
module cc_onehot #(
  parameter int unsigned Width = 4
) (
  input  logic [Width-1:0] d_i,
  output logic is_onehot_o
);
  // trivial base case
  if (Width == 1) begin : gen_degenerated_onehot
    assign is_onehot_o = d_i;
  end else begin : gen_onehot
    localparam int LVLS = $clog2(Width) + 1;

    logic [LVLS-1:0][2**(LVLS-1)-1:0] sum, carry;
    logic [LVLS-2:0] carry_array;

    // Extend to a power of two.
    assign sum[0] = $unsigned(d_i);

    // generate half adders for each lvl
    // lvl 0 is the input level
    for (genvar i = 1; i < LVLS; i++) begin : gen_lvl
      localparam int unsigned LVLWidth = 2**LVLS / 2**i;
      for (genvar j = 0; j < LVLWidth; j+=2) begin : gen_width
        assign sum[i][j/2] = sum[i-1][j] ^ sum[i-1][j+1];
        assign carry[i][j/2] = sum[i-1][j] & sum[i-1][j+1];
      end
      // generate carry tree
      assign carry_array[i-1] = |carry[i][LVLWidth/2-1:0];
    end
    assign is_onehot_o = sum[LVLS-1][0] & ~|carry_array;
  end

endmodule
",cc_onehot.sv.txt,common_cells\cc_onehot.sv.txt
"[Keyword]: cdc_2phase.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements a two-phase clock domain crossing (CDC) mechanism. It facilitates the transfer of data between two different clock domains, ensuring data integrity and preventing metastability. The module uses asynchronous handshake signals to manage data transfer between the source and destination domains.

[Input Signal Description]:
- `src_rst_ni`: Active-low reset signal for the source domain.
- `src_clk_i`: Clock signal for the source domain.
- `src_data_i`: Data input from the source domain.
- `src_valid_i`: Validity signal indicating that the source data is ready to be sent.
- `dst_rst_ni`: Active-low reset signal for the destination domain.
- `dst_clk_i`: Clock signal for the destination domain.
- `dst_ready_i`: Signal indicating that the destination domain is ready to receive data.

[Output Signal Description]:
- `src_ready_o`: Signal indicating that the source domain is ready to accept new data.
- `dst_data_o`: Data output to the destination domain.
- `dst_valid_o`: Validity signal indicating that the destination data is ready to be received.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>

/// A two-phase clock domain crossing.
///
/// # Reset Behavior!!
///
/// This module must not be used if warm reset capabily is a requirement. The
/// only execption is if you consistently use a reset controller that sequences
/// the resets while gating both clock domains (be very careful if you follow
/// this strategy!). If you need warm reset/clear/flush capabilities, use (AND
/// CAREFULLY READ THE DESCRIPTION) the cdc_2phase_clearable module.
///
/// After this disclaimer, here is how you connect the src_rst_ni and the
/// dst_rst_ni of this module for power-on-reset (POR). The src_rst_ni and
/// dst_rst_ni signal must be asserted SIMULTANEOUSLY (i.e. asynchronous
/// assertion). Othwerwise, spurious transactions could occur in the domain
/// where the reset arrives later than the other. The de-assertion of both reset
/// must be synchronized to their respective clock domain (i.e. src_rst_ni must
/// be deasserted synchronously to the src_clk_i and dst_rst_ni must be
/// deasserted synchronously to dst_clk_i.) You can use the rstgen cell in the
/// common_cells library to achieve this (synchronization of only the
/// de-assertion). However, be careful about reset domain crossings; If you
/// reset both domain asynchronously in their entirety (i.e. POR) you are fine.
/// However, if you use this strategy for warm resets (some parts of the circuit
/// are not reset) you might introduce metastability in this separate
/// reset-domain when you assert the reset (the deassertion synchronizer doen't
/// help here).
///
/// CONSTRAINT: Requires max_delay of min_period(src_clk_i, dst_clk_i) through
/// the paths async_req, async_ack, async_data.
/* verilator lint_off DECLFILENAME */
module cdc_2phase #(
  parameter type T = logic
)(
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i
);

  // Asynchronous handshake signals.
  (* dont_touch = ""true"" *) logic async_req;
  (* dont_touch = ""true"" *) logic async_ack;
  (* dont_touch = ""true"" *) T async_data;

  // The sender in the source domain.
  cdc_2phase_src #(.T(T)) i_src (
    .rst_ni       ( src_rst_ni  ),
    .clk_i        ( src_clk_i   ),
    .data_i       ( src_data_i  ),
    .valid_i      ( src_valid_i ),
    .ready_o      ( src_ready_o ),
    .async_req_o  ( async_req   ),
    .async_ack_i  ( async_ack   ),
    .async_data_o ( async_data  )
  );

  // The receiver in the destination domain.
  cdc_2phase_dst #(.T(T)) i_dst (
    .rst_ni       ( dst_rst_ni  ),
    .clk_i        ( dst_clk_i   ),
    .data_o       ( dst_data_o  ),
    .valid_o      ( dst_valid_o ),
    .ready_i      ( dst_ready_i ),
    .async_req_i  ( async_req   ),
    .async_ack_o  ( async_ack   ),
    .async_data_i ( async_data  )
  );

endmodule


/// Half of the two-phase clock domain crossing located in the source domain.
module cdc_2phase_src #(
  parameter type T = logic
)(
  input  logic rst_ni,
  input  logic clk_i,
  input  T     data_i,
  input  logic valid_i,
  output logic ready_o,
  output logic async_req_o,
  input  logic async_ack_i,
  output T     async_data_o
);

  (* dont_touch = ""true"" *)
  logic req_src_q, ack_src_q, ack_q;
  (* dont_touch = ""true"" *)
  T data_src_q;

  // The req_src and data_src registers change when a new data item is accepted.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      req_src_q  <= 0;
      data_src_q <= T'('0);
    end else if (valid_i && ready_o) begin
      req_src_q  <= ~req_src_q;
      data_src_q <= data_i;
    end
  end

  // The ack_src and ack registers act as synchronization stages.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      ack_src_q <= 0;
      ack_q     <= 0;
    end else begin
      ack_src_q <= async_ack_i;
      ack_q     <= ack_src_q;
    end
  end

  // Output assignments.
  assign ready_o = (req_src_q == ack_q);
  assign async_req_o = req_src_q;
  assign async_data_o = data_src_q;

endmodule


/// Half of the two-phase clock domain crossing located in the destination
/// domain.
module cdc_2phase_dst #(
  parameter type T = logic
)(
  input  logic rst_ni,
  input  logic clk_i,
  output T     data_o,
  output logic valid_o,
  input  logic ready_i,
  input  logic async_req_i,
  output logic async_ack_o,
  input  T     async_data_i
);

  (* dont_touch = ""true"" *)
  (* async_reg = ""true"" *)
  logic req_dst_q, req_q0, req_q1, ack_dst_q;
  (* dont_touch = ""true"" *)
  T data_dst_q;

  // The ack_dst register changes when a new data item is accepted.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      ack_dst_q  <= 0;
    end else if (valid_o && ready_i) begin
      ack_dst_q  <= ~ack_dst_q;
    end
  end

  // The data_dst register changes when a new data item is presented. This is
  // indicated by the async_req line changing levels.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      data_dst_q <= T'('0);
    end else if (req_q0 != req_q1 && !valid_o) begin
      data_dst_q <= async_data_i;
    end
  end

  // The req_dst and req registers act as synchronization stages.
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      req_dst_q <= 0;
      req_q0    <= 0;
      req_q1    <= 0;
    end else begin
      req_dst_q <= async_req_i;
      req_q0    <= req_dst_q;
      req_q1    <= req_q0;
    end
  end

  // Output assignments.
  assign valid_o = (ack_dst_q != req_q1);
  assign data_o = data_dst_q;
  assign async_ack_o = ack_dst_q;

endmodule
/* verilator lint_on DECLFILENAME */
",cdc_2phase.sv.txt,common_cells\cdc_2phase.sv.txt
"[Keyword]: cdc_2phase_clearable.sv

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a two-phase clock domain crossing (CDC) with clearability features. It allows data transfer between two clock domains (source and destination) while handling asynchronous and synchronous reset signals. The module ensures that no spurious transactions occur during resets and provides a mechanism to clear pending transactions safely.

[Input Signal Description]:
- `src_rst_ni`: Active-low reset signal for the source clock domain.
- `src_clk_i`: Clock signal for the source domain.
- `src_clear_i`: Clear signal for the source domain, used to initiate a reset sequence.
- `src_data_i`: Data input from the source domain.
- `src_valid_i`: Valid signal indicating the presence of valid data in the source domain.
- `dst_rst_ni`: Active-low reset signal for the destination clock domain.
- `dst_clk_i`: Clock signal for the destination domain.
- `dst_clear_i`: Clear signal for the destination domain, used to initiate a reset sequence.
- `dst_ready_i`: Ready signal from the destination domain indicating readiness to accept data.

[Output Signal Description]:
- `src_clear_pending_o`: Indicates if a clear operation is pending in the source domain.
- `src_ready_o`: Indicates if the source domain is ready to accept new data.
- `dst_clear_pending_o`: Indicates if a clear operation is pending in the destination domain.
- `dst_data_o`: Data output to the destination domain.
- `dst_valid_o`: Valid signal indicating the presence of valid data in the destination domain.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch> (original CDC)
// Manuel Eggimann <meggiman@iis.ee.ethz.ch> (clearability feature)

/// A two-phase clock domain crossing.
///
/// CONSTRAINT: Requires max_delay of min_period(src_clk_i, dst_clk_i) through
/// the paths async_req, async_ack, async_data.
///
///
/// Reset Behavior:
///
/// In contrast to the cdc_2phase version without clear signal, this module
/// supports one-sided warm resets (asynchronously and synchronously). The way
/// this is implemented is described in more detail in the cdc_reset_ctrlr
/// module. To summarize a synchronous clear request i.e. src/dst_clear_i will
/// cause the respective other clock domain to reset as well without introducing
/// any spurious transactions. This is acomplished by an internal module
/// (cdc_reset_ctrlr) that starts a reset sequence on both sides of the CDC in
/// lock-step that first isolates the CDC from the outside world and then resets
/// it. The reset sequencer provides the following behavior:
/// 1. There are no spurious invalid or duplicated transactions regardless how
///    the individual sides are reset (can also happen roughly simultaneosly)
/// 2. The CDC becomes unready at the src side in the next cycle after
///    synchronous reset request until the reset sequence is completed. A currently
///    pending transactions might still complete (if the dst accepts at the
///    exact time the reset is request on the src die).
/// 3. During the reset sequence the dst might withdraw the valid signal. This
///    might violate higher level protocols. If you need this feature you would
///    have to path the existing implementation to wait with the isolate_ack
///    assertion until all open handshakes were acknowledged.
/// 4. If the parameter CLEAR_ON_ASYNC_RESET is enabled, the same behavior as
///    above is also valid for asynchronous resets on either side. However, this
///    increases the minimum number of synchronization stages (SYNC_STAGES
///    parameter) from 2 to 3 (read the cdc_reset_ctrlr header to figure out
///    why).
///
///
/* verilator lint_off DECLFILENAME */

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

module cdc_2phase_clearable #(
  parameter type T = logic,
  parameter int unsigned SYNC_STAGES = 3,
  parameter int CLEAR_ON_ASYNC_RESET = 1
)(
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  logic src_clear_i,
  output logic src_clear_pending_o,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  input  logic dst_clear_i,
  output logic dst_clear_pending_o,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i
);
  logic        s_src_clear_req;
  logic        s_src_clear_ack_q;
  logic        s_src_ready;
  logic        s_src_isolate_req;
  logic        s_src_isolate_ack_q;
  logic        s_dst_clear_req;
  logic        s_dst_clear_ack_q;
  logic        s_dst_valid;
  logic        s_dst_isolate_req;
  logic        s_dst_isolate_ack_q;

  // Asynchronous handshake signals between the CDCs
  (* dont_touch = ""true"" *) logic async_req;
  (* dont_touch = ""true"" *) logic async_ack;
  (* dont_touch = ""true"" *) T async_data;

  if (CLEAR_ON_ASYNC_RESET) begin : gen_elaboration_assertion
    if (SYNC_STAGES < 3)
      $error(""The clearable 2-phase CDC with async reset"",
             ""synchronization requires at least 3 synchronizer stages for the FIFO."");
  end else begin : gen_elaboration_assertion
    if (SYNC_STAGES < 2) begin : gen_elaboration_assertion
      $error(""A minimum of 2 synchronizer stages is required for proper functionality."");
    end
  end


  // The sender in the source domain.
  cdc_2phase_src_clearable #(
    .T           ( T           ),
    .SYNC_STAGES ( SYNC_STAGES )
  ) i_src (
    .rst_ni       ( src_rst_ni                       ),
    .clk_i        ( src_clk_i                        ),
    .clear_i      ( s_src_clear_req                      ),
    .data_i       ( src_data_i                       ),
    .valid_i      ( src_valid_i & !s_src_isolate_req ),
    .ready_o      ( s_src_ready                      ),
    .async_req_o  ( async_req                        ),
    .async_ack_i  ( async_ack                        ),
    .async_data_o ( async_data                       )
  );

  assign src_ready_o = s_src_ready & !s_src_isolate_req;


  // The receiver in the destination domain.
  cdc_2phase_dst_clearable #(
    .T           ( T           ),
    .SYNC_STAGES ( SYNC_STAGES )
  ) i_dst (
    .rst_ni       ( dst_rst_ni                       ),
    .clk_i        ( dst_clk_i                        ),
    .clear_i      ( s_dst_clear_req                      ),
    .data_o       ( dst_data_o                       ),
    .valid_o      ( s_dst_valid                      ),
    .ready_i      ( dst_ready_i & !s_dst_isolate_req ),
    .async_req_i  ( async_req                        ),
    .async_ack_o  ( async_ack                        ),
    .async_data_i ( async_data                       )
  );

  assign dst_valid_o = s_dst_valid & !s_dst_isolate_req;

  // Synchronize the clear and reset signaling in both directions (see header of
  // the cdc_reset_ctrlr module for more details.)
  cdc_reset_ctrlr #(
    .SYNC_STAGES(SYNC_STAGES-1)
  ) i_cdc_reset_ctrlr (
    .a_clk_i         ( src_clk_i           ),
    .a_rst_ni        ( src_rst_ni          ),
    .a_clear_i       ( src_clear_i         ),
    .a_clear_o       ( s_src_clear_req     ),
    .a_clear_ack_i   ( s_src_clear_ack_q   ),
    .a_isolate_o     ( s_src_isolate_req   ),
    .a_isolate_ack_i ( s_src_isolate_ack_q ),
    .b_clk_i         ( dst_clk_i           ),
    .b_rst_ni        ( dst_rst_ni          ),
    .b_clear_i       ( dst_clear_i         ),
    .b_clear_o       ( s_dst_clear_req     ),
    .b_clear_ack_i   ( s_dst_clear_ack_q   ),
    .b_isolate_o     ( s_dst_isolate_req   ),
    .b_isolate_ack_i ( s_dst_isolate_ack_q )
  );

  // Just delay the isolate request by one cycle. We can ensure isolation within
  // one cycle by just deasserting valid and ready signals on both sides of the CDC.
  always_ff @(posedge src_clk_i, negedge src_rst_ni) begin
    if (!src_rst_ni) begin
      s_src_isolate_ack_q <= 1'b0;
      s_src_clear_ack_q   <= 1'b0;
    end else begin
      s_src_isolate_ack_q <= s_src_isolate_req;
      s_src_clear_ack_q   <= s_src_clear_req;
    end
  end

  always_ff @(posedge dst_clk_i, negedge dst_rst_ni) begin
    if (!dst_rst_ni) begin
      s_dst_isolate_ack_q <= 1'b0;
      s_dst_clear_ack_q   <= 1'b0;
    end else begin
      s_dst_isolate_ack_q <= s_dst_isolate_req;
      s_dst_clear_ack_q   <= s_dst_clear_req;
    end
  end


  assign src_clear_pending_o = s_src_isolate_req; // The isolate signal stays
  // asserted during the whole
  // clear sequence.
  assign dst_clear_pending_o = s_dst_isolate_req;


`ifndef COMMON_CELLS_ASSERTS_OFF

  `ASSERT(no_valid_i_during_clear_i, src_clear_i |-> !src_valid_i, src_clk_i, !src_rst_ni)

`endif

endmodule


/// Half of the two-phase clock domain crossing located in the source domain.
module cdc_2phase_src_clearable #(
  parameter type T = logic,
  parameter int unsigned SYNC_STAGES = 2
) (
  input  logic rst_ni,
  input  logic clk_i,
  input  logic clear_i,
  input  T     data_i,
  input  logic valid_i,
  output logic ready_o,
  output logic async_req_o,
  input  logic async_ack_i,
  output T     async_data_o
);

  (* dont_touch = ""true"" *)
  logic  req_src_d, req_src_q, ack_synced;
  (* dont_touch = ""true"" *)
  T data_src_d, data_src_q;

  // Synchronize the async ACK
  sync #(
    .STAGES(SYNC_STAGES)
  ) i_sync(
    .clk_i,
    .rst_ni,
    .serial_i( async_ack_i ),
    .serial_o( ack_synced  )
  );

  // If we receive the clear signal clear the content of the request flip-flop
  // and the data register
  always_comb begin
    data_src_d = data_src_q;
    req_src_d  = req_src_q;
    if (clear_i) begin
      req_src_d  = 1'b0;
    // The req_src and data_src registers change when a new data item is accepted.
    end else if (valid_i && ready_o) begin
      req_src_d  = ~req_src_q;
      data_src_d = data_i;
    end
  end

  `FFNR(data_src_q, data_src_d, clk_i)

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      req_src_q  <= 0;
    end else begin
      req_src_q  <= req_src_d;
    end
  end

  // Output assignments.
  assign ready_o = (req_src_q == ack_synced);
  assign async_req_o = req_src_q;
  assign async_data_o = data_src_q;

// Assertions
`ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSUME(no_clear_and_request, clear_i |-> ~valid_i, clk_i, !rst_ni,
          ""No request allowed while clear_i is asserted."")
`endif

endmodule


/// Half of the two-phase clock domain crossing located in the destination
/// domain.
module cdc_2phase_dst_clearable #(
  parameter type T = logic,
  parameter int unsigned SYNC_STAGES = 2
)(
  input  logic rst_ni,
  input  logic clk_i,
  input  logic clear_i,
  output T     data_o,
  output logic valid_o,
  input  logic ready_i,
  input  logic async_req_i,
  output logic async_ack_o,
  input  T     async_data_i
);

  (* dont_touch = ""true"" *)
  (* async_reg = ""true"" *)
 logic ack_dst_d, ack_dst_q, req_synced, req_synced_q1;
  (* dont_touch = ""true"" *)
  T data_dst_d, data_dst_q;


  //Synchronize the request
  sync #(
    .STAGES(SYNC_STAGES)
  ) i_sync(
    .clk_i,
    .rst_ni,
    .serial_i( async_req_i ),
    .serial_o( req_synced  )
  );

  // The ack_dst register changes when a new data item is accepted.
  always_comb begin
    ack_dst_d = ack_dst_q;
    if (clear_i) begin
      ack_dst_d = 1'b0;
    end else if (valid_o && ready_i) begin
      ack_dst_d = ~ack_dst_q;
    end
  end

  // The data_dst register samples when a new data item is presented. This is
  // indicated by a transition in the req_synced line.
  always_comb begin
    data_dst_d = data_dst_q;
    if (req_synced != req_synced_q1 && !valid_o) begin
      data_dst_d = async_data_i;
    end
  end

  `FFNR(data_dst_q, data_dst_d, clk_i)

  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      ack_dst_q     <= 0;
      req_synced_q1 <= 1'b0;
    end else begin
      ack_dst_q     <= ack_dst_d;
      // The req_synced_q1 is the delayed version of the synchronized req_synced
      // used to detect transitions in the request.
      req_synced_q1 <= req_synced;
    end
  end

  // Output assignments.
  assign valid_o = (ack_dst_q != req_synced_q1);
  assign data_o = data_dst_q;
  assign async_ack_o = ack_dst_q;

endmodule
/* verilator lint_on DECLFILENAME */
",cdc_2phase_clearable.sv.txt,common_cells\cdc_2phase_clearable.sv.txt
"[Keyword]: cdc_4phase.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements a 4-phase clock domain crossing (CDC) mechanism. This is used to safely transfer data between two different clock domains. The 4-phase protocol is less efficient than a 2-phase protocol but is more robust during one-sided resets, as it maintains an IDLE state that does not alternate with every transaction. The design includes options for decoupling and sending reset messages during asynchronous resets.

[Input Signal Description]:
- `src_rst_ni`: Active-low reset signal for the source domain.
- `src_clk_i`: Clock signal for the source domain.
- `src_data_i`: Data input from the source domain.
- `src_valid_i`: Valid signal indicating that the source data is ready to be sent.
- `dst_rst_ni`: Active-low reset signal for the destination domain.
- `dst_clk_i`: Clock signal for the destination domain.
- `dst_ready_i`: Ready signal from the destination domain indicating it can accept data.

[Output Signal Description]:
- `src_ready_o`: Ready signal indicating the source can send data.
- `dst_data_o`: Data output to the destination domain.
- `dst_valid_o`: Valid signal indicating that the data output to the destination is valid.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Manuel Eggimann <meggimann@iis.ee.ethz.ch>

/// A 4-phase clock domain crossing. While this is less efficient than a 2-phase
/// CDC, it doesn't suffer from the same issues during one sided resets since
/// the IDLE state doesn't alternate with every transaction.
///
/// Parameters: T - The type of the data to transmit through the CDC.
///
/// Decoupled - If decoupled is disabled, the 4phase cdc will not consume the
/// src item until the handshake with the other side is completed. This
/// increases the latency of the first transaction but has no effect on
/// throughput. However, critical paths might be slightly longer. Use this mode
/// if you want to ensure that there are no in-flight transactions within the
/// CDC.
///
/// SEND_RESET_MSG - If send reset msg is enabled, the 4phase cdc starts sending
/// the RESET_MSG within its' asynchronous reset state. This can be usefull if
/// we need to transmit a message to the other side of the CDC immediately
/// during an async reset even if there is no clock available. This mode is
/// required for proper functionality of the cdc_reset_ctrlr module.
///
/// CONSTRAINT: Requires max_delay of min_period(src_clk_i, dst_clk_i) through
/// the paths async_req, async_ack, async_data.
/* verilator lint_off DECLFILENAME */
module cdc_4phase #(
  parameter type T = logic,
  parameter bit DECOUPLED = 1'b1,
  parameter bit SEND_RESET_MSG = 1'b0,
  parameter T RESET_MSG = T'('0)
)(
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i
);

  // Asynchronous handshake signals.
  (* dont_touch = ""true"" *) logic async_req;
  (* dont_touch = ""true"" *) logic async_ack;
  (* dont_touch = ""true"" *) T async_data;

  // The sender in the source domain.
  cdc_4phase_src #(
    .T(T),
    .DECOUPLED(DECOUPLED),
    .SEND_RESET_MSG(SEND_RESET_MSG),
    .RESET_MSG(RESET_MSG)
  ) i_src (
    .rst_ni       ( src_rst_ni  ),
    .clk_i        ( src_clk_i   ),
    .data_i       ( src_data_i  ),
    .valid_i      ( src_valid_i ),
    .ready_o      ( src_ready_o ),
    .async_req_o  ( async_req   ),
    .async_ack_i  ( async_ack   ),
    .async_data_o ( async_data  )
  );

  // The receiver in the destination domain.
  cdc_4phase_dst #(.T(T), .DECOUPLED(DECOUPLED)) i_dst (
    .rst_ni       ( dst_rst_ni  ),
    .clk_i        ( dst_clk_i   ),
    .data_o       ( dst_data_o  ),
    .valid_o      ( dst_valid_o ),
    .ready_i      ( dst_ready_i ),
    .async_req_i  ( async_req   ),
    .async_ack_o  ( async_ack   ),
    .async_data_i ( async_data  )
  );
endmodule


/// Half of the 4-phase clock domain crossing located in the source domain.
module cdc_4phase_src #(
  parameter type T = logic,
  parameter int unsigned SYNC_STAGES = 2,
  parameter bit DECOUPLED = 1'b1,
  parameter bit SEND_RESET_MSG = 1'b0,
  parameter T RESET_MSG = T'('0)
)(
  input  logic rst_ni,
  input  logic clk_i,
  input  T     data_i,
  input  logic valid_i,
  output logic ready_o,
  output logic async_req_o,
  input  logic async_ack_i,
  output T     async_data_o
);

  (* dont_touch = ""true"" *)
  logic  req_src_d, req_src_q;
  (* dont_touch = ""true"" *)
  T data_src_d, data_src_q;
  (* dont_touch = ""true"" *)
  logic  ack_synced;

  typedef enum logic[1:0] {IDLE, WAIT_ACK_ASSERT, WAIT_ACK_DEASSERT} state_e;
  state_e state_d, state_q;

  // Synchronize the async ACK
  sync #(
    .STAGES(SYNC_STAGES)
  ) i_sync(
    .clk_i,
    .rst_ni,
    .serial_i( async_ack_i ),
    .serial_o( ack_synced  )
  );

  // FSM for the 4-phase handshake
  always_comb begin
    state_d    = state_q;
    req_src_d  = 1'b0;
    data_src_d = data_src_q;
    ready_o    = 1'b0;
    case (state_q)
      IDLE: begin
        // If decoupling is disabled, defer assertion of ready until the
        // handshake with the dst is completed
        if (DECOUPLED) begin
          ready_o = 1'b1;
        end else begin
          ready_o = 1'b0;
        end
        // Sample a new item when the valid signal is asserted.
        if (valid_i) begin
          data_src_d = data_i;
          req_src_d  = 1'b1;
          state_d = WAIT_ACK_ASSERT;
        end
      end
      WAIT_ACK_ASSERT: begin
        req_src_d = 1'b1;
        if (ack_synced == 1'b1) begin
          req_src_d = 1'b0;
          state_d   = WAIT_ACK_DEASSERT;
        end
      end
      WAIT_ACK_DEASSERT: begin
        if (ack_synced == 1'b0) begin
          state_d = IDLE;
          if (!DECOUPLED) begin
            ready_o = 1'b1;
          end
        end
      end
      default: begin
        state_d = IDLE;
      end
    endcase
  end

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      state_q <= IDLE;
    end else begin
      state_q <= state_d;
    end
  end

  // Sample the data and the request signal to filter combinational glitches
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      if (SEND_RESET_MSG) begin
        req_src_q  <= 1'b1;
        data_src_q <= RESET_MSG;
      end else begin
        req_src_q  <= 1'b0;
        data_src_q <= T'('0);
      end
    end else begin
      req_src_q  <= req_src_d;
      data_src_q <= data_src_d;
    end
  end

  // Async output assignments.
  assign async_req_o = req_src_q;
  assign async_data_o = data_src_q;

endmodule


/// Half of the 4-phase clock domain crossing located in the destination
/// domain.
module cdc_4phase_dst #(
  parameter type T = logic,
  parameter int unsigned SYNC_STAGES = 2,
  parameter bit DECOUPLED = 1
)(
  input  logic rst_ni,
  input  logic clk_i,
  output T     data_o,
  output logic valid_o,
  input  logic ready_i,
  input  logic async_req_i,
  output logic async_ack_o,
  input  T     async_data_i
);

  (* dont_touch = ""true"" *)
  logic  ack_dst_d, ack_dst_q;
  (* dont_touch = ""true"" *)
  logic  req_synced;

  logic  data_valid;

  logic  output_ready;


  typedef enum logic[1:0] {IDLE, WAIT_DOWNSTREAM_ACK, WAIT_REQ_DEASSERT} state_e;
  state_e state_d, state_q;

  //Synchronize the request
  sync #(
    .STAGES(SYNC_STAGES)
  ) i_sync(
    .clk_i,
    .rst_ni,
    .serial_i( async_req_i ),
    .serial_o( req_synced  )
  );

  // FSM for the 4-phase handshake
  always_comb begin
    state_d    = state_q;
    data_valid = 1'b0;
    ack_dst_d  = 1'b0;

    case (state_q)
      IDLE: begin
        // Sample the data upon a new request and transition to the next state
        if (req_synced == 1'b1) begin
          data_valid = 1'b1;
          if (output_ready == 1'b1) begin
            state_d = WAIT_REQ_DEASSERT;
          end else begin
            state_d = WAIT_DOWNSTREAM_ACK;
          end
        end
      end

      WAIT_DOWNSTREAM_ACK: begin
        data_valid       = 1'b1;
        if (output_ready == 1'b1) begin
          state_d    = WAIT_REQ_DEASSERT;
          ack_dst_d  = 1'b1;
        end
      end

      WAIT_REQ_DEASSERT: begin
        ack_dst_d = 1'b1;
        if (req_synced == 1'b0) begin
          ack_dst_d = 1'b0;
          state_d   = IDLE;
        end
      end

      default: begin
        state_d = IDLE;
      end
    endcase
  end

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      state_q <= IDLE;
    end else begin
      state_q <= state_d;
    end
  end

  // Filter glitches on ack signal before sending it through the asynchronous channel
  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      ack_dst_q <= 1'b0;
    end else begin
      ack_dst_q <= ack_dst_d;
    end
  end

  if (DECOUPLED) begin : gen_decoupled
    // Decouple the output from the asynchronous data bus without introducing
    // additional latency by inserting a spill register
    spill_register #(
      .T(T),
      .Bypass(1'b0)
    ) i_spill_register (
      .clk_i,
      .rst_ni,
      .valid_i(data_valid),
      .ready_o(output_ready),
      .data_i(async_data_i),
      .valid_o,
      .ready_i,
      .data_o
    );
  end else begin : gen_not_decoupled
    assign valid_o      = data_valid;
    assign output_ready = ready_i;
    assign data_o       = async_data_i;
  end

  // Output assignments.
  assign async_ack_o = ack_dst_q;

endmodule
/* verilator lint_on DECLFILENAME */
",cdc_4phase.sv.txt,common_cells\cdc_4phase.sv.txt
"[Keyword]: cdc_fifo_2phase.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a clock domain crossing (CDC) FIFO using 2-phase handshakes. It allows data to be transferred between two separate clock domains, ensuring data integrity and synchronization. The FIFO's depth is a power of two, determined by the parameter `LOG_DEPTH`. It is designed to handle asynchronous reset assertion and synchronous de-assertion for both clock domains.

[Input Signal Description]:
- `src_rst_ni`: Active-low reset signal for the source clock domain.
- `src_clk_i`: Clock signal for the source domain.
- `src_data_i`: Data input for the source domain.
- `src_valid_i`: Valid signal indicating that the source data is ready to be written to the FIFO.
- `dst_rst_ni`: Active-low reset signal for the destination clock domain.
- `dst_clk_i`: Clock signal for the destination domain.
- `dst_ready_i`: Ready signal indicating that the destination is ready to accept data from the FIFO.

[Output Signal Description]:
- `src_ready_o`: Ready signal indicating that the FIFO can accept more data from the source.
- `dst_data_o`: Data output for the destination domain.
- `dst_valid_o`: Valid signal indicating that the data output is valid and ready to be read by the destination.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

/// A clock domain crossing FIFO, using 2-phase hand shakes.
///
/// This FIFO has its push and pop ports in two separate clock domains. Its size
/// can only be powers of two, which is why its depth is given as 2**LOG_DEPTH.
/// LOG_DEPTH must be at least 1.
///
/// # Reset Behavior!!
///
/// This module must not be used if warm reset capabily is a requirement. The
/// only execption is if you consistently use a reset controller that sequences
/// the resets while gating both clock domains (be very careful if you follow
/// this strategy!).
///
/// After this disclaimer, here is how you connect the src_rst_ni and the
/// dst_rst_ni of this module for power-on-reset (POR). The src_rst_ni and
/// dst_rst_ni signal must be asserted SIMULTANEOUSLY (i.e. asynchronous
/// assertion). Othwerwise, spurious transactions could occur in the domain
/// where the reset arrives later than the other. The de-assertion of both reset
/// must be synchronized to their respective clock domain (i.e. src_rst_ni must
/// be deasserted synchronously to the src_clk_i and dst_rst_ni must be
/// deasserted synchronously to dst_clk_i.) You can use the rstgen cell in the
/// common_cells library to achieve this (synchronization of only the
/// de-assertion). However, be careful about reset domain crossings; If you
/// reset both domain asynchronously in their entirety (i.e. POR) you are fine.
/// However, if you use this strategy for warm resets (some parts of the circuit
/// are not reset) you might introduce metastability in this separate
/// reset-domain when you assert the reset (the deassertion synchronizer doen't
/// help here).
///
/// CONSTRAINT: See the constraints for `cdc_2phase`. An additional maximum
/// delay path needs to be specified from fifo_data_q to dst_data_o.
module cdc_fifo_2phase #(
  /// The data type of the payload transported by the FIFO.
  parameter type T = logic,
  /// The FIFO's depth given as 2**LOG_DEPTH.
  parameter int LOG_DEPTH = 3
)(
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i
);

  // Check the invariants.
  `ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(log_depth_0, LOG_DEPTH > 0)
  `endif

  localparam int PtrWidth = LOG_DEPTH+1;
  typedef logic [PtrWidth-1:0] pointer_t;
  typedef logic [LOG_DEPTH-1:0] index_t;

  localparam pointer_t PtrFull  = (1 << LOG_DEPTH);
  localparam pointer_t PtrEmpty = '0;

  // Allocate the registers for the FIFO memory with its separate write and read
  // ports. The FIFO has the following ports:
  //
  // - write: fifo_widx, fifo_wdata, fifo_write, src_clk_i
  // - read: fifo_ridx, fifo_rdata
  index_t fifo_widx, fifo_ridx;
  logic fifo_write;
  T fifo_wdata, fifo_rdata;
  T fifo_data_q [2**LOG_DEPTH];

  assign fifo_rdata = fifo_data_q[fifo_ridx];

  for (genvar i = 0; i < 2**LOG_DEPTH; i++) begin : g_word
    always_ff @(posedge src_clk_i, negedge src_rst_ni) begin
      if (!src_rst_ni)
        fifo_data_q[i] <= T'('0);
      else if (fifo_write && fifo_widx == i)
        fifo_data_q[i] <= fifo_wdata;
    end
  end

  // Allocate the read and write pointers in the source and destination domain.
  pointer_t src_wptr_q, dst_wptr, src_rptr, dst_rptr_q;

  always_ff @(posedge src_clk_i, negedge src_rst_ni) begin
    if (!src_rst_ni)
      src_wptr_q <= 0;
    else if (src_valid_i && src_ready_o)
      src_wptr_q <= src_wptr_q + 1;
  end

  always_ff @(posedge dst_clk_i, negedge dst_rst_ni) begin
    if (!dst_rst_ni)
      dst_rptr_q <= 0;
    else if (dst_valid_o && dst_ready_i)
      dst_rptr_q <= dst_rptr_q + 1;
  end

  // The pointers into the FIFO are one bit wider than the actual address into
  // the FIFO. This makes detecting critical states very simple: if all but the
  // topmost bit of rptr and wptr agree, the FIFO is in a critical state. If the
  // topmost bit is equal, the FIFO is empty, otherwise it is full.
  assign src_ready_o = ((src_wptr_q ^ src_rptr) != PtrFull);
  assign dst_valid_o = ((dst_rptr_q ^ dst_wptr) != PtrEmpty);

  // Transport the read and write pointers across the clock domain boundary.
  cdc_2phase #( .T(pointer_t) ) i_cdc_wptr (
    .src_rst_ni  ( src_rst_ni ),
    .src_clk_i   ( src_clk_i  ),
    .src_data_i  ( src_wptr_q ),
    .src_valid_i ( 1'b1       ),
    .src_ready_o (            ),
    .dst_rst_ni  ( dst_rst_ni ),
    .dst_clk_i   ( dst_clk_i  ),
    .dst_data_o  ( dst_wptr   ),
    .dst_valid_o (            ),
    .dst_ready_i ( 1'b1       )
  );

  cdc_2phase #( .T(pointer_t) ) i_cdc_rptr (
    .src_rst_ni  ( dst_rst_ni ),
    .src_clk_i   ( dst_clk_i  ),
    .src_data_i  ( dst_rptr_q ),
    .src_valid_i ( 1'b1       ),
    .src_ready_o (            ),
    .dst_rst_ni  ( src_rst_ni ),
    .dst_clk_i   ( src_clk_i  ),
    .dst_data_o  ( src_rptr   ),
    .dst_valid_o (            ),
    .dst_ready_i ( 1'b1       )
  );

  // Drive the FIFO write and read ports.
  assign fifo_widx  = src_wptr_q;
  assign fifo_wdata = src_data_i;
  assign fifo_write = src_valid_i && src_ready_o;
  assign fifo_ridx  = dst_rptr_q;
  assign dst_data_o = fifo_rdata;

endmodule
",cdc_fifo_2phase.sv.txt,common_cells\cdc_fifo_2phase.sv.txt
"[Keyword]: cdc_fifo_gray.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a clock domain crossing (CDC) FIFO using gray counters. It facilitates the transfer of data between two clock domains by storing the data in a FIFO buffer. The design ensures safe data transfer across clock domains by using gray-coded read and write pointers, which minimize the risk of metastability by ensuring only one bit changes at a time. The FIFO is split into two parts, each operating in its respective clock domain, with synchronization achieved through multi-stage flip-flop synchronizers.

[Input Signal Description]:
- `src_rst_ni`: Active-low reset signal for the source clock domain.
- `src_clk_i`: Clock signal for the source clock domain.
- `src_data_i`: Data input for the source clock domain.
- `src_valid_i`: Valid signal indicating that the source data is ready to be written to the FIFO.
- `dst_rst_ni`: Active-low reset signal for the destination clock domain.
- `dst_clk_i`: Clock signal for the destination clock domain.
- `dst_ready_i`: Ready signal indicating that the destination is ready to accept data from the FIFO.

[Output Signal Description]:
- `src_ready_o`: Ready signal indicating that the FIFO is ready to accept data from the source.
- `dst_data_o`: Data output for the destination clock domain.
- `dst_valid_o`: Valid signal indicating that the data output is valid and ready to be read by the destination.


[Design Detail]:
// Copyright 2018-2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>

/// A clock domain crossing FIFO, using gray counters.
///
/// # Architecture
///
/// The design is split into two parts, each one being clocked and reset
/// separately.
/// 1. The data to be transferred  over the clock domain boundary is
///    is stored in a FIFO. The corresponding write pointer is managed
///    (incremented) in the source clock domain.
/// 2. The entire FIFO content is exposed over the `async_data` port.
///    The destination clock domain increments its read pointer
///    in its destination clock domain.
///
/// Read and write pointers are then gray coded, communicated
/// and synchronized using a classic multi-stage FF synchronizer
/// in the other clock domain. The gray coding ensures that only
/// one bit changes at each pointer increment, preventing the
/// synchronizer to accidentally latch an inconsistent state
/// on a multi-bit bus.
///
/// The not full signal e.g. `src_ready_o` (on the sending side)
/// is generated using the local write pointer and the pessimistic
/// read pointer from the destination clock domain (pessimistic
/// because it is delayed at least two cycles because of the synchronizer
/// stages). This prevents the FIFO from overflowing.
///
/// The not empty signal e.g. `dst_valid_o` is generated using
/// the pessimistic write pointer and the local read pointer in
/// the destination clock domain. This means the FIFO content
/// does not need to be synchronized as we are sure we are reading
/// data which has been written at least two cycles earlier.
/// Furthermore, the read select logic into the FIFO is completely
/// clocked by the destination clock domain which avoids
/// inefficient data synchronization.
///
/// The FIFO size must be powers of two, which is why its depth is
/// given as 2**LOG_DEPTH. LOG_DEPTH must be at least 1.
///
/// # Reset Behavior!!
///
/// This module must not be used if warm reset capabily is a requirement. The
/// only execption is if you consistently use a reset controller that sequences
/// the resets while gating both clock domains (be very careful if you follow
/// this strategy!). If you need warm reset/clear/flush capabilities, use (AND
/// CAREFULLY READ THE DESCRIPTION) the cdc_fifo_gray_clearable module.
///
/// After this disclaimer, here is how you connect the src_rst_ni and the
/// dst_rst_ni of this module for power-on-reset (POR). The src_rst_ni and
/// dst_rst_ni signal must be asserted SIMULTANEOUSLY (i.e. asynchronous
/// assertion). Othwerwise, spurious transactions could occur in the domain
/// where the reset arrives later than the other. The de-assertion of both reset
/// must be synchronized to their respective clock domain (i.e. src_rst_ni must
/// be deasserted synchronously to the src_clk_i and dst_rst_ni must be
/// deasserted synchronously to dst_clk_i.) You can use the rstgen cell in the
/// common_cells library to achieve this (synchronization of only the
/// de-assertion). However be carefull about reset domain crossings; If you
/// reset both domain asynchronously in their entirety (i.e. POR) you are fine.
/// However, if you use this strategy for warm resets (some parts of the circuit
/// are not reset) you might introduce metastability in this separate
/// reset-domain when you assert the reset (the deassertion synchronizer doen't
/// help here).
///
/// # Constraints
///
/// We need to make sure that the propagation delay of the
/// data, read and write pointer is bound to the minimum of
/// either the sending or receiving clock period to prevent
/// an inconsistent state to be latched (if for example the one
/// bit of the read/write pointer have an excessive delay).
/// Furthermore, we should deactivate setup and hold checks on
/// the asynchronous signals.
///
/// ```
/// set_ungroup [get_designs cdc_fifo_gray*] false
/// set_boundary_optimization [get_designs cdc_fifo_gray*] false
/// set_max_delay min(T_src, T_dst) \
///     -through [get_pins -hierarchical -filter async] \
///     -through [get_pins -hierarchical -filter async]
/// set_false_path -hold \
///     -through [get_pins -hierarchical -filter async] \
///     -through [get_pins -hierarchical -filter async]
/// ```

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

(* no_ungroup *)
(* no_boundary_optimization *)
module cdc_fifo_gray #(
  /// The width of the default logic type.
  parameter int unsigned WIDTH = 1,
  /// The data type of the payload transported by the FIFO.
  parameter type T = logic [WIDTH-1:0],
  /// The FIFO's depth given as 2**LOG_DEPTH.
  parameter int LOG_DEPTH = 3,
  /// The number of synchronization registers to insert on the async pointers.
  parameter int SYNC_STAGES = 2
) (
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i
);

  T [2**LOG_DEPTH-1:0] async_data;
  logic [LOG_DEPTH:0]  async_wptr;
  logic [LOG_DEPTH:0]  async_rptr;

  cdc_fifo_gray_src #(
    .T         ( T         ),
    .LOG_DEPTH ( LOG_DEPTH )
  ) i_src (
    .src_rst_ni,
    .src_clk_i,
    .src_data_i,
    .src_valid_i,
    .src_ready_o,

    (* async *) .async_data_o ( async_data ),
    (* async *) .async_wptr_o ( async_wptr ),
    (* async *) .async_rptr_i ( async_rptr )
  );

  cdc_fifo_gray_dst #(
    .T         ( T         ),
    .LOG_DEPTH ( LOG_DEPTH )
  ) i_dst (
    .dst_rst_ni,
    .dst_clk_i,
    .dst_data_o,
    .dst_valid_o,
    .dst_ready_i,

    (* async *) .async_data_i ( async_data ),
    (* async *) .async_wptr_i ( async_wptr ),
    (* async *) .async_rptr_o ( async_rptr )
  );

  // Check the invariants.
  `ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(log_depth_0, LOG_DEPTH > 0)
  `ASSERT_INIT(sync_stages_gt_2, SYNC_STAGES >= 2)
  `endif

endmodule


(* no_ungroup *)
(* no_boundary_optimization *)
module cdc_fifo_gray_src #(
  parameter type T = logic,
  parameter int LOG_DEPTH = 3,
  parameter int SYNC_STAGES = 2
)(
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  output T [2**LOG_DEPTH-1:0] async_data_o,
  output logic [LOG_DEPTH:0]  async_wptr_o,
  input  logic [LOG_DEPTH:0]  async_rptr_i
);

  localparam int PtrWidth = LOG_DEPTH+1;
  localparam logic [PtrWidth-1:0] PtrFull = (1 << LOG_DEPTH);

  T [2**LOG_DEPTH-1:0] data_q;
  logic [PtrWidth-1:0] wptr_q, wptr_d, wptr_bin, wptr_next, rptr, rptr_bin;

  // Data FIFO.
  assign async_data_o = data_q;
  for (genvar i = 0; i < 2**LOG_DEPTH; i++) begin : gen_word
    `FFLNR(data_q[i], src_data_i,
          src_valid_i & src_ready_o & (wptr_bin[LOG_DEPTH-1:0] == i), src_clk_i)
  end

  // Read pointer.
  for (genvar i = 0; i < PtrWidth; i++) begin : gen_sync
    sync #(.STAGES(SYNC_STAGES)) i_sync (
      .clk_i    ( src_clk_i       ),
      .rst_ni   ( src_rst_ni      ),
      .serial_i ( async_rptr_i[i] ),
      .serial_o ( rptr[i]         )
    );
  end
  gray_to_binary #(PtrWidth) i_rptr_g2b (.A(rptr), .Z(rptr_bin));

  // Write pointer.
  assign wptr_next = wptr_bin+1;
  gray_to_binary #(PtrWidth) i_wptr_g2b (.A(wptr_q), .Z(wptr_bin));
  binary_to_gray #(PtrWidth) i_wptr_b2g (.A(wptr_next), .Z(wptr_d));
  `FFLARN(wptr_q, wptr_d, src_valid_i & src_ready_o, '0, src_clk_i, src_rst_ni)
  assign async_wptr_o = wptr_q;

  // The pointers into the FIFO are one bit wider than the actual address into
  // the FIFO. This makes detecting critical states very simple: if all but the
  // topmost bit of rptr and wptr agree, the FIFO is in a critical state. If the
  // topmost bit is equal, the FIFO is empty, otherwise it is full.
  assign src_ready_o = ((wptr_bin ^ rptr_bin) != PtrFull);

endmodule


(* no_ungroup *)
(* no_boundary_optimization *)
module cdc_fifo_gray_dst #(
  parameter type T = logic,
  parameter int LOG_DEPTH = 3,
  parameter int SYNC_STAGES = 2
)(
  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i,

  input  T [2**LOG_DEPTH-1:0] async_data_i,
  input  logic [LOG_DEPTH:0]  async_wptr_i,
  output logic [LOG_DEPTH:0]  async_rptr_o
);

  localparam int PtrWidth = LOG_DEPTH+1;
  localparam logic [PtrWidth-1:0] PtrEmpty = '0;

  T dst_data;
  logic [PtrWidth-1:0] rptr_q, rptr_d, rptr_bin, rptr_bin_d, rptr_next, wptr, wptr_bin;
  logic dst_valid, dst_ready;
  // Data selector and register.
  assign dst_data = async_data_i[rptr_bin[LOG_DEPTH-1:0]];

  // Read pointer.
  assign rptr_next = rptr_bin+1;
  gray_to_binary #(PtrWidth) i_rptr_g2b (.A(rptr_q), .Z(rptr_bin));
  binary_to_gray #(PtrWidth) i_rptr_b2g (.A(rptr_next), .Z(rptr_d));
  `FFLARN(rptr_q, rptr_d, dst_valid & dst_ready, '0, dst_clk_i, dst_rst_ni)
  assign async_rptr_o = rptr_q;

  // Write pointer.
  for (genvar i = 0; i < PtrWidth; i++) begin : gen_sync
    sync #(.STAGES(SYNC_STAGES)) i_sync (
      .clk_i    ( dst_clk_i       ),
      .rst_ni   ( dst_rst_ni      ),
      .serial_i ( async_wptr_i[i] ),
      .serial_o ( wptr[i]         )
    );
  end
  gray_to_binary #(PtrWidth) i_wptr_g2b (.A(wptr), .Z(wptr_bin));

  // The pointers into the FIFO are one bit wider than the actual address into
  // the FIFO. This makes detecting critical states very simple: if all but the
  // topmost bit of rptr and wptr agree, the FIFO is in a critical state. If the
  // topmost bit is equal, the FIFO is empty, otherwise it is full.
  assign dst_valid = ((wptr_bin ^ rptr_bin) != PtrEmpty);

  // Cut the combinatorial path with a spill register.
  spill_register #(
    .T       ( T           )
  ) i_spill_register (
    .clk_i   ( dst_clk_i   ),
    .rst_ni  ( dst_rst_ni  ),
    .valid_i ( dst_valid   ),
    .ready_o ( dst_ready   ),
    .data_i  ( dst_data    ),
    .valid_o ( dst_valid_o ),
    .ready_i ( dst_ready_i ),
    .data_o  ( dst_data_o  )
  );

endmodule
",cdc_fifo_gray.sv.txt,common_cells\cdc_fifo_gray.sv.txt
"[Keyword]: cdc_fifo_gray_clearable.sv

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a clock domain crossing (CDC) FIFO with gray-coded pointers and clearability features. It is used to safely transfer data between two different clock domains. The FIFO ensures data integrity by using gray coding for pointers, which minimizes the risk of capturing inconsistent states during synchronization. The design also supports asynchronous and synchronous reset capabilities, allowing for one-sided warm resets without causing spurious transactions.

[Input Signal Description]:
- `src_rst_ni`: Active-low reset signal for the source clock domain.
- `src_clk_i`: Clock signal for the source clock domain.
- `src_clear_i`: Clear signal for the source clock domain, used to initiate a reset sequence.
- `src_data_i`: Data input for the source clock domain.
- `src_valid_i`: Valid signal indicating that the source data is ready to be written to the FIFO.
- `dst_rst_ni`: Active-low reset signal for the destination clock domain.
- `dst_clk_i`: Clock signal for the destination clock domain.
- `dst_clear_i`: Clear signal for the destination clock domain, used to initiate a reset sequence.
- `dst_ready_i`: Ready signal indicating that the destination is ready to accept data.

[Output Signal Description]:
- `src_clear_pending_o`: Indicates if a clear operation is pending in the source clock domain.
- `src_ready_o`: Indicates if the FIFO is ready to accept new data from the source.
- `dst_clear_pending_o`: Indicates if a clear operation is pending in the destination clock domain.
- `dst_data_o`: Data output for the destination clock domain.
- `dst_valid_o`: Valid signal indicating that the data output is valid and ready to be read by the destination.


[Design Detail]:
// Copyright 2018-2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Manuel Eggimann <meggimann@iis.ee.ethz.ch> (clearability feature)

/// A clock domain crossing FIFO, using gray counters.
///
/// # Architecture
///
/// The design is split into two parts, each one being clocked and reset
/// separately.
/// 1. The data to be transferred  over the clock domain boundary is
///    is stored in a FIFO. The corresponding write pointer is managed
///    (incremented) in the source clock domain.
/// 2. The entire FIFO content is exposed over the `async_data` port.
///    The destination clock domain increments its read pointer
///    in its destination clock domain.
///
/// Read and write pointers are then gray coded, communicated
/// and synchronized using a classic multi-stage FF synchronizer
/// in the other clock domain. The gray coding ensures that only
/// one bit changes at each pointer increment, preventing the
/// synchronizer to accidentally latch an inconsistent state
/// on a multi-bit bus.
///
/// The not full signal e.g. `src_ready_o` (on the sending side)
/// is generated using the local write pointer and the pessimistic
/// read pointer from the destination clock domain (pessimistic
/// because it is delayed at least two cycles because of the synchronizer
/// stages). This prevents the FIFO from overflowing.
///
/// The not empty signal e.g. `dst_valid_o` is generated using
/// the pessimistic write pointer and the local read pointer in
/// the destination clock domain. This means the FIFO content
/// does not need to be synchronized as we are sure we are reading
/// data which has been written at least two cycles earlier.
/// Furthermore, the read select logic into the FIFO is completely
/// clocked by the destination clock domain which avoids
/// inefficient data synchronization.
///
/// The FIFO size must be powers of two, which is why its depth is
/// given as 2**LOG_DEPTH. LOG_DEPTH must be at least 1.

/// Reset Behavior:
///
/// In contrast to the cdc_fifo_gray version without clear signal, this module
/// supports one-sided warm resets (asynchronously and synchronously). The way
/// this is implemented is described in more detail in the cdc_reset_ctrlr
/// module. To summarize a synchronous clear request i.e. src/dst_clear_i will
/// cause the respective other clock domain to reset as well without introducing
/// any spurious transactions. This is acomplished by an internal module
/// (cdc_reset_ctrlr) the starts a reset sequence on both sides of the CDC in
/// lock-step that first isolates the CDC from the outside world and then resets
/// it. The reset sequencer provides the following behavior:
/// 1. There are no spurious invalid or duplicated transactions regardless how
///    the individual sides are reset (can also happen roughly simultaneosly)
/// 2. The FIFO becomes unready at the src side in the next cycle after
///    synchronous reset request until the reset sequence is completed. Some of
///    the pending transactions might still complete (if the dst accepts at the
///    exact time the reset is request on the src die), some of them will be
///    dropped (of course still guaranteeing FIFO order).
/// 3. During the reset sequence the dst might withdraw the valid signal. This
///    might violate higher level protocols. If you need this feature you would
///    have to path the existing implementation to wait with the isolate_ack
///    assertion until all open handshakes were acknowledged.
/// 4. If the parameter CLEAR_ON_ASYNC_RESET is enabled, the same behavior as
///    above is also valid for asynchronous resets on either side. However, this
///    increases the minimum number of synchronization stages (SYNC_STAGES
///    parameter) from 2 to 3 (read the cdc_reset_ctrlr header to figure out
///    why).
///
///
/// # Constraints
///
/// We need to make sure that the propagation delay of the data, read and write
/// pointer is bound to the minimum of either the sending or receiving clock
/// period to prevent an inconsistent state to be latched (if for example the
/// one bit of the read/write pointer have an excessive delay). Furthermore, we
/// should deactivate setup and hold checks on the asynchronous signals.
///
/// ``` set_ungroup [get_designs cdc_fifo_gray*] false set_boundary_optimization
/// [get_designs cdc_fifo_gray*] false set_max_delay min(T_src, T_dst) \
/// -through [get_pins -hierarchical -filter async] \ -through [get_pins
/// -hierarchical -filter async] set_false_path -hold \ -through [get_pins
/// -hierarchical -filter async] \ -through [get_pins -hierarchical -filter
/// async] ```

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

(* no_ungroup *)
(* no_boundary_optimization *)
module cdc_fifo_gray_clearable #(
  /// The width of the default logic type.
  parameter int unsigned WIDTH = 1,
  /// The data type of the payload transported by the FIFO.
  parameter type T = logic [WIDTH-1:0],
  /// The FIFO's depth given as 2**LOG_DEPTH.
  parameter int LOG_DEPTH = 3,
  /// The number of synchronization registers to insert on the async pointers
  /// between the FIFOs. If CLEAR_ON_ASYNC reset is enabled, we need at least 4
  /// synchronizer stages to provide the clear synchronizer lower latency than
  /// the async reset. I.e. if CLEAR_ON_ASYNC_RESET==1 -> SYNC_STAGES >= 4 else
  /// SYNC_STAGES >= 2.
  parameter int SYNC_STAGES = 3,
  parameter int CLEAR_ON_ASYNC_RESET = 1
) (
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  logic src_clear_i,
  output logic src_clear_pending_o,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  input  logic dst_clear_i,
  output logic dst_clear_pending_o,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i
);

  logic        s_src_clear_req;
  logic        s_src_clear_ack_q;
  logic        s_src_ready;
  logic        s_src_isolate_req;
  logic        s_src_isolate_ack_q;
  logic        s_dst_clear_req;
  logic        s_dst_clear_ack_q;
  logic        s_dst_valid;
  logic        s_dst_isolate_req;
  logic        s_dst_isolate_ack_q;


  T [2**LOG_DEPTH-1:0] async_data;
  logic [LOG_DEPTH:0]  async_wptr;
  logic [LOG_DEPTH:0]  async_rptr;

  if (CLEAR_ON_ASYNC_RESET) begin : gen_elaboration_assertion
    if (SYNC_STAGES < 3)
      $error(""The clearable CDC FIFO with async reset synchronization requires at least"",
             ""3 synchronizer stages for the FIFO."");
  end else begin : gen_elaboration_assertion
    if (SYNC_STAGES < 2) begin : gen_elaboration_assertion
      $error(""A minimum of 2 synchronizer stages is required for proper functionality."");
    end
  end

  if (2*SYNC_STAGES > 2**LOG_DEPTH) begin : gen_elaboration_assertion2
    $warning(""The FIFOs depth of %0d is insufficient to completely hide the latency of"",
             "" %0d SYNC_STAGES. The FIFO will stall in the case where f_src ~= f_dst. "",
             ""It is reccomended to increase the FIFO's log depth to at least %0d."",
             2**LOG_DEPTH, SYNC_STAGES, $clog2(2*SYNC_STAGES));
  end



  cdc_fifo_gray_src_clearable #(
    .T           ( T           ),
    .LOG_DEPTH   ( LOG_DEPTH   ),
    .SYNC_STAGES ( SYNC_STAGES )
  ) i_src (
    .src_rst_ni,
    .src_clk_i,
    .src_clear_i ( s_src_clear_req                  ),
    .src_data_i,
    .src_valid_i ( src_valid_i & !s_src_isolate_req ),
    .src_ready_o ( s_src_ready                      ),

    (* async *) .async_data_o ( async_data ),
    (* async *) .async_wptr_o ( async_wptr ),
    (* async *) .async_rptr_i ( async_rptr )
  );

  assign src_ready_o = s_src_ready & !s_src_isolate_req;

  cdc_fifo_gray_dst_clearable #(
    .T           ( T           ),
    .LOG_DEPTH   ( LOG_DEPTH   ),
    .SYNC_STAGES ( SYNC_STAGES )
  ) i_dst (
    .dst_rst_ni,
    .dst_clk_i,
    .dst_clear_i ( s_dst_clear_req                  ),
    .dst_data_o,
    .dst_valid_o ( s_dst_valid                      ),
    .dst_ready_i ( dst_ready_i & !s_dst_isolate_req ),

    (* async *) .async_data_i ( async_data ),
    (* async *) .async_wptr_i ( async_wptr ),
    (* async *) .async_rptr_o ( async_rptr )
  );

  assign dst_valid_o = s_dst_valid & !s_dst_isolate_req;

  // Synchronize the clear and reset signaling in both directions (see header of
  // the cdc_reset_ctrlr module for more details.)
  cdc_reset_ctrlr #(
    .SYNC_STAGES(SYNC_STAGES-1)
  ) i_cdc_reset_ctrlr (
    .a_clk_i         ( src_clk_i           ),
    .a_rst_ni        ( src_rst_ni          ),
    .a_clear_i       ( src_clear_i         ),
    .a_clear_o       ( s_src_clear_req     ),
    .a_clear_ack_i   ( s_src_clear_ack_q   ),
    .a_isolate_o     ( s_src_isolate_req   ),
    .a_isolate_ack_i ( s_src_isolate_ack_q ),
    .b_clk_i         ( dst_clk_i           ),
    .b_rst_ni        ( dst_rst_ni          ),
    .b_clear_i       ( dst_clear_i         ),
    .b_clear_o       ( s_dst_clear_req     ),
    .b_clear_ack_i   ( s_dst_clear_ack_q   ),
    .b_isolate_o     ( s_dst_isolate_req   ),
    .b_isolate_ack_i ( s_dst_isolate_ack_q )
  );

  // Just delay the isolate request by one cycle. We can ensure isolation within
  // one cycle by just deasserting valid and ready signals on both sides of the CDC.
  always_ff @(posedge src_clk_i, negedge src_rst_ni) begin
    if (!src_rst_ni) begin
      s_src_isolate_ack_q <= 1'b0;
      s_src_clear_ack_q   <= 1'b0;
    end else begin
      s_src_isolate_ack_q <= s_src_isolate_req;
      s_src_clear_ack_q   <= s_src_clear_req;
    end
  end

  always_ff @(posedge dst_clk_i, negedge dst_rst_ni) begin
    if (!dst_rst_ni) begin
      s_dst_isolate_ack_q <= 1'b0;
      s_dst_clear_ack_q   <= 1'b0;
    end else begin
      s_dst_isolate_ack_q <= s_dst_isolate_req;
      s_dst_clear_ack_q   <= s_dst_clear_req;
    end
  end


  assign src_clear_pending_o = s_src_isolate_req; // The isolate signal stays
                                                  // asserted during the whole
                                                  // clear sequence.
  assign dst_clear_pending_o = s_dst_isolate_req;

  // Check the invariants.
  `ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(log_depth_0, LOG_DEPTH > 0)
  `ASSERT_INIT(sync_stages_lt_2, SYNC_STAGES >= 2)
  `endif

endmodule


(* no_ungroup *)
(* no_boundary_optimization *)
module cdc_fifo_gray_src_clearable #(
  parameter type T = logic,
  parameter int LOG_DEPTH = 3,
  parameter int SYNC_STAGES = 2
)(
  input  logic src_rst_ni,
  input  logic src_clk_i,
  input  logic src_clear_i,
  input  T     src_data_i,
  input  logic src_valid_i,
  output logic src_ready_o,

  output T [2**LOG_DEPTH-1:0] async_data_o,
  output logic [LOG_DEPTH:0]  async_wptr_o,
  input  logic [LOG_DEPTH:0]  async_rptr_i
);

  localparam int PtrWidth = LOG_DEPTH+1;
  localparam logic [PtrWidth-1:0] PtrFull = (1 << LOG_DEPTH);

  T [2**LOG_DEPTH-1:0] data_q;
  logic [PtrWidth-1:0] wptr_q, wptr_d, wptr_bin, wptr_next, rptr, rptr_bin;

  // Data FIFO.
  assign async_data_o = data_q;
  for (genvar i = 0; i < 2**LOG_DEPTH; i++) begin : gen_word
    `FFLNR(data_q[i], src_data_i,
          src_valid_i & src_ready_o & (wptr_bin[LOG_DEPTH-1:0] == i), src_clk_i)
  end

  // Read pointer.
  for (genvar i = 0; i < PtrWidth; i++) begin : gen_sync
    sync #(.STAGES(SYNC_STAGES)) i_sync (
      .clk_i    ( src_clk_i       ),
      .rst_ni   ( src_rst_ni      ),
      .serial_i ( async_rptr_i[i] ),
      .serial_o ( rptr[i]         )
    );
  end
  gray_to_binary #(PtrWidth) i_rptr_g2b (.A(rptr), .Z(rptr_bin));

  // Write pointer.
  assign wptr_next = wptr_bin+1;
  gray_to_binary #(PtrWidth) i_wptr_g2b (.A(wptr_q), .Z(wptr_bin));
  binary_to_gray #(PtrWidth) i_wptr_b2g (.A(wptr_next), .Z(wptr_d));
  `FFLARNC(wptr_q, wptr_d, src_valid_i & src_ready_o, src_clear_i, '0, src_clk_i, src_rst_ni)
  assign async_wptr_o = wptr_q;

  // The pointers into the FIFO are one bit wider than the actual address into
  // the FIFO. This makes detecting critical states very simple: if all but the
  // topmost bit of rptr and wptr agree, the FIFO is in a critical state. If the
  // topmost bit is equal, the FIFO is empty, otherwise it is full.
  assign src_ready_o = ((wptr_bin ^ rptr_bin) != PtrFull);

endmodule


(* no_ungroup *)
(* no_boundary_optimization *)
module cdc_fifo_gray_dst_clearable #(
  parameter type T = logic,
  parameter int LOG_DEPTH = 3,
  parameter int SYNC_STAGES = 2
)(
  input  logic dst_rst_ni,
  input  logic dst_clk_i,
  input  logic dst_clear_i,
  output T     dst_data_o,
  output logic dst_valid_o,
  input  logic dst_ready_i,

  input  T [2**LOG_DEPTH-1:0] async_data_i,
  input  logic [LOG_DEPTH:0]  async_wptr_i,
  output logic [LOG_DEPTH:0]  async_rptr_o
);

  localparam int PtrWidth = LOG_DEPTH+1;
  localparam logic [PtrWidth-1:0] PtrEmpty = '0;

  T dst_data;
  logic [PtrWidth-1:0] rptr_q, rptr_d, rptr_bin, rptr_next, wptr, wptr_bin;
  logic dst_valid, dst_ready;
  // Data selector and register.
  assign dst_data = async_data_i[rptr_bin[LOG_DEPTH-1:0]];

  // Read pointer.
  assign rptr_next = rptr_bin+1;
  gray_to_binary #(PtrWidth) i_rptr_g2b (.A(rptr_q), .Z(rptr_bin));
  binary_to_gray #(PtrWidth) i_rptr_b2g (.A(rptr_next), .Z(rptr_d));
  `FFLARNC(rptr_q, rptr_d, dst_valid & dst_ready, dst_clear_i, '0, dst_clk_i, dst_rst_ni)
  assign async_rptr_o = rptr_q;

  // Write pointer.
  for (genvar i = 0; i < PtrWidth; i++) begin : gen_sync
    sync #(.STAGES(SYNC_STAGES)) i_sync (
      .clk_i    ( dst_clk_i       ),
      .rst_ni   ( dst_rst_ni      ),
      .serial_i ( async_wptr_i[i] ),
      .serial_o ( wptr[i]         )
    );
  end
  gray_to_binary #(PtrWidth) i_wptr_g2b (.A(wptr), .Z(wptr_bin));

  // The pointers into the FIFO are one bit wider than the actual address into
  // the FIFO. This makes detecting critical states very simple: if all but the
  // topmost bit of rptr and wptr agree, the FIFO is in a critical state. If the
  // topmost bit is equal, the FIFO is empty, otherwise it is full.
  assign dst_valid = ((wptr_bin ^ rptr_bin) != PtrEmpty);

  // Cut the combinatorial path with a spill register.
  spill_register_flushable #(
    .T       ( T           )
  ) i_spill_register (
    .clk_i   ( dst_clk_i                ),
    .rst_ni  ( dst_rst_ni               ),
    .flush_i ( dst_clear_i              ),
    .valid_i ( dst_valid & !dst_clear_i ),
    .ready_o ( dst_ready                ),
    .data_i  ( dst_data                 ),
    .valid_o ( dst_valid_o              ),
    .ready_i ( dst_ready_i              ),
    .data_o  ( dst_data_o               )
  );

endmodule
",cdc_fifo_gray_clearable.sv.txt,common_cells\cdc_fifo_gray_clearable.sv.txt
"[Keyword]: cdc_reset_ctrlr.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design is a CDC (Clock Domain Crossing) clear signaling synchronization module. It ensures that clear requests are synchronized between two clock domains in a CDC module, preventing reset-domain-crossing issues and maintaining protocol integrity. The module uses a 4-phase handshaking mechanism to synchronize clear sequences between two sides ('a' and 'b'), ensuring that both sides are isolated and cleared in lock-step to avoid metastability and spurious transactions.

[Input Signal Description]:
- `a_clk_i`, `b_clk_i`: Clock inputs for side 'a' and side 'b'.
- `a_rst_ni`, `b_rst_ni`: Asynchronous reset inputs for side 'a' and side 'b'.
- `a_clear_i`, `b_clear_i`: Clear request inputs for side 'a' and side 'b'.
- `a_clear_ack_i`, `b_clear_ack_i`: Acknowledgment inputs for clear requests from external circuitry for side 'a' and side 'b'.
- `a_isolate_ack_i`, `b_isolate_ack_i`: Acknowledgment inputs for isolation requests from external circuitry for side 'a' and side 'b'.

[Output Signal Description]:
- `a_clear_o`, `b_clear_o`: Clear outputs for side 'a' and side 'b', indicating when the clear sequence is active.
- `a_isolate_o`, `b_isolate_o`: Isolation outputs for side 'a' and side 'b', indicating when the respective side should be isolated from external transactions.


[Design Detail]:
//-----------------------------------------------------------------------------
// Title : CDC Clear Signaling Synchronization
// -----------------------------------------------------------------------------
// File : cdc_clear_propagator.sv Author : Manuel Eggimann
// <meggimann@iis.ee.ethz.ch> Created : 22.12.2021
// -----------------------------------------------------------------------------
// Description :
//
// This module is mainly used internally to synchronize the clear requests
// between both sides of a CDC module. It aims to solve the problem of
// initiating a CDC clear, reset one-sidedly without running into
// reset-domain-crossing issues and breaking CDC protocol assumption.
//
// Problem Formulation:
//
// CDC implementations usually face the issue that one side of the CDC must not
// be cleared without clearing the other side. E.g. clearing the write-pointer
// without clearing the read-pointer in a gray-counting CDC FIFO results in an
// invalid fill-state an may cause spurious transactions of invalid data to be
// propagated accross the CDC. A similar effect is caused in 2-phase CDC
// implementations.
//
// A naive mitigation technique would be to reset both domains asynchronously
// with the same reset signal. This will cause intra-clock domain RDC issues
// since the asynchronous clear event (assertion of the reset signal) might
// happen close to the active edge of the CDC's periphery and thus might induce
// metastability. A better, but still flawed approach would be to naively
// synchronize assertion AND deassertion (the usual rst sync only synchronize
// deassertion) of the resets into the respective other domain. However, this
// might cause the classic issue of fast-to-slow clock domain crossing where the
// clear signal is not asserted long enough to be captured by the receiving
// side. The common mitigation strategy is to use a feedback acknowledge signal
// to handshake the reset request into the other domain. One even more peculiar
// corner case this approach might suffer is the scenario where the synchronized
// clear signal arrives at the other side of the CDC within or even worse after
// the same clock cylce that the other domain crossing signals (e.g. read/write
// pointers) are cleared. In this scenario, multiple signals change within the
// same clock cycle and due to metastability we cannot be sure, that the other
// side of the CDC sees the reset assertion before the first bits of e.g. the
// write/read pointer start to switch to their reset state. Care must also be
// taken to handle the corner cases where both sides are reset simultaneously or
// the case where one side leaves reset earlier than the other.
//
// How this Module Works
//
// This module has two interfaces, the 'a' side and the 'b' side. Each side can
// be triggered using the a/b_clear_i signal or (optionally) by the asynchronous
// a/b_rst_ni. Once e.g. 'a' is triggered it will initiate a clear sequence that
// first asserts an 'a_isolate_o' signal, waits until the external circuitry
// acknowledges isolation using the 'a_isolate_ack_i'. Then the module asserts
// the 'a_clear_o' signals before some cycles later, the isolate signal is
// deasserted. This sequence ensures that no transactions can arrive to the CDC
// while the state is cleared. Now the important part is, that those four phases
// (asser isolate, assert clear, deassert clear, deassert isolate) are mirrored
// on the other side ('b') in lock-step. The cdc_reset_ctrlr module uses a
// dedicated 4-phase handshaking CDC to transmit the current phase of the clear
// sequence to the other domain. We use a 4-phase rather than a 2-phase CDC to
// avoid the issues of one-sided async reset that might trigger spurious
// transactions. Furthermore, the 4-phase CDC within this module is operated in
// a special mode: DECOUPLED=0 ensures that there are no in-flight transactions.
// The src side only consumes the item once the destination side acknowledged
// the receiption. This property is required to transition through the phases in
// lock-step. Furthermore, (SEND_RESET_MSG=1) will cause the src side of the
// 4-phase CDC to immediately initiate the isolation phase in the dst domain
// upon asynchronous reset regardless how long the async reset stays asserted or
// whether the source clock is gated. Both sides of this module independently
// generate the sequence signals as an initiator (triggered by the clear_i or
// rst_ni signal) or receiver (trigerred for the other side). The or-ed version
// of initiator and receiver are used to generate the actual a/b_isolate_o and
// a/b_clear_o signal. That way, it doesn't matter wheter both sides
// simulatenously trigger a clear sequence, proper sequencing is still
// guaranteed.
//
// The time it takes to complete an entire clear sequence can be bounded as follows:
//
// t_clear <= 20*T+16*SYNC_STAGES*T, with T=max(T_a, T_b) (clock periods of src and dst)
//
// How to Use the Module
//
// Instantiate the module within your CDC and connect a/b_clk_i, the
// asyncrhonous a/b_rst_ni and the synchronous a/b_clear_i signals. The 'a' and
// 'b' port are entirely symetric so it doesn't matter whether you connect src
// to 'a' or 'b'. If you enable support for async reset
// (CLEAR_ON_ASYNC_RESET==1), parametrize the number of synchronization stages
// (for metastability resolution) to be strictly less than the latency of the
// CDC. E.g. if your CDC uses 3 (the minimum) sync stages, parametrize this
// module with SYNC_STAGES < 2! Your CDC must implement a src/dst_clear_i port
// that SYNCHRONOUSLY clears all FFs on the respective side. Connect the CDC's
// src/dst_clear ports to this module's a/b_clear_o port. Once the a/b_isolate_o
// signal is asserted, the respective CDC side (src/dst) must be isolated from
// the outside world (i.e. must no longer accept any transaction on the src side
// and cease presenting or even withdrawing data on the dst side). Once your CDC
// side is isolated (depending on protocol this might take several cycles),
// assert the a/b_isolate_ack_i signal.
//
// -----------------------------------------------------------------------------
// Copyright (C) 2021 ETH Zurich, University of Bologna Copyright and related
// rights are licensed under the Solderpad Hardware License, Version 0.51 (the
// ""License""); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law or
// agreed to in writing, software, hardware and materials distributed under this
// License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS
// OF ANY KIND, either express or implied. See the License for the specific
// language governing permissions and limitations under the License.
// SPDX-License-Identifier: SHL-0.51
// -----------------------------------------------------------------------------

module cdc_reset_ctrlr
  import cdc_reset_ctrlr_pkg::*;
 #(
  /// The number of synchronization stages to use for the
  /// clear signal request/acknowledge. Must be less than the
  /// number of sync stages used in the CDC.
  parameter int unsigned SYNC_STAGES = 2,
  /// Whether an asynchronous reset shall cause a clear
  /// request to be sent to the other side.
  parameter logic        CLEAR_ON_ASYNC_RESET = 1'b1
)(
  // Side A (both sides are symmetric)
  input logic  a_clk_i,
  input logic  a_rst_ni,
  input logic  a_clear_i,
  output logic a_clear_o,
  input logic a_clear_ack_i,
  output logic a_isolate_o,
  input logic  a_isolate_ack_i,
  // Side B (both sides are symmetric)
  input logic  b_clk_i,
  input logic  b_rst_ni,
  input logic  b_clear_i,
  output logic b_clear_o,
  input logic  b_clear_ack_i,
  output logic b_isolate_o,
  input logic  b_isolate_ack_i
);

  (* dont_touch = ""true"" *)
  logic        async_a2b_req, async_b2a_ack;
  (* dont_touch = ""true"" *)
  clear_seq_phase_e async_a2b_next_phase;
  (* dont_touch = ""true"" *)
  logic        async_b2a_req, async_a2b_ack;
  (* dont_touch = ""true"" *)
  clear_seq_phase_e async_b2a_next_phase;

  cdc_reset_ctrlr_half #(
    .SYNC_STAGES          ( SYNC_STAGES          ),
    .CLEAR_ON_ASYNC_RESET ( CLEAR_ON_ASYNC_RESET )
  ) i_cdc_reset_ctrlr_half_a (
    .clk_i              ( a_clk_i              ),
    .rst_ni             ( a_rst_ni             ),
    .clear_i            ( a_clear_i            ),
    .clear_o            ( a_clear_o            ),
    .clear_ack_i        ( a_clear_ack_i        ),
    .isolate_o          ( a_isolate_o          ),
    .isolate_ack_i      ( a_isolate_ack_i      ),
    (* async *) .async_next_phase_o ( async_a2b_next_phase ),
    (* async *) .async_req_o        ( async_a2b_req        ),
    (* async *) .async_ack_i        ( async_b2a_ack        ),
    (* async *) .async_next_phase_i ( async_b2a_next_phase ),
    (* async *) .async_req_i        ( async_b2a_req        ),
    (* async *) .async_ack_o        ( async_a2b_ack        )
  );

    cdc_reset_ctrlr_half #(
    .SYNC_STAGES          ( SYNC_STAGES          ),
    .CLEAR_ON_ASYNC_RESET ( CLEAR_ON_ASYNC_RESET )
  ) i_cdc_reset_ctrlr_half_b (
    .clk_i              ( b_clk_i              ),
    .rst_ni             ( b_rst_ni             ),
    .clear_i            ( b_clear_i            ),
    .clear_o            ( b_clear_o            ),
    .clear_ack_i        ( b_clear_ack_i        ),
    .isolate_o          ( b_isolate_o          ),
    .isolate_ack_i      ( b_isolate_ack_i      ),
    (* async *) .async_next_phase_o ( async_b2a_next_phase ),
    (* async *) .async_req_o        ( async_b2a_req        ),
    (* async *) .async_ack_i        ( async_a2b_ack        ),
    (* async *) .async_next_phase_i ( async_a2b_next_phase ),
    (* async *) .async_req_i        ( async_a2b_req        ),
    (* async *) .async_ack_o        ( async_b2a_ack        )
  );
endmodule


module cdc_reset_ctrlr_half
  import cdc_reset_ctrlr_pkg::*;
#(
  /// The number of synchronization stages to use for the
  /// clear signal request/acknowledge. Must be less than
  /// the number of sync stages used in the CDC
  parameter int unsigned SYNC_STAGES = 2,
  /// Whether an asynchronous reset shall cause a clear
  /// request to be sent to the other side.
  parameter logic        CLEAR_ON_ASYNC_RESET = 1'b1
)(
  // Synchronous side
  input logic                clk_i,
  input logic                rst_ni,
  input logic                clear_i,
  output logic               isolate_o,
  input logic                isolate_ack_i,
  output logic               clear_o,
  input logic                clear_ack_i,
  // Asynchronous clear sequence hanshaking
  output clear_seq_phase_e   async_next_phase_o,
  output logic               async_req_o,
  input logic                async_ack_i,
  input clear_seq_phase_e    async_next_phase_i,
  input logic                async_req_i,
  output logic               async_ack_o
);


  // How this module works:

  // The module is split into two parts. The initiator part consists of an FSM
  // that is triggered by the clear_i signal and transitions through reset
  // sequence. During those transitions, the `initiator_isolate_out` and
  // `initiator_clear_out` signals are asserted appropriately.

  // The receiver part receives the state transitions from the other clock
  // domain (initiator part of the `cdc_reset_ctrlr_half` instance in the other
  // clock domain) and asserts the `receiver_isolate_out` and
  // `receiver_clear_out` appropriately (considering the `isolate_ack_i`
  // signal).

  // In both, the initiator and the receiver part, the respective FSM
  // transitions through 4 phases. In the ISOLATE phase, the isolate signal is
  // asserted and the connected CDCs are expected to block all further
  // interactions with the outside world and acknowledge the isolation with the
  // isolate_ack_i signal. In the CLEAR phase, the clear signal is asserted
  // which resets the internal state of the CDC while keeping the isolate signal
  // asserted. In the POST_CLEAR phase, the clear signal is deasserted. Finally,
  // when returning to the IDLE phase, the isolate signal is deasserted to
  // continue normal operation. The FSM uses a dedicated 4-phase handshaking CDC
  // to transition between the phases in lock-step and transmits the current
  // state to the other domain to avoid issues if the other domain is reset
  // asynchronously while a clear procedure is pending.

  //---------------------- Initiator Side ----------------------
  // Sends clear sequence state transitions to the other side.
   typedef enum logic[3:0] {
     IDLE,
     ISOLATE,
     WAIT_ISOLATE_PHASE_ACK,
     WAIT_ISOLATE_ACK,
     CLEAR,
     WAIT_CLEAR_PHASE_ACK,
     WAIT_CLEAR_ACK,
     POST_CLEAR,
     FINISHED
  } initiator_state_e;
  initiator_state_e initiator_state_d, initiator_state_q;

  // The current phase of the clear sequence, sent to the other side using a
  // 4-phase CDC
  clear_seq_phase_e          initiator_clear_seq_phase;
  logic                      initiator_phase_transition_req;
  logic                      initiator_phase_transition_ack;
  logic                      initiator_isolate_out;
  logic                      initiator_clear_out;

  always_comb begin
    initiator_state_d              = initiator_state_q;
    initiator_phase_transition_req = 1'b0;
    initiator_isolate_out          = 1'b0;
    initiator_clear_out            = 1'b0;
    initiator_clear_seq_phase      = CLEAR_PHASE_IDLE;

    case (initiator_state_q)
      IDLE: begin
        if (clear_i) begin
          initiator_state_d = ISOLATE;
        end
      end

      ISOLATE: begin
        initiator_phase_transition_req = 1'b1;
        initiator_clear_seq_phase      = CLEAR_PHASE_ISOLATE;
        initiator_isolate_out          = 1'b1;
        initiator_clear_out            = 1'b0;
        if (initiator_phase_transition_ack && isolate_ack_i) begin
          initiator_state_d = CLEAR;
        end else if (initiator_phase_transition_ack) begin
          initiator_state_d = WAIT_ISOLATE_ACK;
        end else if (isolate_ack_i) begin
          initiator_state_d = WAIT_ISOLATE_PHASE_ACK;
        end
      end

      WAIT_ISOLATE_ACK: begin
        initiator_isolate_out     = 1'b1;
        initiator_clear_out       = 1'b0;
        initiator_clear_seq_phase = CLEAR_PHASE_ISOLATE;
        if (isolate_ack_i) begin
          initiator_state_d = CLEAR;
        end
      end

      WAIT_ISOLATE_PHASE_ACK: begin
        initiator_phase_transition_req = 1'b1;
        initiator_clear_seq_phase      = CLEAR_PHASE_ISOLATE;
        initiator_isolate_out          = 1'b1;
        initiator_clear_out            = 1'b0;
        if (initiator_phase_transition_ack) begin
          initiator_state_d = CLEAR;
        end
      end

      CLEAR: begin
        initiator_isolate_out          = 1'b1;
        initiator_clear_out            = 1'b1;
        initiator_phase_transition_req = 1'b1;
        initiator_clear_seq_phase      = CLEAR_PHASE_CLEAR;
        if (initiator_phase_transition_ack && clear_ack_i) begin
          initiator_state_d = POST_CLEAR;
        end else if (initiator_phase_transition_ack) begin
          initiator_state_d = WAIT_CLEAR_ACK;
        end else if (clear_ack_i) begin
          initiator_state_d = WAIT_CLEAR_PHASE_ACK;
        end
      end

      WAIT_CLEAR_ACK: begin
        initiator_isolate_out     = 1'b1;
        initiator_clear_out       = 1'b1;
        initiator_clear_seq_phase = CLEAR_PHASE_CLEAR;
        if (clear_ack_i) begin
          initiator_state_d = POST_CLEAR;
        end
      end

      WAIT_CLEAR_PHASE_ACK: begin
        initiator_phase_transition_req = 1'b1;
        initiator_clear_seq_phase      = CLEAR_PHASE_CLEAR;
        initiator_isolate_out          = 1'b1;
        initiator_clear_out            = 1'b1;
        if (initiator_phase_transition_ack) begin
          initiator_state_d = POST_CLEAR;
        end
      end

      POST_CLEAR: begin
        initiator_isolate_out          = 1'b1;
        initiator_clear_out            = 1'b0;
        initiator_phase_transition_req = 1'b1;
        initiator_clear_seq_phase      = CLEAR_PHASE_POST_CLEAR;
        if (initiator_phase_transition_ack) begin
          initiator_state_d = FINISHED;
        end
      end

      FINISHED: begin
        initiator_isolate_out          = 1'b1;
        initiator_clear_out            = 1'b0;
        initiator_phase_transition_req = 1'b1;
        initiator_clear_seq_phase      = CLEAR_PHASE_IDLE;
        if (initiator_phase_transition_ack) begin
          initiator_state_d = IDLE;
        end
      end

      default: begin
        initiator_state_d = ISOLATE;
      end
    endcase
  end

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      if (CLEAR_ON_ASYNC_RESET) begin
        initiator_state_q <= ISOLATE; // Start in the ISOLATE state which is
                                        // the first state of a clear sequence.
      end else begin
        initiator_state_q <= IDLE;
      end
    end else begin
      initiator_state_q <= initiator_state_d;
    end
  end

  // Initiator CDC SRC
  // We use 4 phase handshaking. That way it doesn't matter if one side is
  // sudenly reset asynchronously. With a 2phase CDC, one-sided async resets might
  // introduce spurios transactions.

  cdc_4phase_src #(
    .T(clear_seq_phase_e),
    .SYNC_STAGES(2),
    .DECOUPLED(0), // Important! The CDC must not be in decoupled mode.
                   // Otherwise we will proceed to the next state without
                   // waiting for the new state to arrive on the other side.
    .SEND_RESET_MSG(CLEAR_ON_ASYNC_RESET), // Send the ISOLATE phase request immediately on async
                                           // reset if async reset synchronization is enabled.
    .RESET_MSG(CLEAR_PHASE_ISOLATE)
  ) i_state_transition_cdc_src(
    .clk_i,
    .rst_ni,
    .data_i(initiator_clear_seq_phase),
    .valid_i(initiator_phase_transition_req),
    .ready_o(initiator_phase_transition_ack),
    .async_req_o,
    .async_ack_i,
    .async_data_o(async_next_phase_o)
  );


  //---------------------- Receiver Side ----------------------
  // This part of the circuit receives clear sequence state transitions from the
  // other side.

  clear_seq_phase_e receiver_phase_q;
  clear_seq_phase_e receiver_next_phase;
  logic receiver_phase_req, receiver_phase_ack;

  logic receiver_isolate_out;
  logic receiver_clear_out;

  cdc_4phase_dst #(
    .T(clear_seq_phase_e),
    .SYNC_STAGES(2),
    .DECOUPLED(0) // Important! The CDC must not be in decoupled mode. Otherwise
                  // we will proceed to the next state without waiting for the
                  // new state to arrive on the other side.
  ) i_state_transition_cdc_dst(
    .clk_i,
    .rst_ni,
    .data_o(receiver_next_phase),
    .valid_o(receiver_phase_req),
    .ready_i(receiver_phase_ack),
    .async_req_i,
    .async_ack_o,
    .async_data_i(async_next_phase_i)
  );

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      receiver_phase_q <= CLEAR_PHASE_IDLE;
    end else if (receiver_phase_req && receiver_phase_ack) begin
      receiver_phase_q <= receiver_next_phase;
    end
  end

  always_comb begin
    receiver_isolate_out = 1'b0;
    receiver_clear_out   = 1'b0;
    receiver_phase_ack   = 1'b0;

    // If there is a new phase requestd, checkout which one it is and act accordingly
    if (receiver_phase_req) begin
      case (receiver_next_phase)
        CLEAR_PHASE_IDLE: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b0;
          receiver_phase_ack   = 1'b1;
        end

        CLEAR_PHASE_ISOLATE: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b1;
          // Wait for the isolate to be acknowledged before ack'ing the phase
          receiver_phase_ack = isolate_ack_i;
        end

        CLEAR_PHASE_CLEAR: begin
          receiver_clear_out   = 1'b1;
          receiver_isolate_out = 1'b1;
          // Wait for the clear to be acknowledged before ack'ing the phase
          receiver_phase_ack   = clear_ack_i;
        end

        CLEAR_PHASE_POST_CLEAR: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b1;
          receiver_phase_ack   = 1'b1;
        end

        default: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b0;
          receiver_phase_ack   = 1'b0;
        end
      endcase

    end else begin
      // No phase change is requested for the moment. Act according to the
      // current phase signal
      case (receiver_phase_q)
        CLEAR_PHASE_IDLE: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b0;
        end

        CLEAR_PHASE_ISOLATE: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b1;
        end

        CLEAR_PHASE_CLEAR: begin
          receiver_clear_out   = 1'b1;
          receiver_isolate_out = 1'b1;
        end

        CLEAR_PHASE_POST_CLEAR: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b1;
        end

        default: begin
          receiver_clear_out   = 1'b0;
          receiver_isolate_out = 1'b0;
          receiver_phase_ack   = 1'b0;
        end
      endcase
    end
  end

  // Output Assignment

  // The clear and isolate signal are the OR combination of the receiver and
  // initiator's clear/isolate signal. This ensures that the correct sequence is
  // followed even if both sides are cleared independently at roughly the same
  // time.
  assign clear_o = initiator_clear_out || receiver_clear_out;
  assign isolate_o = initiator_isolate_out || receiver_isolate_out;

endmodule : cdc_reset_ctrlr_half
",cdc_reset_ctrlr.sv.txt,common_cells\cdc_reset_ctrlr.sv.txt
"[Keyword]: cdc_reset_ctrlr_pkg.sv

[Design Category]: Control Circuits

[Design Function Description]:
This design defines a package for a Clear Synchronization Circuitry, which is likely used for managing reset or clear operations across clock domains. It includes an enumeration that represents different phases of a clear sequence, which can be used to control the state transitions in the synchronization process.

[Input Signal Description]:
There are no direct input signals defined in this package. However, the enumeration `clear_seq_phase_e` can be used as a control signal in a larger design to manage the phases of a clear operation.

[Output Signal Description]:
There are no direct output signals defined in this package. The enumeration `clear_seq_phase_e` serves as a state indicator for the clear sequence phases, which can be used in other modules to determine the current phase of the clear operation.


[Design Detail]:
//-----------------------------------------------------------------------------
// Copyright (C) 2022 ETH Zurich, University of Bologna
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
// SPDX-License-Identifier: SHL-0.51
//-----------------------------------------------------------------------------
//
// Author: Manuel Eggimann <meggimann@iis.ee.ethz.ch>
//
// Contains common defintions for the CDC Clear Synchronization Circuitry

package cdc_reset_ctrlr_pkg;

typedef enum logic[1:0] {
  CLEAR_PHASE_IDLE,
  CLEAR_PHASE_ISOLATE,
  CLEAR_PHASE_CLEAR,
  CLEAR_PHASE_POST_CLEAR
} clear_seq_phase_e;

endpackage : cdc_reset_ctrlr_pkg
",cdc_reset_ctrlr_pkg.sv.txt,common_cells\cdc_reset_ctrlr_pkg.sv.txt
"[Keyword]: clk_div.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit is a clock divider that divides the input clock frequency by an integer factor specified by the parameter `RATIO`. It generates a slower clock output with a frequency that is 1/RATIO of the input clock frequency. The design includes a warning about the unbalanced duty cycle of the output clock and suggests using an alternative module for a balanced duty cycle.

[Input Signal Description]:
- `clk_i`: The input clock signal that needs to be divided.
- `rst_ni`: An asynchronous reset signal, active low, used to reset the internal state of the clock divider.
- `testmode_i`: A signal to enable test mode, which bypasses the clock division and outputs the input clock directly.
- `en_i`: An enable signal that allows the clock division to occur when asserted.

[Output Signal Description]:
- `clk_o`: The output clock signal, which is the divided version of the input clock. In test mode, this signal is the same as the input clock.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba
// Description: Divides the clock by an integer factor
module clk_div #(
    parameter int unsigned RATIO = 4,
    parameter bit SHOW_WARNING = 1'b1
)(
    input  logic clk_i,      // Clock
    input  logic rst_ni,     // Asynchronous reset active low
    input  logic testmode_i, // testmode
    input  logic en_i,       // enable clock divider
    output logic clk_o       // divided clock out
);
    logic [RATIO-1:0] counter_q;
    logic clk_q;

    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (~rst_ni) begin
            clk_q       <= 1'b0;
            counter_q <= '0;
        end else begin
            clk_q <= 1'b0;
            if (en_i) begin
                if (counter_q == (RATIO[RATIO-1:0] - 1)) begin
                    clk_q <= 1'b1;
                end else begin
                    counter_q <= counter_q + 1;
                end
            end
        end
    end
    // output assignment - bypass in testmode
    assign clk_o = testmode_i ? clk_i : clk_q;

  if (SHOW_WARNING) begin : gen_elab_warning
    $warning(
       ""This clock divider is deprecated and not reccomended since  "",
       ""the generated output clock has a very unbalanced duty cycle  "",
       ""(1/RATIO). For new designs we reccomend using the at-runtime "",
       ""configurable clk_int_div module which always generates 50%%  "",
       ""duty cycle clock. If you don't need at runtime configuration "",
       ""support, you can instantiate clk_int_div as follows to       "",
       ""obtain a module with roughly the same behavior (except for   "",
       ""the 50 %% duty cycle):\n                                     "",
       ""\n                                                           "",
       ""  clk_int_div #(\n                                           "",
       ""    .DIV_VALUE_WIDTH($clog2(RATIO+1)),\n                     "",
       ""    .DEFAULT_DIV_VALUE(RATIO)\n                              "",
       ""  ) i_clk_int_div(\n                                         "",
       ""    .clk_i,\n                                                "",
       ""    .rst_ni,\n                                               "",
       ""    .test_mode_en_i(testmode_i),\n                           "",
       ""    .en_i,\n                                                 "",
       ""    .div_i('1), // Ignored, used default value\n             "",
       ""    .div_valid_i(1'b0),\n                                    "",
       ""    .div_ready_o(),\n                                        "",
       ""    .clk_o\n                                                 "",
       ""  );                                                         "",
       ""\n                                                           "",
       ""If you know what your are doing and want to disable this     "",
       ""warning message, you can disable it by overriding the new    "",
       ""optional clk_div parameter SHOW_WARNING to 1'b0."");
  end

endmodule
",clk_div.sv.txt,common_cells\clk_div.sv.txt
"[Keyword]: clk_int_div.sv

[Design Category]: Control Circuits

[Design Function Description]:
This module implements a configurable integer clock divider that can be adjusted at runtime. It generates a clean 50% duty cycle output clock. The clock divider settings are handshaked to ensure glitch-free transitions. The module can bypass the divider to directly output the input clock under certain conditions, such as when the division factor is 0 or 1, or when test mode is enabled. It also includes features to safely enable or disable the output clock and to handle clock gating during transitions to prevent glitches.

[Input Signal Description]:
- `clk_i`: Input clock signal.
- `rst_ni`: Active-low reset signal.
- `en_i`: Active-high enable signal for the output clock.
- `test_mode_en_i`: Active-high signal to bypass the clock divider and directly drive the output clock with the input clock.
- `div_i`: Divider select value, determining the frequency division factor.
- `div_valid_i`: Valid handshake signal indicating a new division factor is ready to be loaded.

[Output Signal Description]:
- `div_ready_o`: Handshake signal indicating the module is ready to accept a new division factor.
- `clk_o`: Generated output clock with a 50% duty cycle, glitch-free.
- `cycl_count_o`: Current value of the internal cycle counter, useful for phase shifting relative to the generated clock.


[Design Detail]:
//-----------------------------------------------------------------------------
// Title : Configurable Integer Clock Divider
// -----------------------------------------------------------------------------
// File : clk_int_div.sv Author : Manuel Eggimann <meggimann@iis.ee.ethz.ch>
// Created : 17.03.2022
// -----------------------------------------------------------------------------
// Description :
//
// This module implements an at runtime configurable integer clock divider that
// always generates clean 50% duty cycle output clock. Clock divider setting
// changes are handshaked and during the transitioning phase between clk_div
// value changes, the output clock is gated to prevent clock glitches and no
// other clk_div change request is accepted. clk_o remains gated for at most
// 3x<new clk period> clk_i cycles. If the new div_i value equals the currently
// configured value, the clock is not gated and the handshake is immediately
// granted. It is thus safe to statically tie the valid signal to logic high if
// we can guarantee, that the div_i value remains stable long enough (upper
// limit 2 output clock cycles).
//
// The `en_i` signal can be used to enable or disable the output clock in a safe
// manner.
//
// If a div value of 0 or 1 is requested, the input clock is feed through to the
// output clock. However, the same gating rules apply (again to prevent
// glitches).
//
// If test_mode_en_i is asserted, the output clock gate is bypassed entirely and
// clk_o will always be directly driven by clk_i. Use this mode for DFT of the
// downstream logic.
//
// Parameters:
//
// DIV_VALUE_WIDTH: The number of bits to use for the internal
// counter. Defines the maximum division factor.
//
// DEFAULT_DIV_VALUE: The default division factor to use after reset. Use this
// parameter and tie div_valid_i to zero if you don't need at runtime
// configurability. An elaboration time error will be issued if the supplied
// default div value is not repressentable with DIV_VALUE_WIDTH bits.
//
// ENABLE_CLOCK_IN_RESET: If 1'b1, the clock gate will be enabled during reset
// which allows the clk_int_div instance to bypass the clock during reset, IFF
// the DEFAULT_DIV_VALUE is 1. For all other DEFAULT_DIV_VALUES, the output
// clock will not be available until rst_ni is deasserted!
//
// IMPORTANT!!!
//
// All clock gating/logic within this design is performed by dedicated clock logic
// tech cells. By default the common_cell library uses the behavioral models in
// the `tech_cells_generic` repository. However, for synthesis these cells need to be
// mapped to dedicated cells from your standard cell library, preferably ones
// that are designed for clock logic (they have balanced rise and fall time).
// During synthesis you furthermore have to properly set `dont_touch` or
// `size_only` attributes to prevent the logic synthesizer from replacing those
// cells with regular logic gates which could end up being glitchty!
//
//-----------------------------------------------------------------------------
// Copyright (C) 2022 ETH Zurich, University of Bologna Copyright and related
// rights are licensed under the Solderpad Hardware License, Version 0.51 (the
// ""License""); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law or
// agreed to in writing, software, hardware and materials distributed under this
// License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS
// OF ANY KIND, either express or implied. See the License for the specific
// language governing permissions and limitations under the License.
// SPDX-License-Identifier: SHL-0.51
// -----------------------------------------------------------------------------

module clk_int_div #(
  /// The with
  parameter int unsigned DIV_VALUE_WIDTH = 4,
  /// The default divider value which is used right after reset
  parameter int unsigned DEFAULT_DIV_VALUE = 0,
  /// If 1'b1, the output clock is enabled during async reset assertion
  parameter bit          ENABLE_CLOCK_IN_RESET = 1'b0
) (
  input logic                        clk_i,
  input logic                        rst_ni,
  /// Active-high output clock enable. Controls a glitch-free clock gate so the
  /// enable signal may be driven by combinational logic without introducing
  /// glitches.
  input logic                        en_i,
  /// If asserted (active-high) bypass the clock divider and drive clk_o
  /// directly with clk_i.
  input logic                        test_mode_en_i,
  /// Divider select value. The output clock has a frequency of f_clk_i/div_i.
  /// For div_i == 0 or  div_i == 1, the output clock has the same frequency as
  /// th input clock.
  input logic [DIV_VALUE_WIDTH-1:0]  div_i,
  /// Valid handshake signal. Must not combinationally depend on `div_ready_o`.
  /// Once asserted, the valid signal must not be deasserted until it is
  /// accepted with `div_ready_o`.
  input logic                        div_valid_i,
  output logic                       div_ready_o,
  /// Generated output clock. Given a glitch free input clock, the output clock
  /// is guaranteed to be glitch free with 50% duty cycle, regardless the timing
  /// of reconfiguration requests or en_i de/assetion. During the
  /// reconfiguration, the output clock is gated with its next falling edge and
  /// remains gated (idle-low) for at least one period of the new target output
  /// period to filter out any glitches during the config transition.
  output logic                       clk_o,
  /// Current value of the internal cycle counter. Might be usefull if you need
  /// to do some phase shifting relative to the generated clock.
  output logic [DIV_VALUE_WIDTH-1:0] cycl_count_o
);

  if ($clog2(DEFAULT_DIV_VALUE+1) > DIV_VALUE_WIDTH) begin : gen_elab_error
    $error(""Default divider value %0d is not representable with the configured"",
            ""div value width of %0d bits."",
           DEFAULT_DIV_VALUE, DIV_VALUE_WIDTH);
  end

  // We have to preset the div_q register with a value larger than one to avoid
  // an infinite loop in the WAIT_END_PERIOD state. If the default state of the
  // clock divider should be bypass, we thus always preset the div_q with 1
  // rather than 1 or zero.
  localparam int unsigned DivResetValue = (DEFAULT_DIV_VALUE != 0)? DEFAULT_DIV_VALUE: 1;

  logic [DIV_VALUE_WIDTH-1:0] div_i_normalized;
  logic [DIV_VALUE_WIDTH-1:0] div_d, div_q;
  logic                       toggle_ffs_en;
  logic                       t_ff1_d, t_ff1_q;
  logic                       t_ff1_en;

  logic                       t_ff2_d, t_ff2_q;
  logic                       t_ff2_en;

  logic [DIV_VALUE_WIDTH-1:0]   cycle_cntr_d, cycle_cntr_q;
  logic                         cycle_counter_en;
  logic                         clk_div_bypass_en_d, clk_div_bypass_en_q;
  logic                         odd_clk;
  logic                         even_clk;
  logic                         generated_clock;
  logic                         ungated_output_clock;

  logic                         use_odd_division_d, use_odd_division_q;
  logic                         gate_en_d, gate_en_q;
  logic                         gate_is_open_q;
  logic                         clear_cycle_counter;
  logic                         clear_toggle_flops;

  typedef enum logic[1:0] {IDLE, LOAD_DIV, WAIT_END_PERIOD} clk_gate_state_e;
  clk_gate_state_e clk_gate_state_d, clk_gate_state_q;

  // Normalize the div_i value. div_i == 0 and div_i == 1 have the same meaning
  // but actually loading 0 causes issues in the FSM. We thus always load 1 for
  // both cases
  assign div_i_normalized = (div_i != 0)? div_i : 1;


  //-------------------- Divider Load FSM --------------------
  always_comb begin
    div_d               = div_q;
    div_ready_o         = 1'b0;
    clk_div_bypass_en_d = clk_div_bypass_en_q;
    use_odd_division_d  = use_odd_division_q;
    clk_gate_state_d    = clk_gate_state_q;
    cycle_counter_en    = 1'b1;
    clear_cycle_counter = 1'b0;
    clear_toggle_flops  = 1'b0;
    toggle_ffs_en       = 1'b1;

    gate_en_d           = 1'b0;
    clk_gate_state_d    = clk_gate_state_q;
    case (clk_gate_state_q)
      IDLE: begin
        gate_en_d     = 1'b1;
        toggle_ffs_en = 1'b1;
        if (div_valid_i) begin
          if (div_i_normalized == div_q) begin
            div_ready_o      = 1'b1;
          end else begin
            clk_gate_state_d = LOAD_DIV;
            gate_en_d        = 1'b0;
          end
        // If we disabled the clock output, stop the cycle counter and the
        // toggle flip-flops at the start of the next period to safe energy.
        end else if (!en_i && gate_is_open_q == 1'b0) begin
            cycle_counter_en                 = 1'b0;
            toggle_ffs_en                    = 1'b0;
        end
      end

      LOAD_DIV: begin
        gate_en_d                 = 1'b0;
        toggle_ffs_en             = 1'b1;
        // Wait until the ouptut clock is currently deasserted. This ensures
        // that the clock gate disable (gate_en) was latched and changing the
        // div_q and the cycle_counter_q value cannot affect the output clock
        // any longer.
        if ((gate_is_open_q == 1'b0) || clk_div_bypass_en_q) begin
          // Now clear the cycle counter and the toggle flip flops to have a
          // deterministic output phase (rising edge of output clock always
          // coincides with first rising edge of input clock when cycl_count_o
          // == 0).
          toggle_ffs_en           = 1'b0;
          div_d                   = div_i_normalized;
          div_ready_o             = 1'b1;
          clear_cycle_counter     = 1'b1;
          clear_toggle_flops      = 1'b1;
          use_odd_division_d      = div_i_normalized[0];
          clk_div_bypass_en_d     = div_i_normalized == 1;
          clk_gate_state_d        = WAIT_END_PERIOD;
        end
      end

      WAIT_END_PERIOD: begin
        gate_en_d     = 1'b0;
        // Keep the toggle flip-flops disabled until we reach idle state.
        // Otherwise, the start state of the t-ffs depends on the number of wait
        // cycles which would yield different output clock phase depending on
        // the number of wait cycles.
        toggle_ffs_en = 1'b0;
        if (cycle_cntr_q == div_q - 1) begin
          clk_gate_state_d = IDLE;
        end
      end

      default: begin
        clk_gate_state_d = IDLE;
      end
    endcase
  end

  localparam logic UseOddDivisionResetValue = DEFAULT_DIV_VALUE[0];
  localparam logic ClkDivBypassEnResetValue = (DEFAULT_DIV_VALUE < 2)? 1'b1: 1'b0;

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      use_odd_division_q  <= UseOddDivisionResetValue;
      clk_div_bypass_en_q <= ClkDivBypassEnResetValue;
      div_q               <= DivResetValue;
      clk_gate_state_q    <= IDLE;
      gate_en_q           <= ENABLE_CLOCK_IN_RESET;
    end else begin
      use_odd_division_q  <= use_odd_division_d;
      clk_div_bypass_en_q <= clk_div_bypass_en_d;
      div_q               <= div_d;
      clk_gate_state_q    <= clk_gate_state_d;
      gate_en_q           <= gate_en_d;
    end
  end

  //---------------------- Cycle Counter ----------------------

  // Cycle Counter
  always_comb begin
    cycle_cntr_d = cycle_cntr_q;
    // Reset the counter if we load a new divider value.
    if (clear_cycle_counter) begin
      cycle_cntr_d = '0;
    end else begin
      if (cycle_counter_en) begin
        // During normal operation, reset the counter whenver it reaches
        // <target_count>-1. In bypass mode (div == 0 or div == 1) disable the
        // counter to save power.
        if (clk_div_bypass_en_q || (cycle_cntr_q == div_q-1)) begin
          cycle_cntr_d = '0;
        end else begin
          cycle_cntr_d = cycle_cntr_q + 1;
        end
      end
    end
  end

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      cycle_cntr_q <= '0;
    end else begin
      cycle_cntr_q <= cycle_cntr_d;
    end
  end

  assign cycl_count_o = cycle_cntr_q;

  //----------------------- T-Flip-Flops -----------------------

  // These T-Flip-Flop intentionally use blocking assignments! If we were to use
  // non-blocking assignment like we normally do for flip-flops, we would create
  // a race condition when sampling data from the fast clock domain into
  // flip-flops clocked by t_ff1_q and t_ff2_q. To avoid this, we use blocking assignments
  // which is the recomended method acording to:
  // S. Sutherland and D. Mills,
  // Verilog and System Verilog gotchas: 101 common coding errors and how to
  // avoid them. New York: Springer, 2007. page 64.

  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      t_ff1_q = '0; // Intentional blocking assignment! Do not replace!
    end else begin
      if (t_ff1_en) begin
        t_ff1_q = t_ff1_d; // Intentional blocking assignment! Do not replace!
      end
    end
  end

  // The second flip-flop is required for odd integer division and needs to
  // negative edge tirggered.
  always_ff @(negedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      t_ff2_q = '0; // Intentional blocking assignment! Do not replace!
    end else begin
      if (t_ff2_en) begin
        t_ff2_q = t_ff2_d; // Intentional blocking assignment! Do not replace!
      end
    end
  end

  always_comb begin
    if (clear_toggle_flops) begin
      t_ff1_d = '0;
      t_ff2_d = '0;
    end else begin
      t_ff1_d = t_ff1_en? !t_ff1_q: t_ff1_q;
      t_ff2_d = t_ff2_en? !t_ff2_q: t_ff2_q;
    end
  end


  //----- FSM to control T-FF enable and clk_div_bypass_en -----

  always_comb begin
    t_ff1_en = 1'b0;
    t_ff2_en = 1'b0;
    if (!clk_div_bypass_en_q && toggle_ffs_en) begin
      if (use_odd_division_q) begin
        t_ff1_en = (cycle_cntr_q == 0)? 1'b1: 1'b0;
        t_ff2_en = (cycle_cntr_q == (div_q+1)/2)? 1'b1: 1'b0;
      end else begin
        t_ff1_en = (cycle_cntr_q == 0 || cycle_cntr_q == div_q/2)? 1'b1: 1'b0;
      end
    end
  end

  assign even_clk = t_ff1_q;

  //----------- Clock XOR for the odd division logic -----------
  tc_clk_xor2 i_odd_clk_xor (
    .clk0_i ( t_ff1_q ),
    .clk1_i ( t_ff2_q ),
    .clk_o  ( odd_clk )
  );

  //---- Clock MUX to select between odd and even div logic ----
  tc_clk_mux2 i_clk_mux (
    .clk0_i    ( even_clk           ),
    .clk1_i    ( odd_clk            ),
    .clk_sel_i ( use_odd_division_q ),
    .clk_o     ( generated_clock    )
  );

  //-------------------- clock mux to bypass clock if divide-by-1  --------------------
  tc_clk_mux2 i_clk_bypass_mux (
    .clk0_i    ( generated_clock                       ),
    .clk1_i    ( clk_i                                 ),
    .clk_sel_i ( clk_div_bypass_en_q || test_mode_en_i ),
    .clk_o     ( ungated_output_clock                  )
  );

  //--------------------- Clock gate logic ---------------------
  // During the transitioning phase, we gate the clock to prevent clock glitches

  // The gate_is_open_q signal is used by the FSM to determine whether the
  // gate_en signal has been latched by the clock gate cell, i.e. if this signal
  // is 1'b0, it means not only that the clock gate should be disabled but also that
  // clk_o is currently LOW and thus the enable signal has been latched and the
  // output clock will remain LOW until we enable the clock again.
  // The FSM needs to know this to not disable the T-FFs and the cycle counter
  // to early. Otherwise the clock might get stuck active high or we deassert a
  // clock to early
  always_ff @(posedge ungated_output_clock, negedge rst_ni) begin
    if (!rst_ni) begin
      gate_is_open_q <= 1'b0;
    end else begin
      gate_is_open_q <= gate_en_q & en_i;
    end
  end

  tc_clk_gating #(
    .IS_FUNCTIONAL(1) // The gate is required to prevent glitches during
                      // transitioning. Target specific implementations must not
                      // remove it to save ICGs (e.g. in FPGAs).
  ) i_clk_gate (
    .clk_i     ( ungated_output_clock ),
    .en_i      ( gate_en_q & en_i     ),
    .test_en_i ( test_mode_en_i       ),
    .clk_o
  );


endmodule
",clk_int_div.sv.txt,common_cells\clk_int_div.sv.txt
"[Keyword]: clk_int_div_static.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design implements a static integer clock divider. It divides the input clock signal by a constant integer value specified at elaboration time, ensuring a 50% duty cycle for both odd and even division values. The module provides a simplified interface for a single division factor and includes a glitch-free clock gate for enabling or disabling the output clock safely.

[Input Signal Description]:
- `clk_i`: The input clock signal to be divided.
- `rst_ni`: An active-low reset signal. When asserted, it resets the internal state of the divider.
- `en_i`: An enable signal to control the output clock. When asserted, the output clock is enabled.
- `test_mode_en_i`: A signal used to enable test mode, typically for testing purposes.

[Output Signal Description]:
- `clk_o`: The output clock signal, which is the divided version of the input clock `clk_i`.


[Design Detail]:
//-----------------------------------------------------------------------------
// Title         : Static Integer Clock Divider
//-----------------------------------------------------------------------------
// File          : clk_int_div_static.sv
// Author        : Manuel Eggimann  <meggimann@iis.ee.ethz.ch>
// Created       : 08.05.2023
//-----------------------------------------------------------------------------
// Description :
//
// This module implements a static arbitrary integer divider. Static in this
// case means, the divider value is constant at elaboration time (SV parameter).
// It supports arbitrary integer division with a guaranteed 50% duty cycle for
// odd and even division.

// Internally, this module is wrapper around the ""at-runtime"" configurable
// `clk_int_div`module. If you need to change the division factor at-runtime you
// should directly use `clk_int_div`instead. However if all you need is a single
// division factor this module provides a convenience wrapper for you with a
// simplified interface.
//
// The `en_i` signal can be used to enable or disable the output clock in a safe
// manner (there is an internal, glitch-free clock gate).
//
// Parameters:
//
// DIV_VALUE: The integer value by which the clock shall be divided. Must be
// non-zero integer smaller than 2^32-1.
//
// ENABLE_CLOCK_IN_RESET: If 1'b1, the clock gate will be enabled during reset
// which allows the clk_int_div instance to bypass the clock during reset, IFF
// the DEFAULT_DIV_VALUE is 1. For all other DEFAULT_DIV_VALUES, the output
// clock will not be available until rst_ni is deasserted!
//
// IMPORTANT!!!
//
// All clock gating/logic within this design is performed by dedicated clock
// logic tech cells. By default the common_cell library uses the behavioral
// models in the `tech_cells_generic` repository. However, for synthesis these
// cells need to be mapped to dedicated cells from your standard cell library,
// preferably ones that are designed for clock logic (they have balanced rise
// and fall time). During synthesis you furthermore have to properly set
// `dont_touch` or `size_only` attributes to prevent the logic synthesizer from
// replacing those cells with regular logic gates which could end up being
// glitchty!
//
//-----------------------------------------------------------------------------
// Copyright (C) 2023 ETH Zurich, University of Bologna Copyright and related
// rights are licensed under the Solderpad Hardware License, Version 0.51 (the
// ""License""); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law or
// agreed to in writing, software, hardware and materials distributed under this
// License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS
// OF ANY KIND, either express or implied. See the License for the specific
// language governing permissions and limitations under the License.
// SPDX-License-Identifier: SHL-0.51
// -----------------------------------------------------------------------------


module clk_int_div_static #(
  parameter int unsigned DIV_VALUE = 1,
  parameter bit ENABLE_CLOCK_IN_RESET = 1'b1
) (
  input logic  clk_i,
  input logic  rst_ni,
  input logic  en_i,
  input logic  test_mode_en_i,
  output logic clk_o
);
  if (DIV_VALUE == 0) begin : gen_elab_error
    $error(""DIV_VALUE must be strictly larger than 0."");
  end

  localparam int unsigned DivValueWidth = $clog2(DIV_VALUE+1);

  logic [DivValueWidth-1:0] div_value;
  assign div_value = DIV_VALUE;

  clk_int_div #(
    .DIV_VALUE_WIDTH       ( DivValueWidth         ),
    .DEFAULT_DIV_VALUE     ( DIV_VALUE             ),
    .ENABLE_CLOCK_IN_RESET ( ENABLE_CLOCK_IN_RESET )
  ) i_clk_int_div (
    .clk_i,
    .rst_ni,
    .en_i,
    .test_mode_en_i,
    .div_i        ( div_value ),
    .div_valid_i  ( 1'b0      ),
    .div_ready_o  (           ),
    .clk_o,
    .cycl_count_o (           )
  );

endmodule
",clk_int_div_static.sv.txt,common_cells\clk_int_div_static.sv.txt
"[Keyword]: clk_mux_glitch_free.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a glitch-free clock multiplexer that allows for safe switching between multiple input clock signals with unknown phase relationships. It ensures that the output clock transitions smoothly without glitches by synchronizing the select signal to the relevant clock domains and silencing the output during transitions. The design uses dedicated clock logic cells to manage clock gating and multiplexing, ensuring reliable operation even during reset conditions.

[Input Signal Description]:
- `clks_i[NUM_INPUTS-1:0]`: An array of input clock signals from which one will be selected to propagate to the output.
- `test_clk_i`: A test clock input used for Design for Test (DFT) purposes.
- `test_en_i`: A test enable signal that selects between the regular clock and the test clock.
- `async_rstn_i`: An asynchronous reset signal, active low, used to reset the internal logic.
- `async_sel_i[SelWidth-1:0]`: A selection signal used to choose which input clock to propagate to the output.

[Output Signal Description]:
- `clk_o`: The output clock signal that is the result of the glitch-free multiplexing of the input clocks.


[Design Detail]:
//-----------------------------------------------------------------------------
// Title         : Glitch-free Clock Multiplexer
//-----------------------------------------------------------------------------
// File          : clk_mux_glitch_free.sv
// Author        : Manuel Eggimann  <meggimann@iis.ee.ethz.ch>
// Created       : 10.12.2022
//-----------------------------------------------------------------------------
// Description :
//
// This module allows glitch free clock multiplexing between N arbitrary input
// clock with completely unknown phase relation shipts. The module will make
// sure to first synchronize the clock multiplexer signal to the relevant clock
// domains and ensures glitch free switching between the source clock and the
// new target clock by silencing the output at appropriate times. The clock
// signals themselves only pass through: 1 clock-gate, 1 N-input clock-OR Gate,
// 1 2-input clock mux. All these cells are referenced from the tech_cells
// repository and thus no conventional logic gate is directly in the clock path.

// The correctness of this module is based on the following assumptions:
// 1. The select signal stays stable for a duration of at least min(clks_i
// period)
// 2. Glitches on the select signal are shorter than min(clks_i) - t_setup
// 3. During a transition from clock input a to clock input b, both clocks have
// a stable period.
//
// A clock switching procedure from clock a to clock b has the following timing behavior:
// 1. After at most NUM_SYNC_STAGES clock cycle of clock a, the output clock is
// disabled with its next falling edge.
// 2. After clock cycle of clock a and another NUM_SYNC_STAGES clock cycles of clock b, the output is
// enabled with the next rising edge of clock B.
//
// So in total, an upper bound for the worst case clock switching delay is 2x
// NUM_SYNC_STAGES x max(clock_periods)
//
// The design has a parameter (CLOCK_DURING_RESET) that allows the clock
// multiplexer to propagate the selected clock even during reset assertion.
// However, during reset assertion the glitch filtering and the synchronization
// registers are bypassed (since the are frozen in reset state). Thus no glitch
// filtering is performed during reset. This is ok if the async_sel_i signal
// stays constant during reset assertion. Once you deassert the reset, regular
// glitch fitlering and synchronization will kick in. However, you must wait for
// at least 1x max(input clock periods) before changing the async_sel_i after a
// reset to be sure the switch to regular operation has completed. During the
// transition from async_reset operation to regular operation there will be a
// short phase where the clock is gated (similar to what happens when you switch
// from one clock to the other).
//
//  IMPORTANT!!!
//
// All clock gating/logic within this design is performed by dedicated clock
// logic tech cells. By default the common_cell library uses the behavioral
// models in the `tech_cells_generic` repository. However, for synthesis these
// cells need to be mapped to dedicated cells from your standard cell library,
// preferably ones that are designed for clock logic (they have balanced rise
// and fall time). During synthesis you furthermore have to properly set
// `dont_touch` or `size_only` attributes to prevent the logic synthesizer from
// replacing those cells with regular logic gates which could end up being
// glitchty!
//
//-----------------------------------------------------------------------------
// Copyright (C) 2013-2022 ETH Zurich, University of Bologna
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//-----------------------------------------------------------------------------


module clk_mux_glitch_free #(
  parameter int unsigned  NUM_INPUTS = 2,
  parameter int unsigned  NUM_SYNC_STAGES = 2,
  parameter bit CLOCK_DURING_RESET = 1'b1, //< If 1, alow the selected clock to
                                           //propagate even during reset
                                           //assertion.
  localparam int unsigned SelWidth = $clog2(NUM_INPUTS)
) (
   input logic [NUM_INPUTS-1:0] clks_i,
   input logic                  test_clk_i,
   input logic                  test_en_i,
   input logic                  async_rstn_i,
   input logic [SelWidth-1:0]   async_sel_i,
   output logic                 clk_o
);



  if (NUM_INPUTS<2)
    $error(""Num inputs must be parametrized to a value >= 2."");

  // For each input, we generate an enable signal that enables the clock
  // propagation through an N-input clock OR gate. The crucial and most critical
  // part is to make sure that these clock enable signal transitions are
  // non-overlapping and have enough timing separation to prevent any glitches
  // on the clock output during the transition. We ensure this as follows:
  //
  // 1. Decode the sel_i input to a onehot signal.
  // 2. For each clock input, take the correspondi onehot signal. For each clock
  // input we also have a correspdonding output clock enable signal that
  // controls the corresponding clock's clk gate. We thus and-gate the one-hot
  // signal of the current clock with the inverse of every other clocks enable
  // signal. In other words, we only allow the propagation of the onehot enable
  // signal if the clock is currently disabled.
  // 3. Filter any glitches on this and-gated signal by passing it through a
  // flip-flop clocked by the current clock and and-gating both the output and
  // the input. I.e. the output is only becomes active if the signal stays
  // stable HIGH for at least one clock period.
  // 4. Synchronize this glitch-filtered signal into the current clock domain
  // with an M-stage synchronizer.
  // 5. Use this synchronized signal as the enable signal for a glitch-free
  // clock gate.
  // 7. Feed the output of the clock gate to an N-input clock-AND gate.
  // 8. Latch the gate enable signal with an active low latch before using the
  // signal as a gating signal for the other clock input's onehot signal.

  // Internal signals
  logic [NUM_INPUTS-1:0]        s_sel_onehot;
  (*dont_touch*)
  (*async_reg*)
  logic [NUM_INPUTS-1:0][1:0]   glitch_filter_d, glitch_filter_q;
  logic [NUM_INPUTS-1:0]        s_gate_enable_unfiltered_async;
  logic [NUM_INPUTS-1:0]        s_glitch_filter_output_async;
  logic [NUM_INPUTS-1:0]        s_gate_enable_sync;
  logic [NUM_INPUTS-1:0]        s_gate_enable;
  logic [NUM_INPUTS-1:0]        clock_has_been_disabled_q;
  logic [NUM_INPUTS-1:0]        s_gated_clock;
  logic                         s_output_clock;

  logic [NUM_INPUTS-1:0]        s_reset_synced;
  logic [NUM_INPUTS-1:0]        async_reset_bypass_active_q;


  // Onehot decoder
  always_comb begin
    s_sel_onehot = '0;
    s_sel_onehot[async_sel_i] = 1'b1;
  end

  // Input stages
  for (genvar i = 0; i < NUM_INPUTS; i++) begin : gen_input_stages
    // Synchronize the reset into each clock domain
    rstgen i_rstgen(
      .clk_i       ( clks_i[i]         ),
      .rst_ni      ( async_rstn_i      ),
      .test_mode_i ( test_en_i         ),
      .rst_no      ( s_reset_synced[i] ),
      .init_no     (                   )
    );

    // Gate onehot signal with other clocks' output gate enable
    always_comb begin
      s_gate_enable_unfiltered_async[i] = 1'b1;
      for (int j = 0; j < NUM_INPUTS; j++) begin
        if (i==j) begin
          s_gate_enable_unfiltered_async[i] &= s_sel_onehot[j];
        end else begin
          s_gate_enable_unfiltered_async[i] &= clock_has_been_disabled_q[j];
        end
      end
    end
    assign glitch_filter_d[i][0] = s_gate_enable_unfiltered_async[i];
    assign glitch_filter_d[i][1] = glitch_filter_q[i][0];

    // Filter HIGH-pulse glitches
    always_ff @(posedge clks_i[i], negedge s_reset_synced[i]) begin
      if (!s_reset_synced[i]) begin
        glitch_filter_q[i] <= '0;
      end else begin
        glitch_filter_q[i] <= glitch_filter_d[i];
      end
    end
    assign s_glitch_filter_output_async[i] = glitch_filter_q[i][1] &
                                       glitch_filter_q[i][0] &
                                       s_gate_enable_unfiltered_async[i];

    // Synchronize to current clock
    sync #(.STAGES(NUM_SYNC_STAGES)) i_sync_en(
      .clk_i    ( clks_i[i]                       ),
      .rst_ni   ( s_reset_synced[i]               ),
      .serial_i ( s_glitch_filter_output_async[i] ),
      .serial_o ( s_gate_enable_sync[i]           )
    );

    // If the design is parametrized to propagate a clock during asserted reset,
    // we have to provide a bypass path that directly connects the unfiltered
    // gate enable signal to the clock gate for as long as the reset is active.

    if (CLOCK_DURING_RESET) begin : gen_async_reset_clock_bypass_logic
      always_ff @(posedge clks_i[i], negedge s_reset_synced[i]) begin
        if (!s_reset_synced[i]) begin
          async_reset_bypass_active_q[i] <= 1'b1;
        end else begin
          async_reset_bypass_active_q[i] <= 1'b0;
        end
      end

      assign s_gate_enable[i] = async_reset_bypass_active_q[i]?
                                s_gate_enable_unfiltered_async[i]
                                : s_gate_enable_sync[i];
    end else begin : gen_no_async_reset_bypass_logic
      assign s_gate_enable[i] = s_gate_enable_sync[i];
    end

    // Gate the input clock with the synced enable signal
    tc_clk_gating #(
      .IS_FUNCTIONAL(1'b1)
    ) i_clk_gate (
      .clk_i     ( clks_i[i]        ),
      .en_i      ( s_gate_enable[i] ),
      .test_en_i ( 1'b0             ),
      .clk_o     ( s_gated_clock[i] )
    );

    // Latch the enable signal with the next rising edge of the input clock and
    // feed the output back to the other stage's input. If we were to directly
    // use the clock gate enable signal to determine wether it is save to enable
    // another clock (i.e. the signal becomes low) we would risk enabling the
    // other clock to early. This is because the glitch free clock gate will
    // only really disable the clock with the next falling edge. By delaying the
    // enable signal one more cycle, we ensure that the clock stays low for at
    // least one clock period of the original clock input before any other clock
    // even has the chance to become active.

    always_ff @(posedge clks_i[i], negedge s_reset_synced[i]) begin
      if (!s_reset_synced[i]) begin
        clock_has_been_disabled_q[i] <= 1'b1;
      end else begin
        clock_has_been_disabled_q[i] <= ~s_gate_enable[i];
      end
    end
  end

  // Output OR-gate. At this stage, we should be already sure that the clocks
  // are enabled/disabled at the proper time to prevent any glitches from
  // escaping.

  clk_or_tree #(NUM_INPUTS) i_clk_or_tree (
    .clks_i(s_gated_clock),
    .clk_o(s_output_clock)
  );

  // Mux between the regular muxed clock and the test_clk_i used for DFT.
  tc_clk_mux2 i_test_clk_mux(
    .clk0_i(s_output_clock),
    .clk1_i(test_clk_i),
    .clk_sel_i(test_en_i),
    .clk_o
  );

endmodule

// Helper Module to generate an N-input clock OR-gate from a tree of tc_clk_or2 cells.
module clk_or_tree #(
  parameter int unsigned NUM_INPUTS
) (
  input logic [NUM_INPUTS-1:0] clks_i,
  output logic clk_o
);

  if (NUM_INPUTS < 1) begin : gen_error
    $error(""Cannot parametrize clk_or with less then 1 input but was %0d"", NUM_INPUTS);
  end else if (NUM_INPUTS == 1) begin : gen_leaf
    assign clk_o          = clks_i[0];
  end else if (NUM_INPUTS == 2) begin : gen_leaf
    tc_clk_or2 i_clk_or2 (
      .clk0_i(clks_i[0]),
      .clk1_i(clks_i[1]),
      .clk_o
    );
  end else begin  : gen_recursive
    logic branch_a, branch_b;
    clk_or_tree #(NUM_INPUTS/2) i_or_branch_a (
      .clks_i(clks_i[0+:NUM_INPUTS/2]),
      .clk_o(branch_a)
    );

    clk_or_tree #(NUM_INPUTS/2 + NUM_INPUTS%2) i_or_branch_b (
      .clks_i(clks_i[NUM_INPUTS-1:NUM_INPUTS/2]),
      .clk_o(branch_b)
    );

    tc_clk_or2 i_clk_or2 (
      .clk0_i(branch_a),
      .clk1_i(branch_b),
      .clk_o
    );
  end

endmodule
",clk_mux_glitch_free.sv.txt,common_cells\clk_mux_glitch_free.sv.txt
"[Keyword]: clock_divider.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The module is a clock divider circuit. It takes an input clock signal and divides its frequency based on a specified division factor. The division factor can be dynamically set through an input signal. The module also includes clock gating functionality to enable or disable the output clock based on control signals.

[Input Signal Description]:
- `clk_i`: The input clock signal that needs to be divided.
- `rstn_i`: An active-low reset signal to initialize or reset the circuit.
- `test_mode_i`: A signal to enable test mode, which might bypass certain functionalities for testing purposes.
- `clk_gate_async_i`: An asynchronous signal used for external clock gating.
- `clk_div_data_i[7:0]`: An 8-bit input signal specifying the division factor for the clock.
- `clk_div_valid_i`: A signal indicating that the division factor data is valid and should be sampled.

[Output Signal Description]:
- `clk_div_ack_o`: An acknowledgment signal indicating that the division factor has been successfully sampled.
- `clk_o`: The output clock signal, which is the divided version of the input clock.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Company:        Multitherman Laboratory @ DEIS - University of Bologna     //
//                    Viale Risorgimento 2 40136                              //
//                    Bologna - fax 0512093785 -                              //
//                                                                            //
// Engineer:       Antonio Pullini - pullinia@iis.ee.ethz.ch                  //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    13/02/2013                                                 //
// Design Name:    ULPSoC                                                     //
// Module Name:    clock_divider                                              //
// Project Name:   ULPSoC                                                     //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:    Clock Divider                                              //
//                                                                            //
//                                                                            //
// Revision:                                                                  //
// Revision v0.1 - File Created                                               //
// Revision v0.2 - (19/03/2015)   clock_gating swapped in pulp_clock_gating   //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

module clock_divider
#(
    parameter DIV_INIT     = 0,
    parameter BYPASS_INIT  = 1
)
(
    input  logic       clk_i,
    input  logic       rstn_i,
    input  logic       test_mode_i,
    input  logic       clk_gate_async_i,
    input  logic [7:0] clk_div_data_i,
    input  logic       clk_div_valid_i,
    output logic       clk_div_ack_o,
    output logic       clk_o
);

   enum                logic [1:0] {IDLE, STOP, WAIT, RELEASE} state, state_next;

   logic               s_clk_out;
   logic               s_clock_enable;
   logic               s_clock_enable_gate;
   logic               s_clk_div_valid;

   logic [7:0]         reg_clk_div;
   logic               s_clk_div_valid_sync;

   logic               s_rstn_sync;

   logic [1:0]         reg_ext_gate_sync;

    assign s_clock_enable_gate =  s_clock_enable & reg_ext_gate_sync;

`ifndef PULP_FPGA_EMUL
    rstgen i_rst_gen
    (
        // PAD FRAME SIGNALS
        .clk_i(clk_i),
        .rst_ni(rstn_i),            //async signal coming from pads

        // TEST MODE
        .test_mode_i(test_mode_i),

        // OUTPUT RESET
        .rst_no(s_rstn_sync),
        .init_no()                 //not used
    );
  `else
  assign s_rstn_sync = rstn_i;
`endif


    //handle the handshake with the soc_ctrl. Interface is now async
    pulp_sync_wedge i_edge_prop
    (
        .clk_i(clk_i),
        .rstn_i(s_rstn_sync),
        .en_i(1'b1),
        .serial_i(clk_div_valid_i),
        .serial_o(clk_div_ack_o),
        .r_edge_o(s_clk_div_valid_sync),
        .f_edge_o()
    );

    clock_divider_counter
    #(
        .BYPASS_INIT(BYPASS_INIT),
        .DIV_INIT(DIV_INIT)
    )
    i_clkdiv_cnt
    (
        .clk(clk_i),
        .rstn(s_rstn_sync),
        .test_mode(test_mode_i),
        .clk_div(reg_clk_div),
        .clk_div_valid(s_clk_div_valid),
        .clk_out(s_clk_out)
    );

    pulp_clock_gating i_clk_gate
    (
        .clk_i(s_clk_out),
        .en_i(s_clock_enable_gate),
        .test_en_i(test_mode_i),
        .clk_o(clk_o)
    );

    always_comb
    begin
        case(state)
        IDLE:
        begin
            s_clock_enable   = 1'b1;
            s_clk_div_valid  = 1'b0;
            if (s_clk_div_valid_sync)
                state_next = STOP;
            else
                state_next = IDLE;
        end

        STOP:
        begin
            s_clock_enable   = 1'b0;
            s_clk_div_valid  = 1'b1;
            state_next = WAIT;
        end

        WAIT:
        begin
            s_clock_enable   = 1'b0;
            s_clk_div_valid  = 1'b0;
            state_next = RELEASE;
        end

        RELEASE:
        begin
            s_clock_enable   = 1'b0;
            s_clk_div_valid  = 1'b0;
            state_next = IDLE;
        end
        endcase
    end

    always_ff @(posedge clk_i or negedge s_rstn_sync)
    begin
        if (!s_rstn_sync)
            state <= IDLE;
        else
            state <= state_next;
    end

    //sample the data when valid has been sync and there is a rise edge
    always_ff @(posedge clk_i or negedge s_rstn_sync)
    begin
        if (!s_rstn_sync)
            reg_clk_div <= '0;
        else if (s_clk_div_valid_sync)
                  reg_clk_div <= clk_div_data_i;
    end

    //sample the data when valid has been sync and there is a rise edge
    always_ff @(posedge clk_i or negedge s_rstn_sync)
    begin
        if (!s_rstn_sync)
            reg_ext_gate_sync <= 2'b00;
        else
            reg_ext_gate_sync <= {clk_gate_async_i, reg_ext_gate_sync[1]};
    end

endmodule
",clock_divider.sv.txt,common_cells\clock_divider.sv.txt
"[Keyword]: clock_divider_counter.sv

[Design Category]: Control Circuits

[Design Function Description]:
The module `clock_divider_counter` is designed to divide the input clock frequency by a specified factor. It generates a divided clock output based on the value provided in the `clk_div` input. The module supports both odd and even division factors and includes a bypass mode for direct clock output. It also incorporates clock gating and inversion for power efficiency and testing purposes.

[Input Signal Description]:
- `clk`: The input clock signal that needs to be divided.
- `rstn`: Active-low reset signal to initialize the module.
- `test_mode`: A signal to enable test mode, affecting clock inversion.
- `clk_div[7:0]`: An 8-bit signal specifying the division factor for the clock.
- `clk_div_valid`: A signal indicating when the `clk_div` value is valid and should be used to update the division factor.

[Output Signal Description]:
- `clk_out`: The output clock signal, which is the divided version of the input clock `clk`, or the original clock in bypass or test mode.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

////////////////////////////////////////////////////////////////////////////////
// Company:        Multitherman Laboratory @ DEIS - University of Bologna     //
//                    Viale Risorgimento 2 40136                              //
//                    Bologna - fax 0512093785 -                              //
//                                                                            //
// Engineer:       Antonio Pullini - pullinia@iis.ee.ethz.ch                  //
//                                                                            //
// Additional contributions by:                                               //
//                                                                            //
//                                                                            //
//                                                                            //
// Create Date:    13/02/2013                                                 //
// Design Name:    ULPSoC                                                     //
// Module Name:    clock_divider_counter                                      //
// Project Name:   ULPSoC                                                     //
// Language:       SystemVerilog                                              //
//                                                                            //
// Description:    clock_divider_counter                                      //
//                                                                            //
//                                                                            //
// Revision:                                                                  //
// Revision v0.1 - File Created                                               //
// Revision v0.2 - (19/03/2015)   clock_gating swapped in pulp_clock_gating   //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


module clock_divider_counter
#(
    parameter BYPASS_INIT = 1,
    parameter DIV_INIT    = 'hFF
)
(
    input  logic       clk,
    input  logic       rstn,
    input  logic       test_mode,
    input  logic [7:0] clk_div,
    input  logic       clk_div_valid,
    output logic       clk_out
);

    logic [7:0]         counter;
    logic [7:0]         counter_next;
    logic [7:0]         clk_cnt;
    logic               en1;
    logic               en2;

    logic               is_odd;

    logic               div1;
    logic               div2;
    logic               div2_neg_sync;

    logic [7:0]         clk_cnt_odd;
    logic [7:0]         clk_cnt_odd_incr;
    logic [7:0]         clk_cnt_even;
    logic [7:0]         clk_cnt_en2;

    logic               bypass;

    logic               clk_out_gen;
    logic               clk_div_valid_reg;

    logic               clk_inv_test;
    logic               clk_inv;

    //        assign clk_cnt_odd_incr = clk_div + 1;
    //        assign clk_cnt_odd  = {1'b0,clk_cnt_odd_incr[7:1]}; //if odd divider than clk_cnt = (clk_div+1)/2
    assign clk_cnt_odd  = clk_div - 8'h1; //if odd divider than clk_cnt = clk_div - 1
    assign clk_cnt_even = (clk_div == 8'h2) ? 8'h0 : ({1'b0,clk_div[7:1]} - 8'h1);   //if even divider than clk_cnt = clk_div/2
    assign clk_cnt_en2  = {1'b0,clk_cnt[7:1]} + 8'h1;

    always_comb
    begin
        if (counter == 'h0)
            en1 = 1'b1;
        else
            en1 = 1'b0;

        if (clk_div_valid)
            counter_next = 'h0;
        else if (counter == clk_cnt)
                counter_next = 'h0;
             else
                counter_next = counter + 1;

        if (clk_div_valid)
            en2 = 1'b0;
        else if (counter == clk_cnt_en2)
                en2 = 1'b1;
             else
                en2 = 1'b0;
    end

   always_ff @(posedge clk, negedge rstn)
   begin
        if (~rstn)
        begin
             counter            <=  'h0;
             div1               <= 1'b0;
             bypass             <= BYPASS_INIT;
             clk_cnt            <= DIV_INIT;
             is_odd             <= 1'b0;
             clk_div_valid_reg  <= 1'b0;
        end
        else
        begin
              if (!bypass)
                  counter <= counter_next;

              clk_div_valid_reg <= clk_div_valid;
              if (clk_div_valid)
              begin
                if ((clk_div == 8'h0) || (clk_div == 8'h1))
                  begin
                      bypass <= 1'b1;
                      clk_cnt <= 'h0;
                      is_odd  <= 1'b0;
                  end
                else
                  begin
                      bypass <= 1'b0;
                      if (clk_div[0])
                        begin
                          is_odd  <= 1'b1;
                          clk_cnt <= clk_cnt_odd;
                        end
                      else
                        begin
                          is_odd  <= 1'b0;
                          clk_cnt <= clk_cnt_even;
                        end
                  end
                div1 <= 1'b0;
              end
              else
              begin
                if (en1 && !bypass)
                  div1 <= ~div1;
              end
        end
    end

    pulp_clock_inverter clk_inv_i
    (
        .clk_i(clk),
        .clk_o(clk_inv)
    );

`ifndef PULP_FPGA_EMUL
 `ifdef PULP_DFT
   pulp_clock_mux2 clk_muxinv_i
     (
      .clk0_i(clk_inv),
      .clk1_i(clk),
      .clk_sel_i(test_mode),
      .clk_o(clk_inv_test)
      );
 `else
   assign clk_inv_test = clk_inv;
 `endif
`else
   assign clk_inv_test = clk_inv;
`endif

    always_ff @(posedge clk_inv_test or negedge rstn)
    begin
        if (!rstn)
        begin
            div2    <= 1'b0;
        end
        else
        begin
            if (clk_div_valid_reg)
                div2 <= 1'b0;
            else if (en2 && is_odd && !bypass)
                    div2 <= ~div2;
        end
    end // always_ff @ (posedge clk_inv_test or negedge rstn)

    pulp_clock_xor2 clock_xor_i
    (
        .clk_o(clk_out_gen),
        .clk0_i(div1),
        .clk1_i(div2)
    );

    pulp_clock_mux2 clk_mux_i
    (
        .clk0_i(clk_out_gen),
        .clk1_i(clk),
        .clk_sel_i(bypass || test_mode),
        .clk_o(clk_out)
    );

endmodule
",clock_divider_counter.sv.txt,common_cells\clock_divider_counter.sv.txt
"[Keyword]: counter.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a generic up/down counter. The counter can be configured to count upwards or downwards based on the `down_i` input. It supports loading a new value, synchronous clearing, and can indicate an overflow condition. The width of the counter is parameterizable, allowing for flexibility in the number of bits used for counting.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the counter operations.
- `rst_ni`: Active-low reset input signal to initialize the counter.
- `clear_i`: Synchronous clear input signal to reset the counter value.
- `en_i`: Enable input signal to allow the counter to increment or decrement.
- `load_i`: Input signal to load a new value into the counter.
- `down_i`: Input signal to determine the counting direction (up or down).
- `d_i[WIDTH-1:0]`: Data input signal for loading a specific value into the counter.

[Output Signal Description]:
- `q_o[WIDTH-1:0]`: Output signal representing the current value of the counter.
- `overflow_o`: Output signal indicating if the counter has overflowed.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba
// Description: Generic up/down counter

module counter #(
    parameter int unsigned WIDTH = 4,
    parameter bit STICKY_OVERFLOW = 1'b0
)(
    input  logic             clk_i,
    input  logic             rst_ni,
    input  logic             clear_i, // synchronous clear
    input  logic             en_i,    // enable the counter
    input  logic             load_i,  // load a new value
    input  logic             down_i,  // downcount, default is up
    input  logic [WIDTH-1:0] d_i,
    output logic [WIDTH-1:0] q_o,
    output logic             overflow_o
);
    delta_counter #(
        .WIDTH          (WIDTH),
        .STICKY_OVERFLOW (STICKY_OVERFLOW)
    ) i_counter (
        .clk_i,
        .rst_ni,
        .clear_i,
        .en_i,
        .load_i,
        .down_i,
        .delta_i({{WIDTH-1{1'b0}}, 1'b1}),
        .d_i,
        .q_o,
        .overflow_o
    );
endmodule
",counter.sv.txt,common_cells\counter.sv.txt
"[Keyword]: credit_counter.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a credit counter module that manages a system of credits. It keeps track of the number of available credits, allowing credits to be given or taken. The module can be initialized to a full or empty state and provides outputs indicating the current credit status, such as whether credits are available, critical (one credit away from full), or full.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the credit counter operations.
- `rst_ni`: Active-low reset signal to initialize or reset the credit counter.
- `credit_give_i`: Input signal to increase the credit count.
- `credit_take_i`: Input signal to decrease the credit count.
- `credit_init_i`: Input signal to reinitialize (soft-reset) the credit counter, taking priority over other operations.

[Output Signal Description]:
- `credit_o`: Output signal representing the current number of credits available.
- `credit_left_o`: Output signal indicating if there are any credits left (non-zero).
- `credit_crit_o`: Output signal indicating if the credit count is one less than full capacity.
- `credit_full_o`: Output signal indicating if the credit count has reached full capacity.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// Author: Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Author: Paul Scheffler <paulsc@iis.ee.ethz.ch>

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

module credit_counter #(
  parameter int unsigned NumCredits      = 0,
  /// Whether credit is full or empty on reset
  parameter bit          InitCreditEmpty = 1'b0,
  /// Derived parameters *Do not override*
  parameter int unsigned InitNumCredits  = InitCreditEmpty ? '0 : NumCredits,
  parameter type         credit_cnt_t    = logic [$clog2(NumCredits):0]
) (
  input  logic clk_i,
  input  logic rst_ni,

  output credit_cnt_t credit_o,

  input  logic credit_give_i,
  input  logic credit_take_i,
  input  logic credit_init_i,  // Reinitialize (soft-reset) credit; takes priority

  output logic credit_left_o,
  output logic credit_crit_o,  // Giving one more credit will fill the credits
  output logic credit_full_o
);

  credit_cnt_t credit_d, credit_q;
  logic increment, decrement;

  assign decrement = credit_take_i & ~credit_give_i;
  assign increment = ~credit_take_i & credit_give_i;

  always_comb begin
    credit_d = credit_q;
    if      (decrement) credit_d = credit_q - 1;
    else if (increment) credit_d = credit_q + 1;
  end

  `FFARNC(credit_q, credit_d, credit_init_i, InitNumCredits, clk_i, rst_ni)

  assign credit_o       = credit_q;
  assign credit_left_o  = (credit_q != '0);
  assign credit_crit_o  = (credit_q == NumCredits-1);
  assign credit_full_o  = (credit_q == NumCredits);

  `ASSERT_NEVER(CreditUnderflow, credit_o == '0 && decrement)
  `ASSERT_NEVER(CreditOverflow, credit_o == NumCredits && increment)

endmodule
",credit_counter.sv.txt,common_cells\credit_counter.sv.txt
"[Keyword]: delta_counter.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements an up/down counter with a variable delta. The counter can increment or decrement its value based on the `delta_i` input. It also features a sticky overflow option, which retains the overflow state until cleared or reloaded.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the counter operations.
- `rst_ni`: Active-low reset signal to initialize or reset the counter.
- `clear_i`: Synchronous clear signal to reset the counter value.
- `en_i`: Enable signal to allow the counter to count.
- `load_i`: Load signal to load a new value into the counter.
- `down_i`: Signal to determine the counting direction; if high, the counter decrements.
- `delta_i`: Input signal specifying the amount by which the counter should increment or decrement.
- `d_i`: Input signal specifying the value to load into the counter when `load_i` is active.

[Output Signal Description]:
- `q_o`: Output signal representing the current value of the counter.
- `overflow_o`: Output signal indicating whether the counter has overflowed.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Up/down counter with variable delta

module delta_counter #(
    parameter int unsigned WIDTH = 4,
    parameter bit STICKY_OVERFLOW = 1'b0
)(
    input  logic             clk_i,
    input  logic             rst_ni,
    input  logic             clear_i, // synchronous clear
    input  logic             en_i,    // enable the counter
    input  logic             load_i,  // load a new value
    input  logic             down_i,  // downcount, default is up
    input  logic [WIDTH-1:0] delta_i,
    input  logic [WIDTH-1:0] d_i,
    output logic [WIDTH-1:0] q_o,
    output logic             overflow_o
);
    logic [WIDTH:0] counter_q, counter_d;
    if (STICKY_OVERFLOW) begin : gen_sticky_overflow
        logic overflow_d, overflow_q;

        always_ff @(posedge clk_i or negedge rst_ni)
        begin
            if(!rst_ni) begin
                overflow_q <= 1'b0;
            end else begin
                overflow_q <= overflow_d;
            end
        end

        always_comb begin
            overflow_d = overflow_q;
            if (clear_i || load_i) begin
                overflow_d = 1'b0;
            end else if (!overflow_q && en_i) begin
                if (down_i) begin
                    overflow_d = delta_i > counter_q[WIDTH-1:0];
                end else begin
                    overflow_d = counter_q[WIDTH-1:0] > ({WIDTH{1'b1}} - delta_i);
                end
            end
        end
        assign overflow_o = overflow_q;
    end else begin : gen_transient_overflow
        // counter overflowed if the MSB is set
        assign overflow_o = counter_q[WIDTH];
    end
    assign q_o = counter_q[WIDTH-1:0];

    always_comb begin
        counter_d = counter_q;

        if (clear_i) begin
            counter_d = '0;
        end else if (load_i) begin
            counter_d = {1'b0, d_i};
        end else if (en_i) begin
            if (down_i) begin
                counter_d = counter_q - delta_i;
            end else begin
                counter_d = counter_q + delta_i;
            end
        end
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (!rst_ni) begin
           counter_q <= '0;
        end else begin
           counter_q <= counter_d;
        end
    end
endmodule
",delta_counter.sv.txt,common_cells\delta_counter.sv.txt
"[Keyword]: ecc_encode.sv

[Design Category]: Control Circuits

[Design Function Description]:
This design implements an ECC (Error Correction Code) encoder using SECDED (Single Error Correction, Double Error Detection) Hamming Code with an extended parity bit. The module takes an unencoded data word as input and encodes it to provide error detection and correction capabilities. The encoded output can be used to detect and correct single-bit errors and detect double-bit errors.

[Input Signal Description]:
data_i: This is the unencoded input data word. Its width is defined by the parameter `DataWidth`, which is set to 64 bits by default.

[Output Signal Description]:
data_o: This is the encoded output data. It is a structured type consisting of a parity bit and a code word. The code word is the expanded version of the input data with parity bits inserted for error correction and detection.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
/// # ECC Encoder
///
/// Implements SECDED (Single Error Correction, Double Error Detection) Hamming Code
/// with extended parity bit [1].
/// The module receives a data word and encodes it using above mentioned error
/// detection and correction code. The corresponding decode module
/// can be found in `ecc_decode.sv`
///
/// [1] https://en.wikipedia.org/wiki/Hamming_code

module ecc_encode import ecc_pkg::*; #(
  /// Data width of unencoded word.
  parameter  int unsigned DataWidth   = 64,
  // Do not change
  parameter type data_t         = logic [DataWidth-1:0],
  parameter type parity_t       = logic [get_parity_width(DataWidth)-1:0],
  parameter type code_word_t    = logic [get_cw_width(DataWidth)-1:0],
  parameter type encoded_data_t = struct packed {
                                    logic parity;
                                    code_word_t code_word;
                                  }
) (
  /// Unencoded data in
  input  data_t         data_i,
  /// Encoded data out
  output encoded_data_t data_o
);

  parity_t parity_code_word;
  code_word_t data, codeword;

  // Expand incoming data to codeword width
  always_comb begin : expand_data
    automatic int unsigned idx;
    data = '0;
    idx = 0;
    for (int unsigned i = 1; i < unsigned'($bits(code_word_t)) + 1; i++) begin
      // if it is not a power of two word it is a normal data index
      if (unsigned'(2**$clog2(i)) != i) begin
        data[i - 1] = data_i[idx];
        idx++;
      end
    end
  end

  // calculate code word
  always_comb begin : calculate_syndrome
    parity_code_word = 0;
    for (int unsigned i = 0; i < unsigned'($bits(parity_t)); i++) begin
      for (int unsigned j = 1; j < unsigned'($bits(code_word_t)) + 1; j++) begin
        if (|(unsigned'(2**i) & j)) parity_code_word[i] = parity_code_word[i] ^ data[j - 1];
      end
    end
  end

  // fuse the final codeword
  always_comb begin : generate_codeword
      codeword = data;
      for (int unsigned i = 0; i < unsigned'($bits(parity_t)); i++) begin
        codeword[2**i-1] = parity_code_word[i];
      end
  end

  assign data_o.code_word = codeword;
  assign data_o.parity = ^codeword;

endmodule
",ecc_encode.sv.txt,common_cells\ecc_encode.sv.txt
"[Keyword]: ecc_pkg.sv

[Design Category]: Control Circuits

[Design Function Description]:
This design provides functions to calculate the necessary parameters for implementing Error Correction Code (ECC) in digital systems. Specifically, it calculates the required parity width and codeword width for a given data width, which are essential for ECC encoding and decoding processes.

[Input Signal Description]:
- `data_width`: An integer input representing the width of the data for which ECC parameters are being calculated. It determines how many bits of data need to be protected by ECC.

[Output Signal Description]:
- `get_parity_width`: Returns the number of parity bits required for the given data width to ensure error detection and correction.
- `get_cw_width`: Returns the total codeword width, which includes the original data width plus the necessary parity bits for error correction.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
//
/// Contains common ECC definitions and helper functions.

package ecc_pkg;

  // Calculate required ECC parity width:
  function automatic int unsigned get_parity_width (input int unsigned data_width);
    // data_width + cw_width + 1 <= 2**cw_width
    int unsigned cw_width = 2;
    while (unsigned'(2**cw_width) < cw_width + data_width + 1) cw_width++;
    return cw_width;
  endfunction

  // Calculate required ECC codeword width:
  function automatic int unsigned get_cw_width (input int unsigned data_width);
    // data width + parity width + one additional parity bit (for double error detection)
    return data_width + get_parity_width(data_width);
  endfunction

endpackage
",ecc_pkg.sv.txt,common_cells\ecc_pkg.sv.txt
"[Keyword]: edge_detect.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is an edge detector circuit that identifies rising and falling edges in a data stream. It requires the clock signal to oversample the input data for accurate edge detection.

[Input Signal Description]:
- `clk_i`: Clock input signal used for synchronizing the edge detection process.
- `rst_ni`: Asynchronous reset signal, active low, used to reset the circuit.
- `d_i`: Data input signal, the stream in which edges are to be detected.

[Output Signal Description]:
- `re_o`: Output signal indicating the detection of a rising edge in the input data stream.
- `fe_o`: Output signal indicating the detection of a falling edge in the input data stream.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba
// Description: Edge detector, clock needs to oversample for proper edge detection

module edge_detect (
    input  logic clk_i,   // Clock
    input  logic rst_ni,  // Asynchronous reset active low
    input  logic d_i,     // data stream in
    output logic re_o,    // rising edge detected
    output logic fe_o     // falling edge detected
);

    sync_wedge i_sync_wedge (
        .clk_i    ( clk_i  ),
        .rst_ni   ( rst_ni ),
        .en_i     ( 1'b1   ),
        .serial_i ( d_i    ),
        .r_edge_o ( re_o   ),
        .f_edge_o ( fe_o   ),
        .serial_o (        )
    );

endmodule
",edge_detect.sv.txt,common_cells\edge_detect.sv.txt
"[Keyword]: edge_propagator.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The circuit is designed to propagate an edge signal from one clock domain to another. It ensures that a signal transition (edge) is reliably transferred between two asynchronous clock domains, which is a common requirement in systems where different parts operate on different clock frequencies.

[Input Signal Description]:
- `clk_tx_i`: Clock signal for the transmitting domain.
- `rstn_tx_i`: Active-low reset signal for the transmitting domain.
- `edge_i`: Input edge signal that needs to be propagated to the receiving domain.
- `clk_rx_i`: Clock signal for the receiving domain.
- `rstn_rx_i`: Active-low reset signal for the receiving domain.

[Output Signal Description]:
- `edge_o`: Output edge signal that has been propagated to the receiving domain.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module edge_propagator (
  input  logic clk_tx_i,
  input  logic rstn_tx_i,
  input  logic edge_i,
  input  logic clk_rx_i,
  input  logic rstn_rx_i,
  output logic edge_o
);

  edge_propagator_ack i_edge_propagator_ack (
    .clk_tx_i,
    .rstn_tx_i,
    .edge_i,
    .ack_tx_o (/* unused */),
    .clk_rx_i,
    .rstn_rx_i,
    .edge_o
  );

endmodule
",edge_propagator.sv.txt,common_cells\edge_propagator.sv.txt
"[Keyword]: edge_propagator_ack.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit is designed to propagate an edge signal from one clock domain to another while generating an acknowledgment signal. It uses synchronization techniques to ensure reliable communication between the two clock domains, preventing metastability issues.

[Input Signal Description]:
- `clk_tx_i`: Clock signal for the transmission domain.
- `rstn_tx_i`: Active-low reset signal for the transmission domain.
- `edge_i`: Input edge signal that needs to be propagated to the receiving domain.
- `clk_rx_i`: Clock signal for the receiving domain.
- `rstn_rx_i`: Active-low reset signal for the receiving domain.

[Output Signal Description]:
- `ack_tx_o`: Acknowledgment signal indicating the status of the edge propagation in the transmission domain.
- `edge_o`: Output edge signal in the receiving domain, synchronized to the receiving clock.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module edge_propagator_ack (
  input  logic clk_tx_i,
  input  logic rstn_tx_i,
  input  logic edge_i,
  output logic ack_tx_o,
  input  logic clk_rx_i,
  input  logic rstn_rx_i,
  output logic edge_o
);

  logic [1:0] sync_a;
  logic       sync_b;

  logic r_input_reg;
  logic s_input_reg_next;

  assign ack_tx_o = sync_a[0];

  assign s_input_reg_next = edge_i | (r_input_reg & ~sync_a[0]);

  always @(negedge rstn_tx_i or posedge clk_tx_i) begin
    if (~rstn_tx_i) begin
      r_input_reg <= 1'b0;
      sync_a      <= 2'b00;
    end else begin
      r_input_reg <= s_input_reg_next;
      sync_a      <= {sync_b,sync_a[1]};
    end
  end

  pulp_sync_wedge u_sync_clkb (
    .clk_i    ( clk_rx_i    ),
    .rstn_i   ( rstn_rx_i   ),
    .en_i     ( 1'b1        ),
    .serial_i ( r_input_reg ),
    .r_edge_o ( edge_o      ),
    .f_edge_o (             ),
    .serial_o ( sync_b      )
  );

endmodule
",edge_propagator_ack.sv.txt,common_cells\edge_propagator_ack.sv.txt
"[Keyword]: edge_propagator_rx.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is an edge propagator module that synchronizes an input signal (`valid_i`) to an output signal (`valid_o`) using a clock signal (`clk_i`). It acknowledges the input signal with an output signal (`ack_o`). The module uses a submodule `pulp_sync_wedge` to detect and propagate the rising edge of the input signal.

[Input Signal Description]:
- `clk_i`: Clock input signal used for synchronization.
- `rstn_i`: Active-low reset signal to initialize or reset the module.
- `valid_i`: Input signal whose rising edge is to be detected and propagated.

[Output Signal Description]:
- `ack_o`: Acknowledgment output signal indicating the input signal has been processed.
- `valid_o`: Output signal that reflects the rising edge of the input signal `valid_i`.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module edge_propagator_rx (
    input  logic clk_i,
    input  logic rstn_i,
    input  logic valid_i,
    output logic ack_o,
    output logic valid_o
);

    pulp_sync_wedge i_sync_clkb (
        .clk_i    ( clk_i   ),
        .rstn_i   ( rstn_i  ),
        .en_i     ( 1'b1    ),
        .serial_i ( valid_i ),
        .r_edge_o ( valid_o ),
        .f_edge_o (         ),
        .serial_o ( ack_o   )
    );

endmodule
",edge_propagator_rx.sv.txt,common_cells\edge_propagator_rx.sv.txt
"[Keyword]: edge_propagator_tx.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit is an edge propagator for a transmission system. It manages the propagation of a valid signal through a series of registers, synchronizing it with an acknowledgment signal. This design ensures that the valid signal is properly synchronized and propagated through the system, even in the presence of asynchronous reset conditions.

[Input Signal Description]:
- `clk_i`: Clock input signal used to synchronize the operations within the module.
- `rstn_i`: Active-low reset signal that initializes the internal registers to a known state.
- `valid_i`: Input signal indicating the validity of the data or condition to be propagated.
- `ack_i`: Acknowledgment input signal used to synchronize the valid signal with external conditions.

[Output Signal Description]:
- `valid_o`: Output signal that reflects the propagated and synchronized valid input signal, indicating the current state of the valid condition after processing.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module edge_propagator_tx (
    input  logic clk_i,
    input  logic rstn_i,
    input  logic valid_i,
    input  logic ack_i,
    output logic valid_o
);

    logic [1:0]   sync_a;

    logic    r_input_reg;
    logic    s_input_reg_next;

    assign s_input_reg_next = valid_i | (r_input_reg & ~sync_a[0]);

    always @(negedge rstn_i or posedge clk_i) begin
        if (~rstn_i) begin
            r_input_reg <= 1'b0;
            sync_a      <= 2'b00;
        end else begin
            r_input_reg <= s_input_reg_next;
            sync_a      <= {ack_i,sync_a[1]};
        end
    end

    assign valid_o = r_input_reg;

endmodule
",edge_propagator_tx.sv.txt,common_cells\edge_propagator_tx.sv.txt
"[Keyword]: exp_backoff.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design implements an exponential backoff counter with randomization. It uses a Linear Feedback Shift Register (LFSR) to generate random wait counts and exponentially increases the backoff time for each failed trial. The backoff counter is reset upon a successful trial.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the operations.
- `rst_ni`: Active-low reset signal to initialize the counter and LFSR.
- `set_i`: Input pulse signal to set the backoff counter when a trial fails.
- `clr_i`: Input pulse signal to clear the backoff counter when a trial succeeds.

[Output Signal Description]:
- `is_zero_o`: Output signal indicating whether the backoff counter has reached zero, allowing a new trial to be launched.


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
// Date: 10.04.2019
// Description: exponential backoff counter with randomization.
//
// For each failed trial (set_i pulsed), this unit exponentially increases the
// (average) backoff time by masking an LFSR with a shifted mask in order to
// create the backoff counter initial value.
//
// The shift register mask and the counter value are both reset to '0 in case of
// a successful trial (clr_i).
//

`include ""common_cells/assertions.svh""

module exp_backoff #(
  /// Seed for 16bit LFSR
  parameter int unsigned Seed   = 'hffff,
  /// 2**MaxExp-1 determines the maximum range from which random wait counts are drawn
  parameter int unsigned MaxExp = 16
) (
  input  logic clk_i,
  input  logic rst_ni,
  /// Sets the backoff counter (pulse) -> use when trial did not succeed
  input  logic set_i,
  /// Clears the backoff counter (pulse) -> use when trial succeeded
  input  logic clr_i,
  /// Indicates whether the backoff counter is equal to zero and a new trial can be launched
  output logic is_zero_o
);

  // leave this constant
  localparam int unsigned WIDTH = 16;

  logic [WIDTH-1:0] lfsr_d, lfsr_q, cnt_d, cnt_q, mask_d, mask_q;
  logic lfsr;

  // generate random wait counts
  // note: we use a flipped lfsr here to
  // avoid strange correlation effects between
  // the (left-shifted) mask and the lfsr
  assign lfsr = lfsr_q[15-15] ^
                lfsr_q[15-13] ^
                lfsr_q[15-12] ^
                lfsr_q[15-10];

  assign lfsr_d = (set_i) ? {lfsr, lfsr_q[$high(lfsr_q):1]} :
                            lfsr_q;

  // mask the wait counts with exponentially increasing mask (shift reg)
  assign mask_d = (clr_i) ? '0                                :
                  (set_i) ? {{(WIDTH-MaxExp){1'b0}},mask_q[MaxExp-2:0], 1'b1} :
                            mask_q;

  assign cnt_d =  (clr_i)      ? '0                :
                  (set_i)      ? (mask_q & lfsr_q) :
                  (!is_zero_o) ? cnt_q - 1'b1      : '0;

  assign is_zero_o = (cnt_q=='0);

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      lfsr_q <= WIDTH'(Seed);
      mask_q <= '0;
      cnt_q  <= '0;
    end else begin
      lfsr_q <= lfsr_d;
      mask_q <= mask_d;
      cnt_q  <= cnt_d;
    end
  end

///////////////////////////////////////////////////////
// assertions
///////////////////////////////////////////////////////

`ifndef COMMON_CELLS_ASSERTS_OFF
  // assert wrong parameterizations
  `ASSERT_INIT(max_exp_0, MaxExp>0, ""MaxExp must be greater than 0"")
  `ASSERT_INIT(max_exp_gt_16, MaxExp<=16, ""MaxExp cannot be greater than 16"")
  `ASSERT_INIT(seed_0, Seed>0, ""Zero seed is not allowed for LFSR"")
`endif

endmodule // exp_backoff
",exp_backoff.sv.txt,common_cells\exp_backoff.sv.txt
"[Keyword]: fall_through_register.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a fall-through register with a simple stream-like ready/valid handshake mechanism. It is used to manage data flow between modules by providing a 'default ready' behavior towards the input. The register does not cut the combinatorial path on the valid and data signals but does so on the ready signal. It forwards data if the output module is ready to accept it within the same clock cycle.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the register operations.
- `rst_ni`: Asynchronous active-low reset signal to initialize the register.
- `clr_i`: Synchronous clear signal to flush the register.
- `testmode_i`: Test mode signal to bypass clock gating for testing purposes.
- `valid_i`: Input signal indicating that the input data is valid.
- `data_i`: Input data of type `T` to be stored in the register.
- `ready_i`: Signal from the output module indicating readiness to accept data.

[Output Signal Description]:
- `ready_o`: Output signal indicating that the register is ready to accept new data.
- `valid_o`: Output signal indicating that the data output is valid.
- `data_o`: Output data of type `T` from the register.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Fall-through register with a simple stream-like ready/valid handshake.
// This register does not cut the combinatorial path on the valid and data signals.
// It only cuts the combinatorial path on the ready signal.
// In case the module at its output is ready to accept data within the same clock cycle, they are forwarded.
// Use this module to get a 'default ready' behavior towards the input.
module fall_through_register #(
    parameter type T = logic  // Vivado requires a default value for type parameters.
) (
    input  logic    clk_i,          // Clock
    input  logic    rst_ni,         // Asynchronous active-low reset
    input  logic    clr_i,          // Synchronous clear
    input  logic    testmode_i,     // Test mode to bypass clock gating
    // Input port
    input  logic    valid_i,
    output logic    ready_o,
    input  T        data_i,
    // Output port
    output logic    valid_o,
    input  logic    ready_i,
    output T        data_o
);

    logic   fifo_empty,
            fifo_full;

    fifo_v3 #(
        .FALL_THROUGH   (1'b1),
        .DEPTH          (1),
        .dtype          (T)
    ) i_fifo (
        .clk_i          (clk_i),
        .rst_ni         (rst_ni),
        .flush_i        (clr_i),
        .testmode_i     (testmode_i),
        .full_o         (fifo_full),
        .empty_o        (fifo_empty),
        .usage_o        (),
        .data_i         (data_i),
        .push_i         (valid_i & ~fifo_full),
        .data_o         (data_o),
        .pop_i          (ready_i & ~fifo_empty)
    );

    assign ready_o = ~fifo_full;
    assign valid_o = ~fifo_empty;

endmodule
",fall_through_register.sv.txt,common_cells\fall_through_register.sv.txt
"[Keyword]: fifo_v1.sv

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements a FIFO (First-In-First-Out) queue with configurable parameters such as data width, depth, and threshold. The FIFO can operate in fall-through mode, where data can be immediately available at the output after being pushed. It provides status flags to indicate whether the queue is full, empty, or above a specified threshold.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the FIFO operations.
- `rst_ni`: Asynchronous reset signal, active low, to reset the FIFO.
- `flush_i`: Signal to flush the queue, clearing its contents.
- `testmode_i`: Signal to enable test mode, potentially bypassing clock gating.
- `data_i`: Input data to be pushed into the FIFO.
- `push_i`: Signal indicating that the input data is valid and can be pushed into the FIFO.
- `pop_i`: Signal to pop the head element from the queue.

[Output Signal Description]:
- `full_o`: Signal indicating that the FIFO is full and cannot accept more data.
- `empty_o`: Signal indicating that the FIFO is empty and no data can be popped.
- `threshold_o`: Signal indicating that the FIFO has reached or exceeded the specified threshold level.
- `data_o`: Output data from the FIFO, representing the head of the queue.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>

/* verilator lint_off DECLFILENAME */
module fifo #(
    parameter bit          FALL_THROUGH = 1'b0, // fifo is in fall-through mode
    parameter int unsigned DATA_WIDTH   = 32,   // default data width if the fifo is of type logic
    parameter int unsigned DEPTH        = 8,    // depth can be arbitrary from 0 to 2**32
    parameter int unsigned THRESHOLD    = 1,    // fill count until when to assert threshold_o
    parameter type dtype                = logic [DATA_WIDTH-1:0]
)(
    input  logic  clk_i,            // Clock
    input  logic  rst_ni,           // Asynchronous reset active low
    input  logic  flush_i,          // flush the queue
    input  logic  testmode_i,       // test_mode to bypass clock gating
    // status flags
    output logic  full_o,           // queue is full
    output logic  empty_o,          // queue is empty
    output logic  threshold_o,      // the FIFO is above the specified threshold
    // as long as the queue is not full we can push new data
    input  dtype  data_i,           // data to push into the queue
    input  logic  push_i,           // data is valid and can be pushed to the queue
    // as long as the queue is not empty we can pop new elements
    output dtype  data_o,           // output data
    input  logic  pop_i             // pop head from queue
);
    fifo_v2 #(
        .FALL_THROUGH ( FALL_THROUGH ),
        .DATA_WIDTH   ( DATA_WIDTH   ),
        .DEPTH        ( DEPTH        ),
        .ALM_FULL_TH  ( THRESHOLD    ),
        .dtype        ( dtype        )
    ) impl (
        .clk_i       ( clk_i       ),
        .rst_ni      ( rst_ni      ),
        .flush_i     ( flush_i     ),
        .testmode_i  ( testmode_i  ),
        .full_o      ( full_o      ),
        .empty_o     ( empty_o     ),
        .alm_full_o  ( threshold_o ),
        .alm_empty_o (             ),
        .data_i      ( data_i      ),
        .push_i      ( push_i      ),
        .data_o      ( data_o      ),
        .pop_i       ( pop_i       )
    );
endmodule
/* verilator lint_on DECLFILENAME */
",fifo_v1.sv.txt,common_cells\fifo_v1.sv.txt
"[Keyword]: fifo_v2.sv

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements a FIFO (First-In-First-Out) queue with configurable parameters such as data width, depth, and almost full/empty thresholds. The FIFO can operate in fall-through mode and supports flush and test modes. It provides status flags to indicate full, empty, almost full, and almost empty states.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the FIFO operations.
- `rst_ni`: Asynchronous reset signal, active low, to reset the FIFO.
- `flush_i`: Signal to flush the queue, clearing its contents.
- `testmode_i`: Signal to enable test mode, bypassing clock gating.
- `data_i`: Data input to be pushed into the FIFO.
- `push_i`: Signal indicating that the data is valid and can be pushed into the FIFO.
- `pop_i`: Signal to pop the head element from the FIFO.

[Output Signal Description]:
- `full_o`: Indicates that the FIFO is full and cannot accept more data.
- `empty_o`: Indicates that the FIFO is empty and no data can be popped.
- `alm_full_o`: Indicates that the FIFO fill state is greater than or equal to the almost full threshold.
- `alm_empty_o`: Indicates that the FIFO fill state is less than or equal to the almost empty threshold.
- `data_o`: Data output from the FIFO, representing the head of the queue.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>

module fifo_v2 #(
    parameter bit          FALL_THROUGH = 1'b0, // fifo is in fall-through mode
    parameter int unsigned DATA_WIDTH   = 32,   // default data width if the fifo is of type logic
    parameter int unsigned DEPTH        = 8,    // depth can be arbitrary from 0 to 2**32
    parameter int unsigned ALM_EMPTY_TH = 1,    // almost empty threshold (when to assert alm_empty_o)
    parameter int unsigned ALM_FULL_TH  = 1,    // almost full threshold (when to assert alm_full_o)
    parameter type dtype                = logic [DATA_WIDTH-1:0],
    // DO NOT OVERWRITE THIS PARAMETER
    parameter int unsigned ADDR_DEPTH   = (DEPTH > 1) ? $clog2(DEPTH) : 1
)(
    input  logic  clk_i,            // Clock
    input  logic  rst_ni,           // Asynchronous reset active low
    input  logic  flush_i,          // flush the queue
    input  logic  testmode_i,       // test_mode to bypass clock gating
    // status flags
    output logic  full_o,           // queue is full
    output logic  empty_o,          // queue is empty
    output logic  alm_full_o,       // FIFO fillstate >= the specified threshold
    output logic  alm_empty_o,      // FIFO fillstate <= the specified threshold
    // as long as the queue is not full we can push new data
    input  dtype  data_i,           // data to push into the queue
    input  logic  push_i,           // data is valid and can be pushed to the queue
    // as long as the queue is not empty we can pop new elements
    output dtype  data_o,           // output data
    input  logic  pop_i             // pop head from queue
);

    logic [ADDR_DEPTH-1:0] usage;

    // generate threshold parameters
    if (DEPTH == 0) begin
        assign alm_full_o  = 1'b0; // that signal does not make any sense in a FIFO of depth 0
        assign alm_empty_o = 1'b0; // that signal does not make any sense in a FIFO of depth 0
    end else begin
        assign alm_full_o   = (usage >= ALM_FULL_TH[ADDR_DEPTH-1:0]);
        assign alm_empty_o  = (usage <= ALM_EMPTY_TH[ADDR_DEPTH-1:0]);
    end

    fifo_v3 #(
        .FALL_THROUGH ( FALL_THROUGH ),
        .DATA_WIDTH   ( DATA_WIDTH   ),
        .DEPTH        ( DEPTH        ),
        .dtype        ( dtype        )
    ) i_fifo_v3 (
        .clk_i,
        .rst_ni,
        .flush_i,
        .testmode_i,
        .full_o,
        .empty_o,
        .usage_o (usage),
        .data_i,
        .push_i,
        .data_o,
        .pop_i
    );

    `ifndef SYNTHESIS
    `ifndef COMMON_CELLS_ASSERTS_OFF
        initial begin
            assert (ALM_FULL_TH <= DEPTH)  else $error(""ALM_FULL_TH can't be larger than the DEPTH."");
            assert (ALM_EMPTY_TH <= DEPTH) else $error(""ALM_EMPTY_TH can't be larger than the DEPTH."");
        end
    `endif
    `endif

endmodule // fifo_v2
",fifo_v2.sv.txt,common_cells\fifo_v2.sv.txt
"[Keyword]: fifo_v3.sv

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements a FIFO (First-In-First-Out) queue with configurable depth and data width. It supports both normal and fall-through modes, allowing data to be pushed into the queue when it is not full and popped from the queue when it is not empty. The FIFO can be flushed, and it provides status flags to indicate whether it is full or empty, as well as the current usage level.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the FIFO operations.
- `rst_ni`: Asynchronous reset signal, active low, to reset the FIFO.
- `flush_i`: Signal to flush the queue, resetting pointers and status.
- `testmode_i`: Test mode signal to bypass clock gating.
- `data_i`: Data input to be pushed into the FIFO.
- `push_i`: Signal indicating that the data input is valid and can be pushed into the FIFO.
- `pop_i`: Signal indicating that the head of the queue should be popped.

[Output Signal Description]:
- `full_o`: Status flag indicating that the FIFO is full.
- `empty_o`: Status flag indicating that the FIFO is empty.
- `usage_o`: Output indicating the current fill level of the FIFO.
- `data_o`: Data output from the FIFO, representing the head of the queue.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

module fifo_v3 #(
    parameter bit          FALL_THROUGH = 1'b0, // fifo is in fall-through mode
    parameter int unsigned DATA_WIDTH   = 32,   // default data width if the fifo is of type logic
    parameter int unsigned DEPTH        = 8,    // depth can be arbitrary from 0 to 2**32
    parameter type dtype                = logic [DATA_WIDTH-1:0],
    // DO NOT OVERWRITE THIS PARAMETER
    parameter int unsigned ADDR_DEPTH   = (DEPTH > 1) ? $clog2(DEPTH) : 1
)(
    input  logic  clk_i,            // Clock
    input  logic  rst_ni,           // Asynchronous reset active low
    input  logic  flush_i,          // flush the queue
    input  logic  testmode_i,       // test_mode to bypass clock gating
    // status flags
    output logic  full_o,           // queue is full
    output logic  empty_o,          // queue is empty
    output logic  [ADDR_DEPTH-1:0] usage_o,  // fill pointer
    // as long as the queue is not full we can push new data
    input  dtype  data_i,           // data to push into the queue
    input  logic  push_i,           // data is valid and can be pushed to the queue
    // as long as the queue is not empty we can pop new elements
    output dtype  data_o,           // output data
    input  logic  pop_i             // pop head from queue
);
    // local parameter
    // FIFO depth - handle the case of pass-through, synthesizer will do constant propagation
    localparam int unsigned FifoDepth = (DEPTH > 0) ? DEPTH : 1;
    // clock gating control
    logic gate_clock;
    // pointer to the read and write section of the queue
    logic [ADDR_DEPTH - 1:0] read_pointer_n, read_pointer_q, write_pointer_n, write_pointer_q;
    // keep a counter to keep track of the current queue status
    // this integer will be truncated by the synthesis tool
    logic [ADDR_DEPTH:0] status_cnt_n, status_cnt_q;
    // actual memory
    dtype [FifoDepth - 1:0] mem_n, mem_q;

    assign usage_o = status_cnt_q[ADDR_DEPTH-1:0];

    if (DEPTH == 0) begin : gen_pass_through
        assign empty_o     = ~push_i;
        assign full_o      = ~pop_i;
    end else begin : gen_fifo
        assign full_o       = (status_cnt_q == FifoDepth[ADDR_DEPTH:0]);
        assign empty_o      = (status_cnt_q == 0) & ~(FALL_THROUGH & push_i);
    end
    // status flags

    // read and write queue logic
    always_comb begin : read_write_comb
        // default assignment
        read_pointer_n  = read_pointer_q;
        write_pointer_n = write_pointer_q;
        status_cnt_n    = status_cnt_q;
        data_o          = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];
        mem_n           = mem_q;
        gate_clock      = 1'b1;

        // push a new element to the queue
        if (push_i && ~full_o) begin
            // push the data onto the queue
            mem_n[write_pointer_q] = data_i;
            // un-gate the clock, we want to write something
            gate_clock = 1'b0;
            // increment the write counter
            // this is dead code when DEPTH is a power of two
            if (write_pointer_q == FifoDepth[ADDR_DEPTH-1:0] - 1)
                write_pointer_n = '0;
            else
                write_pointer_n = write_pointer_q + 1;
            // increment the overall counter
            status_cnt_n    = status_cnt_q + 1;
        end

        if (pop_i && ~empty_o) begin
            // read from the queue is a default assignment
            // but increment the read pointer...
            // this is dead code when DEPTH is a power of two
            if (read_pointer_n == FifoDepth[ADDR_DEPTH-1:0] - 1)
                read_pointer_n = '0;
            else
                read_pointer_n = read_pointer_q + 1;
            // ... and decrement the overall count
            status_cnt_n   = status_cnt_q - 1;
        end

        // keep the count pointer stable if we push and pop at the same time
        if (push_i && pop_i &&  ~full_o && ~empty_o)
            status_cnt_n   = status_cnt_q;

        // FIFO is in pass through mode -> do not change the pointers
        if (FALL_THROUGH && (status_cnt_q == 0) && push_i) begin
            data_o = data_i;
            if (pop_i) begin
                status_cnt_n = status_cnt_q;
                read_pointer_n = read_pointer_q;
                write_pointer_n = write_pointer_q;
            end
        end
    end

    // sequential process
    always_ff @(posedge clk_i or negedge rst_ni) begin
        if(~rst_ni) begin
            read_pointer_q  <= '0;
            write_pointer_q <= '0;
            status_cnt_q    <= '0;
        end else begin
            if (flush_i) begin
                read_pointer_q  <= '0;
                write_pointer_q <= '0;
                status_cnt_q    <= '0;
             end else begin
                read_pointer_q  <= read_pointer_n;
                write_pointer_q <= write_pointer_n;
                status_cnt_q    <= status_cnt_n;
            end
        end
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin
        if(~rst_ni) begin
            mem_q <= {FifoDepth{dtype'('0)}};
        end else if (!gate_clock) begin
            mem_q <= mem_n;
        end
    end

`ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(depth_0, DEPTH > 0, ""DEPTH must be greater than 0."")

    `ASSERT(full_write, full_o |-> ~push_i, clk_i, !rst_ni,
            ""Trying to push new data although the FIFO is full."")

    `ASSERT(empty_read, empty_o |-> ~pop_i, clk_i, !rst_ni,
            ""Trying to pop data although the FIFO is empty."")
`endif

endmodule // fifo_v3
",fifo_v3.sv.txt,common_cells\fifo_v3.sv.txt
"[Keyword]: find_first_one.sv

[Design Category]: Combinational Logic

[Design Function Description]:
The module is a leading-one finder or leading zero counter. It determines the position of the first '1' bit in an input vector or counts the number of leading zeros, depending on the parameter FLIP. If FLIP is set to 0, the module outputs the index of the first '1' from the least significant bit (LSB). If FLIP is set to 1, it counts the number of leading zeros from the most significant bit (MSB).

[Input Signal Description]:
- `in_i[WIDTH-1:0]`: The input vector whose leading '1' or leading zeros are to be found. The width of this vector is determined by the parameter WIDTH.

[Output Signal Description]:
- `first_one_o[$clog2(WIDTH)-1:0]`: Outputs the index of the first '1' bit if FLIP is 0, or the count of leading zeros if FLIP is 1.
- `no_ones_o`: A flag that indicates if there are no '1's in the input vector. It is set to 1 if there are no '1's, otherwise 0.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Deprecated, use lzc unit instead.

/// A leading-one finder / leading zero counter.
/// Set FLIP to 0 for find_first_one => first_one_o is the index of the first one (from the LSB)
/// Set FLIP to 1 for leading zero counter => first_one_o is the number of leading zeroes (from the MSB)
module find_first_one #(
    /// The width of the input vector.
    parameter int WIDTH = -1,
    parameter int FLIP = 0
)(
    input  logic [WIDTH-1:0]         in_i,
    output logic [$clog2(WIDTH)-1:0] first_one_o,
    output logic                     no_ones_o
);

    localparam int NUM_LEVELS = $clog2(WIDTH);

    `ifndef SYNTHESIS
    initial begin
        assert(WIDTH >= 0);
    end
    `endif

    logic [WIDTH-1:0][NUM_LEVELS-1:0]          index_lut;
    logic [2**NUM_LEVELS-1:0]                  sel_nodes;
    logic [2**NUM_LEVELS-1:0][NUM_LEVELS-1:0]  index_nodes;

    logic [WIDTH-1:0] in_tmp;

    for (genvar i = 0; i < WIDTH; i++) begin
        assign in_tmp[i] = FLIP ? in_i[WIDTH-1-i] : in_i[i];
    end

    for (genvar j = 0; j < WIDTH; j++) begin
        assign index_lut[j] = j;
    end

    for (genvar level = 0; level < NUM_LEVELS; level++) begin

        if (level < NUM_LEVELS-1) begin
            for (genvar l = 0; l < 2**level; l++) begin
                assign sel_nodes[2**level-1+l]   = sel_nodes[2**(level+1)-1+l*2] | sel_nodes[2**(level+1)-1+l*2+1];
                assign index_nodes[2**level-1+l] = (sel_nodes[2**(level+1)-1+l*2] == 1'b1) ?
                    index_nodes[2**(level+1)-1+l*2] : index_nodes[2**(level+1)-1+l*2+1];
            end
        end

        if (level == NUM_LEVELS-1) begin
            for (genvar k = 0; k < 2**level; k++) begin
                // if two successive indices are still in the vector...
                if (k * 2 < WIDTH-1) begin
                    assign sel_nodes[2**level-1+k]   = in_tmp[k*2] | in_tmp[k*2+1];
                    assign index_nodes[2**level-1+k] = (in_tmp[k*2] == 1'b1) ? index_lut[k*2] : index_lut[k*2+1];
                end
                // if only the first index is still in the vector...
                if (k * 2 == WIDTH-1) begin
                    assign sel_nodes[2**level-1+k]   = in_tmp[k*2];
                    assign index_nodes[2**level-1+k] = index_lut[k*2];
                end
                // if index is out of range
                if (k * 2 > WIDTH-1) begin
                    assign sel_nodes[2**level-1+k]   = 1'b0;
                    assign index_nodes[2**level-1+k] = '0;
                end
            end
        end
    end

    assign first_one_o = NUM_LEVELS > 0 ? index_nodes[0] : '0;
    assign no_ones_o   = NUM_LEVELS > 0 ? ~sel_nodes[0]  : '1;

endmodule
",find_first_one.sv.txt,common_cells\find_first_one.sv.txt
"[Keyword]: generic_fifo.sv

[Design Category]: Memory Circuits

[Design Function Description]:
The design is a generic FIFO (First-In-First-Out) buffer used to store data temporarily. It is utilized in the D_address_decoder and D_allocator to manage destination ports. The FIFO allows data to be written (pushed) and read (popped) in a sequential manner, maintaining the order of data as it was input.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the FIFO.
- `data_i`: Input data to be stored in the FIFO, with a width defined by the parameter `DATA_WIDTH`.
- `valid_i`: Indicates when the input data is valid and ready to be written into the FIFO.
- `grant_i`: Signal from the consumer indicating readiness to accept data from the FIFO.
- `test_mode_i`: Signal to enable test mode, affecting clock gating.

[Output Signal Description]:
- `grant_o`: Signal indicating the FIFO is ready to accept new data.
- `data_o`: Output data from the FIFO, with a width defined by the parameter `DATA_WIDTH`.
- `valid_o`: Indicates when the output data is valid and ready to be read from the FIFO.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// ============================================================================= //
// Company:        Multitherman Laboratory @ DEIS - University of Bologna        //
//                    Viale Risorgimento 2 40136                                 //
//                    Bologna - fax 0512093785 -                                 //
//                                                                               //
// Engineer:       Igor Loi - igor.loi@unibo.it                                  //
//                                                                               //
//                                                                               //
// Additional contributions by:                                                  //
//                                                                               //
//                                                                               //
//                                                                               //
// Create Date:    01/02/2014                                                    //
// Design Name:    MISC                                                          //
// Module Name:    generic_fifo                                                  //
// Project Name:   PULP                                                          //
// Language:       SystemVerilog                                                 //
//                                                                               //
// Description:   A simple FIFO used in the D_address_decoder, and D_allocator   //
//                to store the destinations ports                                //
//                                                                               //
// Revision:                                                                     //
// Revision v0.1 - 01/02/2014 : File Created                                     //
// Revision v0.2 - 02/09/2015 : Updated with a global CG cell                    //
//                                                                               //
// ============================================================================= //

module generic_fifo
#(
   parameter int unsigned          DATA_WIDTH = 32,
   parameter int unsigned          DATA_DEPTH = 8
)
(
   input  logic                                    clk,
   input  logic                                    rst_n,
   //PUSH SIDE
   input  logic [DATA_WIDTH-1:0]                   data_i,
   input  logic                                    valid_i,
   output logic                                    grant_o,
   //POP SIDE
   output logic [DATA_WIDTH-1:0]                   data_o,
   output logic                                    valid_o,
   input  logic                                    grant_i,

   input  logic                                    test_mode_i
);


   // Local Parameter
   localparam int unsigned ADDR_DEPTH = $clog2(DATA_DEPTH);
   enum logic [1:0] { EMPTY, FULL, MIDDLE } CS, NS;
   // Internal Signals

   logic       gate_clock;
   logic       clk_gated;

   logic [ADDR_DEPTH-1:0]  Pop_Pointer_CS,  Pop_Pointer_NS;
   logic [ADDR_DEPTH-1:0]  Push_Pointer_CS, Push_Pointer_NS;
   logic [DATA_WIDTH-1:0]  FIFO_REGISTERS[DATA_DEPTH-1:0];
   int unsigned            i;

   // Parameter Check
   `ifndef SYNTHESIS
   initial begin : parameter_check
      integer param_err_flg;
      param_err_flg = 0;

      if (DATA_WIDTH < 1) begin
         param_err_flg = 1;
         $display(""ERROR: %m :\n  Invalid value (%d) for parameter DATA_WIDTH (legal range: greater than 1)"", DATA_WIDTH );
      end

      if (DATA_DEPTH < 1) begin
         param_err_flg = 1;
         $display(""ERROR: %m :\n  Invalid value (%d) for parameter DATA_DEPTH (legal range: greater than 1)"", DATA_DEPTH );
      end
   end
   `endif

`ifndef PULP_FPGA_EMUL
   cluster_clock_gating cg_cell
   (
     .clk_i     ( clk         ),
     .en_i      (~gate_clock  ),
     .test_en_i ( test_mode_i ),
     .clk_o     ( clk_gated   )
   );
`else
   assign clk_gated = clk;
`endif

   // UPDATE THE STATE
   always_ff @(posedge clk, negedge rst_n)
   begin
       if(rst_n == 1'b0)
       begin
               CS              <= EMPTY;
               Pop_Pointer_CS  <= {ADDR_DEPTH {1'b0}};
               Push_Pointer_CS <= {ADDR_DEPTH {1'b0}};
       end
       else
       begin
               CS              <= NS;
               Pop_Pointer_CS  <= Pop_Pointer_NS;
               Push_Pointer_CS <= Push_Pointer_NS;
       end
   end


   // Compute Next State
   always_comb
   begin
      gate_clock      = 1'b0;

      case(CS)

      EMPTY:
      begin
          grant_o = 1'b1;
          valid_o = 1'b0;

          case(valid_i)
          1'b0 :
          begin
                  NS              = EMPTY;
                  Push_Pointer_NS = Push_Pointer_CS;
                  Pop_Pointer_NS  = Pop_Pointer_CS;
                  gate_clock      = 1'b1;
          end

          1'b1:
          begin
                  NS              = MIDDLE;
                  Push_Pointer_NS = Push_Pointer_CS + 1'b1;
                  Pop_Pointer_NS  = Pop_Pointer_CS;
          end

          endcase
      end//~EMPTY

      MIDDLE:
      begin
          grant_o = 1'b1;
          valid_o = 1'b1;

          case({valid_i,grant_i})

          2'b01:
          begin
                  gate_clock      = 1'b1;

                  if((Pop_Pointer_CS == Push_Pointer_CS -1 ) || ((Pop_Pointer_CS == DATA_DEPTH-1) && (Push_Pointer_CS == 0) ))
                          NS              = EMPTY;
                  else
                          NS              = MIDDLE;

                  Push_Pointer_NS = Push_Pointer_CS;

                  if(Pop_Pointer_CS == DATA_DEPTH-1)
                          Pop_Pointer_NS  = 0;
                  else
                          Pop_Pointer_NS  = Pop_Pointer_CS + 1'b1;
          end

          2'b00 :
          begin
                  gate_clock      = 1'b1;
                  NS              = MIDDLE;
                  Push_Pointer_NS = Push_Pointer_CS;
                  Pop_Pointer_NS  = Pop_Pointer_CS;
          end

          2'b11:
          begin
                  NS              = MIDDLE;

                  if(Push_Pointer_CS == DATA_DEPTH-1)
                          Push_Pointer_NS = 0;
                  else
                          Push_Pointer_NS = Push_Pointer_CS + 1'b1;

                  if(Pop_Pointer_CS == DATA_DEPTH-1)
                          Pop_Pointer_NS  = 0;
                  else
                          Pop_Pointer_NS  = Pop_Pointer_CS  + 1'b1;
          end

          2'b10:
          begin
                  if(( Push_Pointer_CS == Pop_Pointer_CS - 1) || ( (Push_Pointer_CS == DATA_DEPTH-1) && (Pop_Pointer_CS == 0) ))
                          NS              = FULL;
                  else
                          NS        = MIDDLE;

                  if(Push_Pointer_CS == DATA_DEPTH - 1)
                          Push_Pointer_NS = 0;
                  else
                          Push_Pointer_NS = Push_Pointer_CS + 1'b1;

                  Pop_Pointer_NS  = Pop_Pointer_CS;
          end

          endcase
      end

      FULL:
      begin
          grant_o     = 1'b0;
          valid_o     = 1'b1;
          gate_clock  = 1'b1;

          case(grant_i)
          1'b1:
          begin
                  NS              = MIDDLE;

                  Push_Pointer_NS = Push_Pointer_CS;

                  if(Pop_Pointer_CS == DATA_DEPTH-1)
                          Pop_Pointer_NS  = 0;
                  else
                          Pop_Pointer_NS  = Pop_Pointer_CS  + 1'b1;
          end

          1'b0:
          begin
                  NS              = FULL;
                  Push_Pointer_NS = Push_Pointer_CS;
                  Pop_Pointer_NS  = Pop_Pointer_CS;
          end
          endcase

      end // end of FULL

      default :
      begin
          gate_clock      = 1'b1;
          grant_o         = 1'b0;
          valid_o         = 1'b0;
          NS              = EMPTY;
          Pop_Pointer_NS  = 0;
          Push_Pointer_NS = 0;
      end

      endcase
   end

   always_ff @(posedge clk_gated, negedge rst_n)
   begin
      if(rst_n == 1'b0)
      begin
      for (i=0; i< DATA_DEPTH; i++)
         FIFO_REGISTERS[i] <= {DATA_WIDTH {1'b0}};
      end
      else
      begin
         if((grant_o == 1'b1) && (valid_i == 1'b1))
            FIFO_REGISTERS[Push_Pointer_CS] <= data_i;
      end
   end

   assign data_o = FIFO_REGISTERS[Pop_Pointer_CS];

endmodule // generic_fifo
",generic_fifo.sv.txt,common_cells\generic_fifo.sv.txt
"[Keyword]: generic_fifo_adv.sv

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements a generic FIFO (First-In-First-Out) buffer with advanced features. It allows for data to be written to the buffer (pushed) and read from the buffer (popped) in a sequential manner. The FIFO can handle variable data widths and depths, as specified by the parameters `DATA_WIDTH` and `DATA_DEPTH`. It includes state management to handle empty, middle, and full states, and uses clock gating for power efficiency.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the FIFO.
- `clear_i`: Signal to clear the FIFO contents.
- `data_i`: Input data to be written into the FIFO, with a width defined by `DATA_WIDTH`.
- `valid_i`: Signal indicating that the input data is valid and ready to be written into the FIFO.
- `grant_i`: Signal indicating that the output data has been successfully read and the FIFO can proceed to the next data.
- `test_mode_i`: Signal for enabling test mode, affecting clock gating behavior.

[Output Signal Description]:
- `grant_o`: Signal indicating that the FIFO is ready to accept new data.
- `data_o`: Output data read from the FIFO, with a width defined by `DATA_WIDTH`.
- `valid_o`: Signal indicating that the output data is valid and ready to be read.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Igor Loi <igor.loi@unibo.it>

module generic_fifo_adv 
#( 
   parameter int unsigned          DATA_WIDTH = 32,
   parameter int unsigned          DATA_DEPTH = 8
   )
   (
    input  logic                                    clk,
    input  logic                                    rst_n,
    input  logic                                    clear_i,
    
    //PUSH SIDE
    input  logic [DATA_WIDTH-1:0]                   data_i,
    input  logic                                    valid_i,
    output logic                                    grant_o,
    
    //POP SIDE
    output logic [DATA_WIDTH-1:0]                   data_o,
    output logic                                    valid_o,
    input  logic                                    grant_i,
    
    input  logic                                    test_mode_i
    );
   
   
   // Local Parameter
   localparam  int 				    unsigned ADDR_DEPTH = $clog2(DATA_DEPTH);
   enum 					    logic [1:0] { EMPTY, FULL, MIDDLE } CS, NS;
   // Internal Signals
   
   logic 					    gate_clock;
   logic 					    clk_gated;
   
   logic [ADDR_DEPTH-1:0] 			    Pop_Pointer_CS,  Pop_Pointer_NS;
   logic [ADDR_DEPTH-1:0] 			    Push_Pointer_CS, Push_Pointer_NS;
   logic [DATA_WIDTH-1:0] 			    FIFO_REGISTERS[DATA_DEPTH-1:0];
   int 						    unsigned                    i;
   
   // Parameter Check
   `ifndef SYNTHESIS
   initial
   begin : parameter_check
      integer param_err_flg;
      param_err_flg = 0;
      
      if (DATA_WIDTH < 1)
	begin
           param_err_flg = 1;
           $display(""ERROR: %m :\n  Invalid value (%d) for parameter DATA_WIDTH (legal range: greater than 1)"", DATA_WIDTH );
	end
      
      if (DATA_DEPTH < 1)
	begin
           param_err_flg = 1;
           $display(""ERROR: %m :\n  Invalid value (%d) for parameter DATA_DEPTH (legal range: greater than 1)"", DATA_DEPTH );
	end                   
   end
   `endif
   
`ifndef PULP_FPGA_EMUL
   cluster_clock_gating cg_cell
     (
      .clk_i     ( clk         ),
      .en_i      (~gate_clock  ),
      .test_en_i ( test_mode_i ),
      .clk_o     ( clk_gated   )
      );
`else
   assign clk_gated = clk;
`endif
   
   // UPDATE THE STATE
   always_ff @(posedge clk, negedge rst_n)
     begin
	if(rst_n == 1'b0)
	  begin
             CS              <= EMPTY;
             Pop_Pointer_CS  <= {ADDR_DEPTH {1'b0}};
             Push_Pointer_CS <= {ADDR_DEPTH {1'b0}};
	  end
	else
	  begin
             if(clear_i)
               begin
		  CS              <= EMPTY;
		  Pop_Pointer_CS  <= {ADDR_DEPTH {1'b0}};
		  Push_Pointer_CS <= {ADDR_DEPTH {1'b0}};
               end
             else
               begin
		  CS              <= NS;
		  Pop_Pointer_CS  <= Pop_Pointer_NS;
		  Push_Pointer_CS <= Push_Pointer_NS;
               end
	  end
     end
   
   
   // Compute Next State
   always_comb
     begin
	gate_clock      = 1'b0;
	
	case(CS)
	  
	  EMPTY:
	    begin
               grant_o = 1'b1;
               valid_o = 1'b0;
	       
               case(valid_i)
		 1'b0 : 
		   begin 
                      NS              = EMPTY;
                      Push_Pointer_NS = Push_Pointer_CS;
                      Pop_Pointer_NS  = Pop_Pointer_CS;
                      gate_clock      = 1'b1;
		   end
		 
		 1'b1: 
		   begin 
                      NS              = MIDDLE;
                      Push_Pointer_NS = Push_Pointer_CS + 1'b1;
                      Pop_Pointer_NS  = Pop_Pointer_CS;
		   end
		 
               endcase
	    end//~EMPTY
	  
	  MIDDLE:
	    begin
               grant_o = 1'b1;
               valid_o = 1'b1;
	       
               case({valid_i,grant_i})
		 
		 2'b01:
		   begin
                      gate_clock      = 1'b1;
		      
                      if((Pop_Pointer_CS == Push_Pointer_CS -1 ) || ((Pop_Pointer_CS == DATA_DEPTH-1) && (Push_Pointer_CS == 0) ))
                        NS              = EMPTY;
                      else
                        NS              = MIDDLE;
		      
                      Push_Pointer_NS = Push_Pointer_CS;
		      
                      if(Pop_Pointer_CS == DATA_DEPTH-1)
                        Pop_Pointer_NS  = 0;
                      else
                        Pop_Pointer_NS  = Pop_Pointer_CS + 1'b1;
		   end
		 
		 2'b00 : 
		   begin
                      gate_clock      = 1'b1; 
                      NS              = MIDDLE;
                      Push_Pointer_NS = Push_Pointer_CS;
                      Pop_Pointer_NS  = Pop_Pointer_CS;
		   end
		 
		 2'b11: 
		   begin
                      NS              = MIDDLE;
		      
                      if(Push_Pointer_CS == DATA_DEPTH-1)
                        Push_Pointer_NS = 0;
                      else
                        Push_Pointer_NS = Push_Pointer_CS + 1'b1;
		      
                      if(Pop_Pointer_CS == DATA_DEPTH-1)
                        Pop_Pointer_NS  = 0;
                      else
                        Pop_Pointer_NS  = Pop_Pointer_CS  + 1'b1;
		   end
		 
		 2'b10:
		   begin 
                      if(( Push_Pointer_CS == Pop_Pointer_CS - 1) || ( (Push_Pointer_CS == DATA_DEPTH-1) && (Pop_Pointer_CS == 0) ))
                        NS              = FULL;
                      else
                        NS        = MIDDLE;
		      
                      if(Push_Pointer_CS == DATA_DEPTH - 1)
                        Push_Pointer_NS = 0;
                      else
                        Push_Pointer_NS = Push_Pointer_CS + 1'b1;
		      
                      Pop_Pointer_NS  = Pop_Pointer_CS;
		   end
		 
               endcase                     
	    end
	  
	  FULL:
	    begin
               grant_o     = 1'b0;
               valid_o     = 1'b1;
               gate_clock  = 1'b1;
	       
               case(grant_i)
		 1'b1: 
		   begin 
                      NS              = MIDDLE;
		      
                      Push_Pointer_NS = Push_Pointer_CS;
		      
                      if(Pop_Pointer_CS == DATA_DEPTH-1)
                        Pop_Pointer_NS  = 0;
                      else
                        Pop_Pointer_NS  = Pop_Pointer_CS  + 1'b1;
		   end
		 
		 1'b0:
		   begin 
                      NS              = FULL;
                      Push_Pointer_NS = Push_Pointer_CS;
                      Pop_Pointer_NS  = Pop_Pointer_CS;
		   end
               endcase                 
	       
	    end // end of FULL
	  
	  default :
	    begin
               gate_clock      = 1'b1;
               grant_o         = 1'b0;
               valid_o         = 1'b0;
               NS              = EMPTY;
               Pop_Pointer_NS  = 0;
               Push_Pointer_NS = 0;
	    end
	  
	endcase
     end
   
   always_ff @(posedge clk_gated, negedge rst_n)
     begin
	if(rst_n == 1'b0)
	  begin
	     for (i=0; i< DATA_DEPTH; i++)
               FIFO_REGISTERS[i] <= {DATA_WIDTH {1'b0}};
	  end
	else
	  begin
             if((grant_o == 1'b1) && (valid_i == 1'b1))
               FIFO_REGISTERS[Push_Pointer_CS] <= data_i;
	  end
     end
   
   assign data_o = FIFO_REGISTERS[Pop_Pointer_CS];
   
endmodule // generic_fifo
",generic_fifo_adv.sv.txt,common_cells\generic_fifo_adv.sv.txt
"[Keyword]: generic_LFSR_8bit.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a generic 8-bit Linear Feedback Shift Register (LFSR) with both binary and one-hot encoding outputs. The LFSR is used to generate pseudo-random sequences, which can be utilized in various applications such as counters, random number generation, and scrambling.

[Input Signal Description]:
- `enable_i`: A logic input signal that enables the LFSR operation. When high, the LFSR updates its state on each clock cycle.
- `clk`: The clock input signal that synchronizes the LFSR updates.
- `rst_n`: An active-low reset input signal that initializes the LFSR to a predefined seed value when asserted.

[Output Signal Description]:
- `data_OH_o`: A one-hot encoded output signal of width `OH_WIDTH`, representing the current state of the LFSR in one-hot format.
- `data_BIN_o`: A binary encoded output signal of width `BIN_WIDTH`, representing a portion of the LFSR state in binary format.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Igor Loi <igor.loi@unibo.it>

module generic_LFSR_8bit
  #(
    parameter OH_WIDTH      = 4,
    parameter BIN_WIDTH     = $clog2(OH_WIDTH),
    parameter SEED          = 8'b00000000
    ) 
   (
    output logic [OH_WIDTH-1:0]    data_OH_o,   // One hot encoding
    output logic [BIN_WIDTH-1:0]   data_BIN_o,  // Binary encoding
    input  logic                   enable_i,        //
    input  logic                   clk,             //
    input  logic                   rst_n            //
    );
   
   logic [7:0] 			   out;
   logic                           linear_feedback;
   logic [BIN_WIDTH-1:0] 	   temp_ref_way;
   
   
   //-------------Code Starts Here-------
   assign linear_feedback = !(out[7] ^ out[3] ^ out[2] ^ out[1]); // TAPS for XOR feedback
   
   assign data_BIN_o = temp_ref_way;
   
   always_ff @(posedge clk, negedge rst_n)
     begin
	if (rst_n == 1'b0)
	  begin
	     out <= SEED ;
	  end 
	else if (enable_i) 
          begin
             out <= {out[6],out[5],out[4],out[3],out[2],out[1],out[0], linear_feedback};
          end 
     end
   
   generate
      
      if(OH_WIDTH == 2)
	assign temp_ref_way = out[1];
      else
	assign temp_ref_way = out[BIN_WIDTH:1];
   endgenerate
   
   // Bin to One Hot Encoder
   always_comb
     begin
	data_OH_o = '0;
	data_OH_o[temp_ref_way] = 1'b1;
     end
   
endmodule
",generic_LFSR_8bit.sv.txt,common_cells\generic_LFSR_8bit.sv.txt
"[Keyword]: gray_to_binary.sv

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is a Gray code to binary converter. It takes an N-bit Gray code input and converts it to an N-bit binary output. Gray code is a binary numeral system where two successive values differ in only one bit, and this module translates that into a standard binary representation.

[Input Signal Description]:
A[N-1:0]: An N-bit input signal representing a number in Gray code format.

[Output Signal Description]:
Z[N-1:0]: An N-bit output signal representing the equivalent binary number of the input Gray code.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>

/// A gray code to binary converter.
module gray_to_binary #(
    parameter int N = -1
)(
    input  logic [N-1:0] A,
    output logic [N-1:0] Z
);
    for (genvar i = 0; i < N; i++)
        assign Z[i] = ^A[N-1:i];
endmodule
",gray_to_binary.sv.txt,common_cells\gray_to_binary.sv.txt
"[Keyword]: id_queue.sv

[Design Category]: Memory Circuits

[Design Function Description]:
The design implements an ID-based queue system where each element in the queue is associated with a unique numeric ID. The queue maintains a FIFO (First-In-First-Out) order for elements with the same ID. It supports operations to push (enqueue) and pop (dequeue) elements, with the ability to handle simultaneous input and output operations depending on the bandwidth mode. Additionally, the queue provides a search functionality to check for the existence of elements based on a masked comparison.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing operations.
- `rst_ni`: Active-low reset signal to initialize or reset the queue.
- `inp_id_i`: Input ID for the element to be enqueued.
- `inp_data_i`: Data associated with the input ID to be enqueued.
- `inp_req_i`: Request signal to enqueue an element.
- `exists_data_i`: Data to be compared against elements in the queue for existence checking.
- `exists_mask_i`: Mask for selective bit comparison during existence checking.
- `exists_req_i`: Request signal to perform an existence check.
- `oup_id_i`: Output ID for the element to be dequeued.
- `oup_pop_i`: Signal to indicate if the element should be dequeued (popped).
- `oup_req_i`: Request signal to dequeue an element.

[Output Signal Description]:
- `inp_gnt_o`: Grant signal indicating if the enqueue request is accepted.
- `exists_o`: Output signal indicating if the searched element exists in the queue.
- `exists_gnt_o`: Grant signal for the existence check request.
- `oup_data_o`: Data output of the dequeued element.
- `oup_data_valid_o`: Signal indicating if the output data is valid.
- `oup_gnt_o`: Grant signal indicating if the dequeue request is accepted.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// ID Queue
//
// In an ID queue, every element has a numeric ID. Among all elements that have the same ID, the ID
// queue preserves FIFO order.
//
// This ID queue implementation allows to either push (through the `inp_*` signals) or pop (through
// the `oup_*` signals) one element per clock cycle (depending on the _FULL_BW_ operating mode
// descibed below). The `inp_` port has priority and grants a request iff the queue is not full. The
// `oup_` port dequeues an element iff `oup_pop_i` is asserted during an `oup_` handshake;
// otherwise, it performs a non-destructive read. `oup_data_o` is valid iff `oup_data_valid_o` is
// asserted during an `oup_` handshake. If `oup_data_valid_o` is not asserted, the queue did not
// contain an element with the provided ID.
//
// The queue can work in two bandwidth modes:
//  * !FULL_BW: Input and output cannot be performed simultaneously (max bandwidth: 50%).
//  *  FULL_BW: Input and output can be performed simultaneously and a popped cell can be reused
//    immediately in the same clock cycle. Area increase typically 5-10%.
//
// This ID queue additionally provides the `exists_` port, which searches for an element anywhere in
// the queue. The comparison performed during the search can be masked: for every bit that is
// asserted in `exists_mask_i`, the corresponding bit in the queue element and in `exists_data_i`
// must be equal for a match; the other bits are not compared. If masking is not required, tie
// `exists_mask_i_ to `'1` and the synthesizer should simplify the comparisons to unmasked ones. The
// `exists_` port operates independently of the `inp_` and `oup_` ports. If the `exists_` port is
// unused, tie `exists_req_i` to `1'b0` and the synthesizer should remove the internal comparators.
//
// This ID queue can store at most `CAPACITY` elements, independent of their ID. Let
// - C = `CAPACITY`
// - B = $bits(data_t)
// - I = 2**`ID_WIDTH`
// Then
// - the queue element storage requires O(C * (B + log2(C))) bit
// - the ID table requires O(H * log2(C)) bit, where H = min(C, I)
//
// Maintainers:
// - Andreas Kurth <akurth@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

module id_queue #(
    parameter int ID_WIDTH  = 0,
    parameter int CAPACITY  = 0,
    parameter bit FULL_BW   = 0,
    parameter bit CUT_OUP_POP_INP_GNT = 0,
    parameter int NUM_CMP_PORTS = 1,
    parameter type data_t   = logic[31:0],
    // Dependent parameters, DO NOT OVERRIDE!
    localparam type id_t    = logic[ID_WIDTH-1:0]
) (
    input  logic    clk_i,
    input  logic    rst_ni,

    input  id_t     inp_id_i,
    input  data_t   inp_data_i,
    input  logic    inp_req_i,
    output logic    inp_gnt_o,

    input  data_t [NUM_CMP_PORTS-1:0] exists_data_i,
    input  data_t [NUM_CMP_PORTS-1:0] exists_mask_i,
    input  logic  [NUM_CMP_PORTS-1:0] exists_req_i,
    output logic  [NUM_CMP_PORTS-1:0] exists_o,
    output logic  [NUM_CMP_PORTS-1:0] exists_gnt_o,

    input  id_t     oup_id_i,
    input  logic    oup_pop_i,
    input  logic    oup_req_i,
    output data_t   oup_data_o,
    output logic    oup_data_valid_o,
    output logic    oup_gnt_o
);

    // Capacity of the head-tail table, which associates an ID with corresponding head and tail
    // indices.
    localparam int NIds = 2**ID_WIDTH;
    localparam int HtCapacity = (NIds <= CAPACITY) ? NIds : CAPACITY;
    localparam int unsigned HtIdxWidth = cf_math_pkg::idx_width(HtCapacity);
    localparam int unsigned LdIdxWidth = cf_math_pkg::idx_width(CAPACITY);

    // Type for indexing the head-tail table.
    typedef logic [HtIdxWidth-1:0] ht_idx_t;

    // Type for indexing the lined data table.
    typedef logic [LdIdxWidth-1:0] ld_idx_t;

    // Type of an entry in the head-tail table.
    typedef struct packed {
        id_t        id;
        ld_idx_t    head,
                    tail;
        logic       free;
    } head_tail_t;

    // Type of an entry in the linked data table.
    typedef struct packed {
        data_t      data;
        ld_idx_t    next;
        logic       free;
    } linked_data_t;

    head_tail_t [HtCapacity-1:0]    head_tail_d,    head_tail_q;

    linked_data_t [CAPACITY-1:0]    linked_data_d,  linked_data_q;

    logic                           full,
                                    match_in_id_valid,
                                    match_out_id_valid,
                                    no_in_id_match,
                                    no_out_id_match;

    logic [HtCapacity-1:0]         head_tail_free,
                                    idx_matches_in_id,
                                    idx_matches_out_id;

    logic [NUM_CMP_PORTS-1:0][CAPACITY-1:0] exists_match;
    logic [CAPACITY-1:0]            linked_data_free;

    id_t                            match_in_id, match_out_id;

    ht_idx_t                        head_tail_free_idx,
                                    match_in_idx,
                                    match_out_idx;

    ld_idx_t                        linked_data_free_idx,
                                    oup_data_free_idx;

    logic                           oup_data_popped,
                                    oup_ht_popped;

    // Find the index in the head-tail table that matches a given ID.
    for (genvar i = 0; i < HtCapacity; i++) begin: gen_idx_match
        assign idx_matches_in_id[i] = match_in_id_valid && (head_tail_q[i].id == match_in_id) &&
                !head_tail_q[i].free;
        assign idx_matches_out_id[i] = match_out_id_valid && (head_tail_q[i].id == match_out_id) &&
                !head_tail_q[i].free;
    end
    assign no_in_id_match = !(|idx_matches_in_id);
    assign no_out_id_match = !(|idx_matches_out_id);
    onehot_to_bin #(
        .ONEHOT_WIDTH ( HtCapacity )
    ) i_id_ohb_in (
        .onehot ( idx_matches_in_id ),
        .bin    ( match_in_idx      )
    );
    onehot_to_bin #(
        .ONEHOT_WIDTH ( HtCapacity )
    ) i_id_ohb_out (
        .onehot ( idx_matches_out_id ),
        .bin    ( match_out_idx      )
    );

    // Find the first free index in the head-tail table.
    for (genvar i = 0; i < HtCapacity; i++) begin: gen_head_tail_free
        assign head_tail_free[i] = head_tail_q[i].free;
    end
    lzc #(
        .WIDTH ( HtCapacity ),
        .MODE  ( 0          ) // Start at index 0.
    ) i_ht_free_lzc (
        .in_i    ( head_tail_free     ),
        .cnt_o   ( head_tail_free_idx ),
        .empty_o (                    )
    );

    // Find the first free index in the linked data table.
    for (genvar i = 0; i < CAPACITY; i++) begin: gen_linked_data_free
        assign linked_data_free[i] = linked_data_q[i].free;
    end
    lzc #(
        .WIDTH ( CAPACITY ),
        .MODE  ( 0        ) // Start at index 0.
    ) i_ld_free_lzc (
        .in_i    ( linked_data_free     ),
        .cnt_o   ( linked_data_free_idx ),
        .empty_o (                      )
    );

    // The queue is full if and only if there are no free items in the linked data structure.
    assign full = !(|linked_data_free);
    // Data potentially freed by the output.
    assign oup_data_free_idx = head_tail_q[match_out_idx].head;

    // Data can be accepted if the linked list pool is not full, or if some data is simultaneously
    // popped (given FULL_BW & !CUT_OUP_POP_INP_GNT).
    assign inp_gnt_o = ~full || (oup_data_popped && FULL_BW && ~CUT_OUP_POP_INP_GNT);
    always_comb begin
        match_in_id         = '0;
        match_out_id        = '0;
        match_in_id_valid   = 1'b0;
        match_out_id_valid  = 1'b0;
        head_tail_d         = head_tail_q;
        linked_data_d       = linked_data_q;
        oup_gnt_o           = 1'b0;
        oup_data_o          = data_t'('0);
        oup_data_valid_o    = 1'b0;
        oup_data_popped     = 1'b0;
        oup_ht_popped       = 1'b0;

        if (!FULL_BW) begin
            if (inp_req_i && !full) begin
                match_in_id = inp_id_i;
                match_in_id_valid = 1'b1;
                // If the ID does not yet exist in the queue, add a new ID entry.
                if (no_in_id_match) begin
                    head_tail_d[head_tail_free_idx] = '{
                        id: inp_id_i,
                        head: linked_data_free_idx,
                        tail: linked_data_free_idx,
                        free: 1'b0
                    };
                // Otherwise append it to the existing ID subqueue.
                end else begin
                    linked_data_d[head_tail_q[match_in_idx].tail].next = linked_data_free_idx;
                    head_tail_d[match_in_idx].tail = linked_data_free_idx;
                end
                linked_data_d[linked_data_free_idx] = '{
                    data: inp_data_i,
                    next: '0,
                    free: 1'b0
                };
            end else if (oup_req_i) begin
                match_in_id = oup_id_i;
                match_in_id_valid = 1'b1;
                if (!no_in_id_match) begin
                    oup_data_o = data_t'(linked_data_q[head_tail_q[match_in_idx].head].data);
                    oup_data_valid_o = 1'b1;
                    if (oup_pop_i) begin
                        // Set free bit of linked data entry, all other bits are don't care.
                        linked_data_d[head_tail_q[match_in_idx].head]      = '0;
                        linked_data_d[head_tail_q[match_in_idx].head][0]   = 1'b1;
                        if (head_tail_q[match_in_idx].head == head_tail_q[match_in_idx].tail) begin
                            head_tail_d[match_in_idx] = '{free: 1'b1, default: '0};
                        end else begin
                            head_tail_d[match_in_idx].head =
                                    linked_data_q[head_tail_q[match_in_idx].head].next;
                        end
                    end
                end
                // Always grant the output request.  If there was no match, the default, invalid entry
                // will be returned.
                oup_gnt_o = 1'b1;
            end
        end else begin
            // FULL_BW
            if (oup_req_i) begin
                match_out_id = oup_id_i;
                match_out_id_valid = 1'b1;
                if (!no_out_id_match) begin
                    oup_data_o = data_t'(linked_data_q[head_tail_q[match_out_idx].head].data);
                    oup_data_valid_o = 1'b1;
                    if (oup_pop_i) begin
                        oup_data_popped = 1'b1;
                        // Set free bit of linked data entry, all other bits are don't care.
                        linked_data_d[head_tail_q[match_out_idx].head]      = '0;
                        linked_data_d[head_tail_q[match_out_idx].head][0]   = 1'b1;
                        if (head_tail_q[match_out_idx].head
                                          == head_tail_q[match_out_idx].tail) begin
                            oup_ht_popped = 1'b1;
                            head_tail_d[match_out_idx] = '{free: 1'b1, default: '0};
                        end else begin
                            head_tail_d[match_out_idx].head =
                                    linked_data_q[head_tail_q[match_out_idx].head].next;
                        end
                    end
                end
                // Always grant the output request.  If there was no match, the default, invalid entry
                // will be returned.
                oup_gnt_o = 1'b1;
            end
            if (inp_req_i && inp_gnt_o) begin
                match_in_id = inp_id_i;
                match_in_id_valid = 1'b1;
                // If the ID does not yet exist in the queue or was just popped, add a new ID entry.
                if (oup_ht_popped && (oup_id_i==inp_id_i)) begin
                    // If output data was popped for this ID, which lead the head_tail to be popped,
                    // then repopulate this head_tail immediately.
                    head_tail_d[match_out_idx] = '{
                        id: inp_id_i,
                        head: oup_data_free_idx,
                        tail: oup_data_free_idx,
                        free: 1'b0
                    };
                    linked_data_d[oup_data_free_idx] = '{
                        data: inp_data_i,
                        next: '0,
                        free: 1'b0
                    };
                end else if (no_in_id_match) begin
                    // Else, if no head_tail corresponds to the input id.
                    if (oup_ht_popped) begin
                        head_tail_d[match_out_idx] = '{
                            id: inp_id_i,
                            head: oup_data_free_idx,
                            tail: oup_data_free_idx,
                            free: 1'b0
                        };
                        linked_data_d[oup_data_free_idx] = '{
                            data: inp_data_i,
                            next: '0,
                            free: 1'b0
                        };
                    end else begin
                        if (oup_data_popped) begin
                          head_tail_d[head_tail_free_idx] = '{
                            id: inp_id_i,
                            head: oup_data_free_idx,
                            tail: oup_data_free_idx,
                            free: 1'b0
                          };
                          linked_data_d[oup_data_free_idx] = '{
                              data: inp_data_i,
                              next: '0,
                              free: 1'b0
                          };
                        end else begin
                            head_tail_d[head_tail_free_idx] = '{
                              id: inp_id_i,
                              head: linked_data_free_idx,
                              tail: linked_data_free_idx,
                              free: 1'b0
                            };
                            linked_data_d[linked_data_free_idx] = '{
                                data: inp_data_i,
                                next: '0,
                                free: 1'b0
                            };
                        end
                    end
                end else begin
                    // Otherwise append it to the existing ID subqueue.
                    if (oup_data_popped) begin
                        linked_data_d[head_tail_q[match_in_idx].tail].next = oup_data_free_idx;
                        head_tail_d[match_in_idx].tail = oup_data_free_idx;
                        linked_data_d[oup_data_free_idx] = '{
                            data: inp_data_i,
                            next: '0,
                            free: 1'b0
                        };
                    end else begin
                        linked_data_d[head_tail_q[match_in_idx].tail].next = linked_data_free_idx;
                        head_tail_d[match_in_idx].tail = linked_data_free_idx;
                        linked_data_d[linked_data_free_idx] = '{
                            data: inp_data_i,
                            next: '0,
                            free: 1'b0
                        };
                    end
                end
            end
        end
    end

    // Exists Lookup
    for (genvar k = 0; k < NUM_CMP_PORTS; k++) begin: gen_lookup_port
        for (genvar i = 0; i < CAPACITY; i++) begin: gen_lookup
            data_t exists_match_bits;
            for (genvar j = 0; j < $bits(data_t); j++) begin: gen_mask
                always_comb begin
                    if (linked_data_q[i].free) begin
                        exists_match_bits[j] = 1'b0;
                    end else begin
                        if (!exists_mask_i[k][j]) begin
                            exists_match_bits[j] = 1'b1;
                        end else begin
                            exists_match_bits[j] =
                                (linked_data_q[i].data[j] == exists_data_i[k][j]);
                        end
                    end
                end
            end
            assign exists_match[k][i] = (&exists_match_bits);
        end
        always_comb begin
            exists_gnt_o[k] = 1'b0;
            exists_o[k] = '0;
            if (exists_req_i[k]) begin
                exists_gnt_o[k] = 1'b1;
                exists_o[k] = (|exists_match[k]);
            end
        end
    end

    // Registers
    for (genvar i = 0; i < HtCapacity; i++) begin: gen_ht_ffs
        always_ff @(posedge clk_i, negedge rst_ni) begin
            if (!rst_ni) begin
                head_tail_q[i] <= '{free: 1'b1, default: '0};
            end else begin
                head_tail_q[i] <= head_tail_d[i];
            end
        end
    end
    for (genvar i = 0; i < CAPACITY; i++) begin: gen_data_ffs
        always_ff @(posedge clk_i, negedge rst_ni) begin
            if (!rst_ni) begin
                // Set free bit of linked data entries, all other bits are don't care.
                linked_data_q[i]    <= '0;
                linked_data_q[i][0] <= 1'b1;
            end else begin
                linked_data_q[i]    <= linked_data_d[i];
            end
        end
    end

    // Validate parameters.
`ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(id_width_0, ID_WIDTH >= 1, ""The ID must at least be one bit wide!"")
    `ASSERT_INIT(capacity_0, CAPACITY >= 1, ""The queue must have capacity of at least one entry!"")
`endif

endmodule
",id_queue.sv.txt,common_cells\id_queue.sv.txt
"[Keyword]: isochronous_4phase_handshake.sv

[Design Category]: Interface Circuits

[Design Function Description]:
This module implements a 4-phase handshake mechanism between isochronous clock domains, which are clock domains operating at integer multiples of each other. The design facilitates communication between these clock domains without the risk of metastability, as the handshake signals are not synchronized. The module ensures that the upstream circuit only handshakes if the downstream circuit has completed its handshake. It does not buffer data and toggles the source handshake only after the destination handshake has been toggled.

[Input Signal Description]:
- `src_clk_i`: Source clock input signal.
- `src_rst_ni`: Active-low reset signal for the source domain.
- `src_valid_i`: Input signal indicating the validity of the source data.
- `dst_clk_i`: Destination clock input signal.
- `dst_rst_ni`: Active-low reset signal for the destination domain.
- `dst_ready_i`: Input signal indicating the readiness of the destination to receive data.

[Output Signal Description]:
- `src_ready_o`: Output signal indicating the readiness of the source to send data.
- `dst_valid_o`: Output signal indicating the validity of the data at the destination.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>

/// 4-phase handshake between isochronous clock domains
/// (i.e., clock domains which operate on an integer multiple of each other).
///
/// The internals of this modules are similar to a clock-domain crossing except that
/// they do not synchronize the handshake signals as signals can not become metastable (covered by STA).
/// The upstream circuit will only handshake iff the downstream circuit handshaked.
///
/// ## Optionally Passing of Data
///
/// If the passing of data is necessary this should be done out side the module, for example:
/// ```
/// `FFLNR(dst_data_o, src_data_i, (src_valid_i && src_ready_o), src_clk_i)
/// ```
///
/// This module differs to `isochronous_spill_register` that it doesn't buffer any data
/// and only toggles the source handshake once the destination handshake has been toggled.
///
/// # Restrictions
///
/// Source and destination clock domains must be an integer multiple of each other and
/// all timing-paths need to be covered by STA. For example a recommended SDC would be:
///
/// `create_generated_clock dst_clk_i -name dst_clk  -source src_clk_i -divide_by 2
///
/// There are _no_ restrictions on which clock domain should be the faster, any integer
/// ratio will work.

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

module isochronous_4phase_handshake (
  input  logic src_clk_i,
  input  logic src_rst_ni,
  input  logic src_valid_i,
  output logic src_ready_o,
  input  logic dst_clk_i,
  input  logic dst_rst_ni,
  output logic dst_valid_o,
  input  logic dst_ready_i
);

  logic src_req_q, src_ack_q;
  logic dst_req_q, dst_ack_q;

  // source is making a request
  `FFLARN(src_req_q, ~src_req_q, (src_valid_i && src_ready_o), 1'b0, src_clk_i, src_rst_ni)
  // ""synchronize"" the acknowledge into the sending clock-domain
  `FFARN(src_ack_q, dst_ack_q, 1'b0, src_clk_i, src_rst_ni)
  // source is ready if the request wasn't yet acknowledged
  assign src_ready_o = (src_req_q == src_ack_q);

  // down-stream circuit is acknowledging the handshake
  `FFLARN(dst_ack_q, ~dst_ack_q, (dst_valid_o && dst_ready_i), 1'b0, dst_clk_i, dst_rst_ni)
  // ""synchronize"" the request into the receiving clock domain
  `FFARN(dst_req_q, src_req_q, 1'b0, dst_clk_i, dst_rst_ni)
  // destination is valid if we didn't yet get acknowledge
  assign dst_valid_o = (dst_req_q != dst_ack_q);

 // stability guarantees
  `ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT(src_valid_unstable, src_valid_i && !src_ready_o |=> $stable(src_valid_i),
          src_clk_i, !src_rst_ni, ""src_valid_i is unstable"")
  `ASSERT(dst_valid_unstable, dst_valid_o && !dst_ready_i |=> $stable(dst_valid_o),
          dst_clk_i, !dst_rst_ni, ""dst_valid_o is unstable"")
  `endif

endmodule
",isochronous_4phase_handshake.sv.txt,common_cells\isochronous_4phase_handshake.sv.txt
"[Keyword]: isochronous_spill_register.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The module implements an isochronous spill register, which acts as a dual-clock FIFO with handshakes. It is designed to cut any combinatorial paths between the input and output across isochronous clock domains. This allows for data transfer between clock domains that are derived from the same source but may have different frequencies. The module ensures that data is transferred reliably without the need for additional synchronization, relying on static timing analysis to manage timing relationships.

[Input Signal Description]:
- `src_clk_i`: Clock signal for the source clock domain.
- `src_rst_ni`: Active low asynchronous reset signal for the source domain.
- `src_valid_i`: Indicates that the source input data is valid.
- `src_data_i`: The actual data input from the source domain.
- `dst_clk_i`: Clock signal for the destination clock domain.
- `dst_rst_ni`: Active low asynchronous reset signal for the destination domain.
- `dst_ready_i`: Indicates that the destination is ready to accept data.

[Output Signal Description]:
- `src_ready_o`: Indicates that the source is ready to accept new data.
- `dst_valid_o`: Indicates that the destination output data is valid.
- `dst_data_o`: The actual data output to the destination domain.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

/// A register with handshakes that completely cuts any combinatorial paths
/// between the input and output in isochronous clock domains.
///
/// > Definition of isochronous: In telecommunication, an isochronous signal is a signal
/// > in which the time interval separating any two significant instants is equal to the
/// > unit interval or a multiple of the unit interval.
///
/// The source and destination clock domains must be derived from the same clock
/// but can vary in frequency by a constant factor (e.g., double the frequency).
///
/// The module is basically a two deep dual-clock fifo with read and write pointers
/// in different clock domains. As we know the static timing relationship between the
/// clock domains we can rely on static timing analysis (STA) to get the sampling windows
/// right and therefore don't need any synchronization.
///
/// # Restrictions
///
/// Source and destination clock domains must be an integer multiple of each other and
/// all timing-paths need to be covered by STA. For example a recommended SDC would be:
///
/// `create_generated_clock dst_clk_i -name dst_clk  -source src_clk_i -divide_by 2
///
/// There are _no_ restrictions on which clock domain should be the faster, any integer
/// ratio will work.
module isochronous_spill_register #(
  /// Data type of spill register.
  parameter type T      = logic,
  /// Make this spill register transparent.
  parameter bit  Bypass = 1'b0
) (
  /// Clock of source clock domain.
  input  logic src_clk_i,
  /// Active low async reset in source domain.
  input  logic src_rst_ni,
  /// Source input data is valid.
  input  logic src_valid_i,
  /// Source is ready to accept.
  output logic src_ready_o,
  /// Source input data.
  input  T     src_data_i,
  /// Clock of destination clock domain.
  input  logic dst_clk_i,
  /// Active low async reset in destination domain.
  input  logic dst_rst_ni,
  /// Destination output data is valid.
  output logic dst_valid_o,
  /// Destination is ready to accept.
  input  logic dst_ready_i,
  /// Destination output data.
  output T     dst_data_o
);
  // Don't generate the spill register.
  if (Bypass) begin : gen_bypass
    assign dst_valid_o = src_valid_i;
    assign src_ready_o = dst_ready_i;
    assign dst_data_o  = src_data_i;
  // Generate the spill register
  end else begin : gen_isochronous_spill_register
    /// Read/write pointer are one bit wider than necessary.
    /// We implicitly capture the full and empty state with the second bit:
    /// If all but the topmost bit of `rd_pointer_q` and `wr_pointer_q` agree, the
    /// FIFO is in a critical state. If the topmost bit is equal, the FIFO is
    /// empty, otherwise it is full.
    logic [1:0] rd_pointer_q, wr_pointer_q;
    // Advance write pointer if we pushed a new item into the FIFO. (Source clock domain)
    `FFLARN(wr_pointer_q, wr_pointer_q+1, (src_valid_i && src_ready_o), '0, src_clk_i, src_rst_ni)
    // Advance read pointer if downstream consumed an item. (Destination clock domain)
    `FFLARN(rd_pointer_q, rd_pointer_q+1, (dst_valid_o && dst_ready_i), '0, dst_clk_i, dst_rst_ni)

    T [1:0] mem_d, mem_q;
    `FFLNR(mem_q, mem_d, (src_valid_i && src_ready_o), src_clk_i)
    always_comb begin
      mem_d = mem_q;
      mem_d[wr_pointer_q[0]] = src_data_i;
    end

    assign src_ready_o = (rd_pointer_q ^ wr_pointer_q) != 2'b10;

    assign dst_valid_o = (rd_pointer_q ^ wr_pointer_q) != '0;
    assign dst_data_o = mem_q[rd_pointer_q[0]];
  end

  // stability guarantees
  `ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT(src_valid_unstable, src_valid_i && !src_ready_o |=> $stable(src_valid_i),
          src_clk_i, !src_rst_ni, ""src_valid_i is unstable"")
  `ASSERT(src_data_unstable, src_valid_i && !src_ready_o |=> $stable(src_data_i),
          src_clk_i, !src_rst_ni, ""src_data_i is unstable"")
  `ASSERT(dst_valid_unstable, dst_valid_o && !dst_ready_i |=> $stable(dst_valid_o),
          dst_clk_i, !dst_rst_ni, ""dst_valid_o is unstable"")
  `ASSERT(dst_data_unstable, dst_valid_o && !dst_ready_i |=> $stable(dst_data_o),
          dst_clk_i, !dst_rst_ni, ""dst_data_o is unstable"")
  `endif
endmodule
",isochronous_spill_register.sv.txt,common_cells\isochronous_spill_register.sv.txt
"[Keyword]: lfsr.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a parametric Linear Feedback Shift Register (LFSR) with precomputed coefficients for LFSR lengths ranging from 4 to 64 bits. It can generate pseudo-random sequences and includes optional block cipher layers to introduce non-linearity and break linear shifting patterns. The block cipher layers are applicable only for an LFSR width of 64 bits.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the LFSR operations.
- `rst_ni`: Active-low reset input signal to initialize the LFSR to a predefined value.
- `en_i`: Enable input signal to control the operation of the LFSR. When high, the LFSR updates its state.

[Output Signal Description]:
- `out_o`: Output signal that provides the current state of the LFSR, truncated to the specified output width (`OutWidth`).


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
// Date: 26.04.2019
//
// Description: This is a parametric LFSR with precomputed coefficients for
// LFSR lengths from 4 to 64bit.

// Additional block cipher layers can be instantiated to non-linearly transform
// the pseudo-random LFSR sequence at the output, and hence break the shifting
// patterns. The additional cipher layers can only be used for an LFSR width
// of 64bit, since the block cipher has been designed for that block length.

`include ""common_cells/assertions.svh""

module lfsr #(
  parameter int unsigned          LfsrWidth     = 64,   // [4,64]
  parameter int unsigned          OutWidth      = 8,    // [1,LfsrWidth]
  parameter logic [LfsrWidth-1:0] RstVal        = '1,   // [1,2^LfsrWidth-1]
  // 0: disabled, the present cipher uses 31, but just a few layers (1-3) are enough
  // to break linear shifting patterns
  parameter int unsigned          CipherLayers  = 0,
  parameter bit                   CipherReg     = 1'b1  // additional output reg after cipher
) (
  input  logic                 clk_i,
  input  logic                 rst_ni,
  input  logic                 en_i,
  output logic [OutWidth-1:0]  out_o
);

// Galois LFSR feedback masks
// Automatically generated with get_lfsr_masks.py
// Masks are from https://users.ece.cmu.edu/~koopman/lfsr/
localparam logic [63:0] Masks [4:64] = '{64'hC,
                                         64'h1E,
                                         64'h39,
                                         64'h7E,
                                         64'hFA,
                                         64'h1FD,
                                         64'h3FC,
                                         64'h64B,
                                         64'hD8F,
                                         64'h1296,
                                         64'h2496,
                                         64'h4357,
                                         64'h8679,
                                         64'h1030E,
                                         64'h206CD,
                                         64'h403FE,
                                         64'h807B8,
                                         64'h1004B2,
                                         64'h2006A8,
                                         64'h4004B2,
                                         64'h800B87,
                                         64'h10004F3,
                                         64'h200072D,
                                         64'h40006AE,
                                         64'h80009E3,
                                         64'h10000583,
                                         64'h20000C92,
                                         64'h400005B6,
                                         64'h80000EA6,
                                         64'h1000007A3,
                                         64'h200000ABF,
                                         64'h400000842,
                                         64'h80000123E,
                                         64'h100000074E,
                                         64'h2000000AE9,
                                         64'h400000086A,
                                         64'h8000001213,
                                         64'h1000000077E,
                                         64'h2000000123B,
                                         64'h40000000877,
                                         64'h8000000108D,
                                         64'h100000000AE9,
                                         64'h200000000E9F,
                                         64'h4000000008A6,
                                         64'h80000000191E,
                                         64'h100000000090E,
                                         64'h2000000000FB3,
                                         64'h4000000000D7D,
                                         64'h80000000016A5,
                                         64'h10000000000B4B,
                                         64'h200000000010AF,
                                         64'h40000000000DDE,
                                         64'h8000000000181A,
                                         64'h100000000000B65,
                                         64'h20000000000102D,
                                         64'h400000000000CD5,
                                         64'h8000000000024C1,
                                         64'h1000000000000EF6,
                                         64'h2000000000001363,
                                         64'h4000000000000FCD,
                                         64'h80000000000019E2};

// this S-box and permutation P has been taken from the Present Cipher,
// a super lightweight block cipher. use the cipher layers to add additional
// non-linearity to the LFSR output. note one layer does not fully correspond
// to the present cipher round, since the key and rekeying function is not applied here.
//
// See also:
// ""PRESENT: An Ultra-Lightweight Block Cipher"", A. Bogdanov et al., Ches 2007
// http://www.lightweightcrypto.org/present/present_ches2007.pdf

// this is the sbox from the present cipher
localparam logic[15:0][3:0] Sbox4 = {4'h2, 4'h1, 4'h7, 4'h4,
                                     4'h8, 4'hF, 4'hE, 4'h3,
                                     4'hD, 4'hA, 4'h0, 4'h9,
                                     4'hB, 4'h6, 4'h5, 4'hC };

// these are the permutation indices of the present cipher
localparam logic[63:0][5:0] Perm = {6'd63, 6'd47, 6'd31, 6'd15, 6'd62, 6'd46, 6'd30, 6'd14,
                                    6'd61, 6'd45, 6'd29, 6'd13, 6'd60, 6'd44, 6'd28, 6'd12,
                                    6'd59, 6'd43, 6'd27, 6'd11, 6'd58, 6'd42, 6'd26, 6'd10,
                                    6'd57, 6'd41, 6'd25, 6'd09, 6'd56, 6'd40, 6'd24, 6'd08,
                                    6'd55, 6'd39, 6'd23, 6'd07, 6'd54, 6'd38, 6'd22, 6'd06,
                                    6'd53, 6'd37, 6'd21, 6'd05, 6'd52, 6'd36, 6'd20, 6'd04,
                                    6'd51, 6'd35, 6'd19, 6'd03, 6'd50, 6'd34, 6'd18, 6'd02,
                                    6'd49, 6'd33, 6'd17, 6'd01, 6'd48, 6'd32, 6'd16, 6'd00};


function automatic logic [63:0] sbox4_layer(logic [63:0] in);
  logic [63:0] out;
  //for (logic [4:0] j = '0; j<16; j++) out[j*4 +: 4] = sbox4[in[j*4 +: 4]];
  // this simulates much faster than the loop
  out[0*4  +: 4] = Sbox4[in[0*4  +: 4]];
  out[1*4  +: 4] = Sbox4[in[1*4  +: 4]];
  out[2*4  +: 4] = Sbox4[in[2*4  +: 4]];
  out[3*4  +: 4] = Sbox4[in[3*4  +: 4]];

  out[4*4  +: 4] = Sbox4[in[4*4  +: 4]];
  out[5*4  +: 4] = Sbox4[in[5*4  +: 4]];
  out[6*4  +: 4] = Sbox4[in[6*4  +: 4]];
  out[7*4  +: 4] = Sbox4[in[7*4  +: 4]];

  out[8*4  +: 4] = Sbox4[in[8*4  +: 4]];
  out[9*4  +: 4] = Sbox4[in[9*4  +: 4]];
  out[10*4 +: 4] = Sbox4[in[10*4 +: 4]];
  out[11*4 +: 4] = Sbox4[in[11*4 +: 4]];

  out[12*4 +: 4] = Sbox4[in[12*4 +: 4]];
  out[13*4 +: 4] = Sbox4[in[13*4 +: 4]];
  out[14*4 +: 4] = Sbox4[in[14*4 +: 4]];
  out[15*4 +: 4] = Sbox4[in[15*4 +: 4]];
  return out;
endfunction : sbox4_layer

function automatic logic [63:0] perm_layer(logic [63:0] in);
  logic [63:0] out;
  // for (logic [7:0] j = '0; j<64; j++) out[perm[j]] = in[j];
  // this simulates much faster than the loop
  out[Perm[0]] = in[0];
  out[Perm[1]] = in[1];
  out[Perm[2]] = in[2];
  out[Perm[3]] = in[3];
  out[Perm[4]] = in[4];
  out[Perm[5]] = in[5];
  out[Perm[6]] = in[6];
  out[Perm[7]] = in[7];
  out[Perm[8]] = in[8];
  out[Perm[9]] = in[9];

  out[Perm[10]] = in[10];
  out[Perm[11]] = in[11];
  out[Perm[12]] = in[12];
  out[Perm[13]] = in[13];
  out[Perm[14]] = in[14];
  out[Perm[15]] = in[15];
  out[Perm[16]] = in[16];
  out[Perm[17]] = in[17];
  out[Perm[18]] = in[18];
  out[Perm[19]] = in[19];

  out[Perm[20]] = in[20];
  out[Perm[21]] = in[21];
  out[Perm[22]] = in[22];
  out[Perm[23]] = in[23];
  out[Perm[24]] = in[24];
  out[Perm[25]] = in[25];
  out[Perm[26]] = in[26];
  out[Perm[27]] = in[27];
  out[Perm[28]] = in[28];
  out[Perm[29]] = in[29];

  out[Perm[30]] = in[30];
  out[Perm[31]] = in[31];
  out[Perm[32]] = in[32];
  out[Perm[33]] = in[33];
  out[Perm[34]] = in[34];
  out[Perm[35]] = in[35];
  out[Perm[36]] = in[36];
  out[Perm[37]] = in[37];
  out[Perm[38]] = in[38];
  out[Perm[39]] = in[39];

  out[Perm[40]] = in[40];
  out[Perm[41]] = in[41];
  out[Perm[42]] = in[42];
  out[Perm[43]] = in[43];
  out[Perm[44]] = in[44];
  out[Perm[45]] = in[45];
  out[Perm[46]] = in[46];
  out[Perm[47]] = in[47];
  out[Perm[48]] = in[48];
  out[Perm[49]] = in[49];

  out[Perm[50]] = in[50];
  out[Perm[51]] = in[51];
  out[Perm[52]] = in[52];
  out[Perm[53]] = in[53];
  out[Perm[54]] = in[54];
  out[Perm[55]] = in[55];
  out[Perm[56]] = in[56];
  out[Perm[57]] = in[57];
  out[Perm[58]] = in[58];
  out[Perm[59]] = in[59];

  out[Perm[60]] = in[60];
  out[Perm[61]] = in[61];
  out[Perm[62]] = in[62];
  out[Perm[63]] = in[63];
  return out;
endfunction : perm_layer

////////////////////////////////////////////////////////////////////////
// lfsr
////////////////////////////////////////////////////////////////////////

logic [LfsrWidth-1:0] lfsr_d, lfsr_q;
assign lfsr_d =
  (en_i) ? (lfsr_q>>1) ^ ({LfsrWidth{lfsr_q[0]}} & Masks[LfsrWidth][LfsrWidth-1:0]) : lfsr_q;

always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
  //$display(""%b %h"", en_i, lfsr_d);
  if (!rst_ni) begin
    lfsr_q <= LfsrWidth'(RstVal);
  end else begin
    lfsr_q <= lfsr_d;
  end
end

////////////////////////////////////////////////////////////////////////
// block cipher layers
////////////////////////////////////////////////////////////////////////

if (CipherLayers > unsigned'(0)) begin : g_cipher_layers
  logic [63:0] ciph_layer;
  localparam int unsigned NumRepl = ((64+LfsrWidth)/LfsrWidth);

  always_comb begin : p_ciph_layer
    automatic logic [63:0] tmp;
    tmp = 64'({NumRepl{lfsr_q}});
    for(int unsigned k = 0; k < CipherLayers; k++) begin
      tmp = perm_layer(sbox4_layer(tmp));
    end
    ciph_layer = tmp;
  end

  // additiona output reg after cipher
  if (CipherReg) begin : g_cipher_reg
    logic [OutWidth-1:0] out_d, out_q;

    assign out_d = (en_i) ? ciph_layer[OutWidth-1:0] : out_q;
    assign out_o = out_q[OutWidth-1:0];

    always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
      if (!rst_ni) begin
        out_q <= '0;
      end else begin
        out_q <= out_d;
      end
    end
  // no outreg
  end else begin : g_no_out_reg
    assign out_o  = ciph_layer[OutWidth-1:0];
  end

// no block cipher
end else begin : g_no_cipher_layers
  assign out_o    = lfsr_q[OutWidth-1:0];
end

////////////////////////////////////////////////////////////////////////
// assertions
////////////////////////////////////////////////////////////////////////
`ifndef COMMON_CELLS_ASSERTS_OFF
// these are the LUT limits
`ASSERT_INIT(outwidth_gt_lfsrwidth, OutWidth <= LfsrWidth,
             ""OutWidth must be smaller equal the LfsrWidth."")
`ASSERT_INIT(rstval_0, RstVal > unsigned'(0), ""RstVal must be nonzero."")
`ASSERT_INIT(lfsrwidth_invalid, (LfsrWidth >= $low(Masks)) && (LfsrWidth <= $high(Masks)),
             ""Unsupported LfsrWidth."")
`ASSERT_INIT(mask_invalid, Masks[LfsrWidth][LfsrWidth-1],
             ""LFSR mask is not correct. The MSB must be 1."")
`ASSERT_INIT(cipherlayers_invalid, (CipherLayers > 0) && (LfsrWidth == 64) || (CipherLayers == 0),
             ""Use additional cipher layers only in conjunction with an LFSR width of 64 bit."")

  `ASSERT(all_zero, en_i |-> lfsr_d, clk_i, !rst_ni, ""Lfsr must not be all-zero."")
`endif

endmodule // lfsr
",lfsr.sv.txt,common_cells\lfsr.sv.txt
"[Keyword]: lfsr_16bit.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a 16-bit Linear Feedback Shift Register (LFSR). It generates pseudo-random sequences of bits using a shift register with feedback. The feedback is determined by XORing specific bits of the register, which are then fed back into the register. This LFSR is used to produce a one-hot encoded output and a binary output based on the current state of the shift register.

[Input Signal Description]:
- `clk_i`: Clock input signal that synchronizes the shift register operations.
- `rst_ni`: Active-low reset input signal that initializes the shift register to a predefined seed value.
- `en_i`: Enable input signal that allows the shift register to update its state when high.

[Output Signal Description]:
- `refill_way_oh`: One-hot encoded output signal representing the current state of the LFSR.
- `refill_way_bin`: Binary output signal representing the current state of the LFSR.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba, ETH Zurich
// Date: 5.11.2018
// Description: 16-bit LFSR

`include ""common_cells/assertions.svh""

// --------------
// 16-bit LFSR
// --------------
//
// Description: Shift register
//
module lfsr_16bit #(
    parameter logic [15:0] SEED  = 8'b0,
    parameter int unsigned WIDTH = 16
)(
    input  logic                      clk_i,
    input  logic                      rst_ni,
    input  logic                      en_i,
    output logic [WIDTH-1:0]          refill_way_oh,
    output logic [$clog2(WIDTH)-1:0]  refill_way_bin
);

    localparam int unsigned LogWidth = $clog2(WIDTH);

    logic [15:0] shift_d, shift_q;


    always_comb begin

        automatic logic shift_in;
        shift_in = !(shift_q[15] ^ shift_q[12] ^ shift_q[5] ^ shift_q[1]);

        shift_d = shift_q;

        if (en_i)
            shift_d = {shift_q[14:0], shift_in};

        // output assignment
        refill_way_oh = 'b0;
        refill_way_oh[shift_q[LogWidth-1:0]] = 1'b1;
        refill_way_bin = shift_q;
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin : proc_
        if(~rst_ni) begin
            shift_q <= SEED;
        end else begin
            shift_q <= shift_d;
        end
    end

  `ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(width_gt_16, WIDTH <= 16,
                 ""WIDTH needs to be less than 16 because of the 16-bit LFSR"")
  `endif

endmodule
",lfsr_16bit.sv.txt,common_cells\lfsr_16bit.sv.txt
"[Keyword]: lfsr_8bit.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is an 8-bit Linear Feedback Shift Register (LFSR). It generates pseudo-random sequences of bits using a shift register and feedback logic. The LFSR is used to produce a sequence of bits that can be used for various purposes such as random number generation, scrambling, or as a counter.

[Input Signal Description]:
- `clk_i`: Clock input signal that synchronizes the shifting operation.
- `rst_ni`: Active-low reset input signal that initializes the LFSR to a predefined seed value.
- `en_i`: Enable input signal that allows the LFSR to shift and generate new values when asserted.

[Output Signal Description]:
- `refill_way_oh`: One-hot encoded output representing the current state of the LFSR.
- `refill_way_bin`: Binary encoded output representing the current state of the LFSR.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Igor Loi - University of Bologna
// Author: Florian Zaruba, ETH Zurich
// Date: 12.11.2017
// Description: 8-bit LFSR

`include ""common_cells/assertions.svh""

/// 8 bit Linear Feedback Shift register
module lfsr_8bit #(
  parameter logic        [7:0] SEED  = 8'b0,
  parameter int unsigned       WIDTH = 8
) (
  input  logic                     clk_i,
  input  logic                     rst_ni,
  input  logic                     en_i,
  output logic [        WIDTH-1:0] refill_way_oh,
  output logic [$clog2(WIDTH)-1:0] refill_way_bin
);

  localparam int unsigned LogWidth = $clog2(WIDTH);

  logic [7:0] shift_d, shift_q;

  always_comb begin

    automatic logic shift_in;
    shift_in = !(shift_q[7] ^ shift_q[3] ^ shift_q[2] ^ shift_q[1]);

    shift_d = shift_q;

    if (en_i) shift_d = {shift_q[6:0], shift_in};

    // output assignment
    refill_way_oh = 'b0;
    refill_way_oh[shift_q[LogWidth - 1:0]] = 1'b1;
    refill_way_bin = shift_q;
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_
    if (~rst_ni) begin
      shift_q <= SEED;
    end else begin
      shift_q <= shift_d;
    end
  end

`ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(width_gt_8, WIDTH <= 8, ""WIDTH needs to be less than 8 because of the 8-bit LFSR"")
`endif

endmodule
",lfsr_8bit.sv.txt,common_cells\lfsr_8bit.sv.txt
"[Keyword]: lossy_valid_to_stream.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The `lossy_valid_to_stream` module is designed to handle data sources that use a valid-only interface, meaning they do not support backpressure. It acts as a FIFO with a depth of 2, allowing new data to overwrite the last element if the FIFO is full. This ensures that the input is always ready to accept new transactions, but intermediate transactions may be lost if the input rate exceeds the output consumption rate. The module outputs data in a ready-valid manner, ensuring data stability until the sink is ready to consume it.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronization.
- `rst_ni`: Active-low reset signal to initialize the module.
- `valid_i`: Input signal indicating the validity of `data_i`.
- `data_i`: Input data of type `T` (default width is 32 bits), representing the data to be processed.
- `ready_i`: Input signal from the sink indicating readiness to accept data.

[Output Signal Description]:
- `valid_o`: Output signal indicating the validity of `data_o`.
- `data_o`: Output data of type `T`, representing the data being sent to the sink.
- `busy_o`: Output status signal indicating if there are outstanding transactions (high if there are pending transactions).


[Design Detail]:
//-----------------------------------------------------------------------------
// Title : lossy_valid_to_stream
// -----------------------------------------------------------------------------
// File : lossy_valid_to_stream.sv Author : Manuel Eggimann
// <meggimann@iis.ee.ethz.ch> Created : 17.05.2023
// -----------------------------------------------------------------------------
// Description :
//
// This module helps to deal with sources that use a valid-only interface, that
// is they do not support backpressure i.e. cannot handle the case where the
// sink is not ready to accept a value. The module is implemented as FIFO with 2
// elements. In contrast to a regular FIFO that stops accepting new transactions
// once the FIFO is full, this IP overwrites the last element entered into the
// FIFO. This means the input is always ready to accept new transactions,
// however, intermediate transactions might be overwritten by the latest one. On
// the output side, the module behaves like a regular ready-valid source i.e.
// once valid is asserted, data_o remains stable until the sink consumes them
// (by asserting ready_i).

// IMPORTANT: As the name implies, this module might drop intermediate
// transactions if the input generates transactions faster than the sink can
// consume them. The input side can check if the last transaction was
// successfully comitted to the output by checking the
// busy_o signal. If it is de-asserted (low), there are no
// more outstanding transactions and the most recent value presented at the
// input side has been comitted to the output.
//
//
// The lossy_valid_to_stream module is helpful to connect configuration registers with
// IPs that could cause back pressure. In this case we might not care how long
// it takes for the config value to be sent to the IP but if we change the
// config value we want the latest value to be used regardless whether the
// previous value has already been forwarded or not.
//
//
//-----------------------------------------------------------------------------
// Copyright (C) 2023 ETH Zurich, University of Bologna Copyright and related
// rights are licensed under the Solderpad Hardware License, Version 0.51 (the
// ""License""); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law or
// agreed to in writing, software, hardware and materials distributed under this
// License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS
// OF ANY KIND, either express or implied. See the License for the specific
// language governing permissions and limitations under the License.
// SPDX-License-Identifier: SHL-0.51
// -----------------------------------------------------------------------------

module lossy_valid_to_stream #(
    /// Default data width if the fifo is of type logic
    parameter int unsigned DATA_WIDTH = 32,
    parameter type T = logic [DATA_WIDTH-1:0]
) (
    input  logic clk_i,
    input  logic rst_ni,
    // Input Interface (the input is always ready so there is no ready_o signal)
    input  logic valid_i,
    input  T     data_i,
    // Output Interface
    output logic valid_o,
    input  logic ready_i,
    output T     data_o,
    // Status port
    output busy_o
);

  // Implement a FIFO with depth == 2 where the write logic can overwrite the
  // last element.

  logic read_ptr_d, read_ptr_q;
  logic write_ptr_d, write_ptr_q;
  logic [1:0] pending_tx_counter_d, pending_tx_counter_q;
  T[1:0] mem_d, mem_q;

  assign valid_o = pending_tx_counter_q != 0 || valid_i;

  always_comb begin : write_logic
    write_ptr_d = write_ptr_q;
    mem_d       = mem_q;
    if (valid_i) begin
      // If the FIFO is empty and the output is currently ready, fall through
      // the FIFO and don't update anything
      if (pending_tx_counter_q != 0 || !ready_i) begin
        // If the FIFO is full and the output is still stalling, update the
        // previous element instead of writing a new one and do not update the
        // write pointer
        if (pending_tx_counter_q == 2 && !ready_i) begin
          mem_d[write_ptr_q - 1'b1] = data_i;
        end else begin
          mem_d[write_ptr_q] = data_i;
          write_ptr_d = write_ptr_q + 1'b1;
        end
      end
    end
  end

  always_comb begin : read_logic
    read_ptr_d = read_ptr_q;
    data_o = mem_q[read_ptr_q];
    // Handle the fall-through case
    if (pending_tx_counter_q == 0 && valid_i) begin
      data_o = data_i;
    end else if (valid_o && ready_i) begin
      read_ptr_d = read_ptr_q + 1'b1;
    end
  end

  always_comb begin: count_transactions
    pending_tx_counter_d = pending_tx_counter_q;
    if (valid_i && valid_o && ready_i) begin
      pending_tx_counter_d = pending_tx_counter_q;
    end else if (valid_i && !(valid_o && ready_i)) begin
      // If the FIFO is already full, do not update the counter
      if (pending_tx_counter_q != 2) begin
        pending_tx_counter_d = pending_tx_counter_q + 1'b1;
      end
    end else if (!valid_i && (valid_o && ready_i)) begin
      pending_tx_counter_d = pending_tx_counter_q - 1'b1;
    end
  end

  // Registers
  always_ff @(posedge clk_i, negedge rst_ni) begin
    if (!rst_ni) begin
      read_ptr_q           <= '0;
      write_ptr_q          <= '0;
      pending_tx_counter_q <= '0;
      mem_q                <= {2{T'('0)}};
    end else begin
      read_ptr_q           <= read_ptr_d;
      write_ptr_q          <= write_ptr_d;
      pending_tx_counter_q <= pending_tx_counter_d;
      mem_q                <= mem_d;
    end
  end

  assign busy_o = pending_tx_counter_q != 0;

endmodule
",lossy_valid_to_stream.sv.txt,common_cells\lossy_valid_to_stream.sv.txt
"[Keyword]: lzc.sv

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The module implements a zero counter that can operate in two modes: trailing zero count and leading zero count. When in trailing zero mode (MODE = 0), it counts the number of consecutive zeros starting from the least significant bit (LSB). When in leading zero mode (MODE = 1), it counts the number of consecutive zeros starting from the most significant bit (MSB). If the input vector contains no zeros, the `empty_o` signal is asserted, and `cnt_o` outputs the maximum number of zeros minus one.

[Input Signal Description]:
- `in_i [WIDTH-1:0]`: The input vector whose zeros are to be counted. The width of this vector is determined by the parameter `WIDTH`.

[Output Signal Description]:
- `cnt_o [CNT_WIDTH-1:0]`: Outputs the count of leading or trailing zeros based on the mode selected. The width of this output is determined by the parameter `CNT_WIDTH`.
- `empty_o`: A signal that is asserted when all bits in the input vector `in_i` are zero.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

`include ""common_cells/assertions.svh""

/// A trailing zero counter / leading zero counter.
/// Set MODE to 0 for trailing zero counter => cnt_o is the number of trailing zeros (from the LSB)
/// Set MODE to 1 for leading zero counter  => cnt_o is the number of leading zeros  (from the MSB)
/// If the input does not contain a zero, `empty_o` is asserted. Additionally `cnt_o` contains
/// the maximum number of zeros - 1. For example:
///   in_i = 000_0000, empty_o = 1, cnt_o = 6 (mode = 0)
///   in_i = 000_0001, empty_o = 0, cnt_o = 0 (mode = 0)
///   in_i = 000_1000, empty_o = 0, cnt_o = 3 (mode = 0)
/// Furthermore, this unit contains a more efficient implementation for Verilator (simulation only).
/// This speeds up simulation significantly.
module lzc #(
  /// The width of the input vector.
  parameter int unsigned WIDTH = 2,
  /// Mode selection: 0 -> trailing zero, 1 -> leading zero
  parameter bit          MODE  = 1'b0,
  /// Dependent parameter. Do **not** change!
  ///
  /// Width of the output signal with the zero count.
  parameter int unsigned CNT_WIDTH = cf_math_pkg::idx_width(WIDTH)
) (
  /// Input vector to be counted.
  input  logic [WIDTH-1:0]     in_i,
  /// Count of the leading / trailing zeros.
  output logic [CNT_WIDTH-1:0] cnt_o,
  /// Counter is empty: Asserted if all bits in in_i are zero.
  output logic                 empty_o
);

  if (WIDTH == 1) begin : gen_degenerate_lzc

    assign cnt_o[0] = !in_i[0];
    assign empty_o = !in_i[0];

  end else begin : gen_lzc

    localparam int unsigned NumLevels = $clog2(WIDTH);

  `ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(width_0, WIDTH > 0, ""input must be at least one bit wide"")
  `endif

    logic [WIDTH-1:0][NumLevels-1:0] index_lut;
    logic [2**NumLevels-1:0] sel_nodes;
    logic [2**NumLevels-1:0][NumLevels-1:0] index_nodes;

    logic [WIDTH-1:0] in_tmp;

    // reverse vector if required
    always_comb begin : flip_vector
      for (int unsigned i = 0; i < WIDTH; i++) begin
        in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];
      end
    end

    for (genvar j = 0; unsigned'(j) < WIDTH; j++) begin : g_index_lut
      assign index_lut[j] = (NumLevels)'(unsigned'(j));
    end

    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : g_levels
      if (unsigned'(level) == NumLevels - 1) begin : g_last_level
        for (genvar k = 0; k < 2 ** level; k++) begin : g_level
          // if two successive indices are still in the vector...
          if (unsigned'(k) * 2 < WIDTH - 1) begin : g_reduce
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2] | in_tmp[k * 2 + 1];
            assign index_nodes[2 ** level - 1 + k] = (in_tmp[k * 2] == 1'b1)
              ? index_lut[k * 2] :
                index_lut[k * 2 + 1];
          end
          // if only the first index is still in the vector...
          if (unsigned'(k) * 2 == WIDTH - 1) begin : g_base
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2];
            assign index_nodes[2 ** level - 1 + k] = index_lut[k * 2];
          end
          // if index is out of range
          if (unsigned'(k) * 2 > WIDTH - 1) begin : g_out_of_range
            assign sel_nodes[2 ** level - 1 + k] = 1'b0;
            assign index_nodes[2 ** level - 1 + k] = '0;
          end
        end
      end else begin : g_not_last_level
        for (genvar l = 0; l < 2 ** level; l++) begin : g_level
          assign sel_nodes[2 ** level - 1 + l] =
              sel_nodes[2 ** (level + 1) - 1 + l * 2] | sel_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
          assign index_nodes[2 ** level - 1 + l] = (sel_nodes[2 ** (level + 1) - 1 + l * 2] == 1'b1)
            ? index_nodes[2 ** (level + 1) - 1 + l * 2] :
              index_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
        end
      end
    end

    assign cnt_o = NumLevels > unsigned'(0) ? index_nodes[0] : {($clog2(WIDTH)) {1'b0}};
    assign empty_o = NumLevels > unsigned'(0) ? ~sel_nodes[0] : ~(|in_i);

  end : gen_lzc

`ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(width_0, WIDTH >= 1, ""The WIDTH must at least be one bit wide!"")
`endif

endmodule : lzc
",lzc.sv.txt,common_cells\lzc.sv.txt
"[Keyword]: max_counter.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements an up/down counter with the ability to track its maximum value. The counter can be incremented or decremented by a specified delta value, and it can be cleared or loaded with a new value. Additionally, the design keeps track of the maximum value the counter has reached and provides overflow indicators for both the current counter and the maximum value.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the counter operations.
- `rst_ni`: Active-low reset signal to initialize the counter and maximum value tracking.
- `clear_i`: Synchronous clear signal for resetting the counter value.
- `clear_max_i`: Synchronous clear signal for resetting the maximum value tracking.
- `en_i`: Enable signal to allow the counter to increment or decrement.
- `load_i`: Signal to load a new value into the counter.
- `down_i`: Signal to determine the counting direction; when high, the counter decrements.
- `delta_i`: The value by which the counter is incremented or decremented.
- `d_i`: The new value to be loaded into the counter when `load_i` is active.

[Output Signal Description]:
- `q_o`: The current value of the counter.
- `max_o`: The maximum value the counter has reached since the last reset or clear.
- `overflow_o`: Indicates if the counter has overflowed.
- `overflow_max_o`: Indicates if the maximum value tracking has overflowed.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Up/down counter that tracks its maximum value

module max_counter #(
    parameter int unsigned WIDTH = 4
) (
    input  logic             clk_i,
    input  logic             rst_ni,
    input  logic             clear_i,       // synchronous clear for counter
    input  logic             clear_max_i,   // synchronous clear for maximum value
    input  logic             en_i,          // enable the counter
    input  logic             load_i,        // load a new value
    input  logic             down_i,        // downcount, default is up
    input  logic [WIDTH-1:0] delta_i,       // counter delta
    input  logic [WIDTH-1:0] d_i,
    output logic [WIDTH-1:0] q_o,
    output logic [WIDTH-1:0] max_o,
    output logic             overflow_o,
    output logic             overflow_max_o
);
    logic [WIDTH-1:0] max_d, max_q;
    logic overflow_max_d, overflow_max_q;

    delta_counter #(
        .WIDTH           (WIDTH),
        .STICKY_OVERFLOW (1'b1)
    ) i_counter (
        .clk_i,
        .rst_ni,
        .clear_i,
        .en_i,
        .load_i,
        .down_i,
        .delta_i,
        .d_i,
        .q_o,
        .overflow_o
    );

    always_comb begin
        max_d = max_q;
        max_o = max_q;
        overflow_max_d = overflow_max_q;
        if (clear_max_i) begin
            max_d = '0;
            overflow_max_d = 1'b0;
        end else if (q_o > max_q) begin
            max_d = q_o;
            max_o = q_o;
            if (overflow_o) begin
                overflow_max_d = 1'b1;
            end
        end
    end

    assign overflow_max_o = overflow_max_q;

    always_ff @(posedge clk_i, negedge rst_ni) begin
        if (!rst_ni) begin
           max_q <= '0;
           overflow_max_q <= 1'b0;
        end else begin
           max_q <= max_d;
           overflow_max_q <= overflow_max_d;
        end
    end

endmodule
",max_counter.sv.txt,common_cells\max_counter.sv.txt
"[Keyword]: mem_to_banks.sv

[Design Category]: Memory Circuits

[Design Function Description]:
The design is a memory interface module that splits memory access requests over multiple parallel memory banks. Each bank has its own request and grant signals, allowing for parallel processing of memory transactions. This module handles the distribution of memory requests and responses across the banks, ensuring efficient memory access and management.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing operations.
- `rst_ni`: Asynchronous reset signal, active low, used to reset the module.
- `req_i`: Input signal indicating a valid memory request.
- `addr_i`: Input address signal for the memory request, specified byte-wise.
- `wdata_i`: Input data signal for write operations.
- `strb_i`: Write strobe signal indicating which bytes of `wdata_i` are valid.
- `atop_i`: Atomic operation signal from AXI4+ATOP protocol.
- `we_i`: Write enable signal, active high, indicating a write operation.
- `bank_gnt_i`: Grant signals from each memory bank, indicating if a bank can accept a request.
- `bank_rvalid_i`: Valid response signals from each memory bank, indicating if the read data is valid.
- `bank_rdata_i`: Read data signals from each memory bank.

[Output Signal Description]:
- `gnt_o`: Output signal indicating if the memory request can be granted.
- `rvalid_o`: Output signal indicating if the response data is valid.
- `rdata_o`: Output signal for the read data from the memory.
- `bank_req_o`: Request signals to each memory bank, indicating a valid request.
- `bank_addr_o`: Address signals to each memory bank, specified byte-wise.
- `bank_wdata_o`: Write data signals to each memory bank.
- `bank_strb_o`: Write strobe signals to each memory bank.
- `bank_atop_o`: Atomic operation signals to each memory bank.
- `bank_we_o`: Write enable signals to each memory bank, active high.


[Design Detail]:
// Copyright (c) 2022 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Wolfgang Roenninger <wroennin@ethz.ch>

/// Split memory access over multiple parallel banks, where each bank has its own req/gnt
/// request and valid response direction.
module mem_to_banks #(
  /// Input address width.
  parameter int unsigned AddrWidth = 32'd0,
  /// Input data width, must be a power of two.
  parameter int unsigned DataWidth = 32'd0,
  /// Atop width.
  parameter int unsigned AtopWidth = 32'd0,
  /// Number of banks at output, must evenly divide `DataWidth`.
  parameter int unsigned NumBanks  = 32'd1,
  /// Remove transactions that have zero strobe
  parameter bit          HideStrb  = 1'b0,
  /// Number of outstanding transactions
  parameter int unsigned MaxTrans  = 32'd1,
  /// FIFO depth, must be >=1
  parameter int unsigned FifoDepth = 32'd1,
  /// Atop type.
  parameter  type atop_t     = logic [AtopWidth-1:0],
  /// Dependent parameter, do not override! Address type.
  localparam type addr_t     = logic [AddrWidth-1:0],
  /// Dependent parameter, do not override! Input data type.
  localparam type inp_data_t = logic [DataWidth-1:0],
  /// Dependent parameter, do not override! Input write strobe type.
  localparam type inp_strb_t = logic [DataWidth/8-1:0],
  /// Dependent parameter, do not override! Output data type.
  localparam type oup_data_t = logic [DataWidth/NumBanks-1:0],
  /// Dependent parameter, do not override! Output write strobe type.
  localparam type oup_strb_t = logic [DataWidth/NumBanks/8-1:0]
) (
  /// Clock input.
  input  logic                      clk_i,
  /// Asynchronous reset, active low.
  input  logic                      rst_ni,
  /// Memory request to split, request is valid.
  input  logic                      req_i,
  /// Memory request to split, request can be granted.
  output logic                      gnt_o,
  /// Memory request to split, request address, byte-wise.
  input  addr_t                     addr_i,
  /// Memory request to split, request write data.
  input  inp_data_t                 wdata_i,
  /// Memory request to split, request write strobe.
  input  inp_strb_t                 strb_i,
  /// Memory request to split, request Atomic signal from AXI4+ATOP.
  input  atop_t                     atop_i,
  /// Memory request to split, request write enable, active high.
  input  logic                      we_i,
  /// Memory request to split, response is valid. Required for read and write requests
  output logic                      rvalid_o,
  /// Memory request to split, response read data.
  output inp_data_t                 rdata_o,
  /// Memory bank request, request is valid.
  output logic      [NumBanks-1:0]  bank_req_o,
  /// Memory bank request, request can be granted.
  input  logic      [NumBanks-1:0]  bank_gnt_i,
  /// Memory bank request, request address, byte-wise. Will be different for each bank.
  output addr_t     [NumBanks-1:0]  bank_addr_o,
  /// Memory bank request, request write data.
  output oup_data_t [NumBanks-1:0]  bank_wdata_o,
  /// Memory bank request, request write strobe.
  output oup_strb_t [NumBanks-1:0]  bank_strb_o,
  /// Memory bank request, request Atomic signal from AXI4+ATOP.
  output atop_t     [NumBanks-1:0]  bank_atop_o,
  /// Memory bank request, request write enable, active high.
  output logic      [NumBanks-1:0]  bank_we_o,
  /// Memory bank request, response is valid. Required for read and write requests
  input  logic      [NumBanks-1:0]  bank_rvalid_i,
  /// Memory bank request, response read data.
  input  oup_data_t [NumBanks-1:0]  bank_rdata_i
);

  mem_to_banks_detailed #(
    .AddrWidth  ( AddrWidth  ),
    .DataWidth  ( DataWidth  ),
    .WUserWidth ( AtopWidth  ),
    .RUserWidth ( 1          ),
    .NumBanks   ( NumBanks   ),
    .HideStrb   ( HideStrb   ),
    .MaxTrans   ( MaxTrans   ),
    .FifoDepth  ( FifoDepth  ),
    .wuser_t    ( atop_t     )
  ) i_mem_to_banks_detailed (
    .clk_i,
    .rst_ni,
    .req_i,
    .gnt_o,
    .addr_i,
    .wdata_i,
    .strb_i,
    .wuser_i      ( atop_i ),
    .we_i,
    .rvalid_o,
    .rdata_o,
    .ruser_o      (),
    .bank_req_o,
    .bank_gnt_i,
    .bank_addr_o,
    .bank_wdata_o,
    .bank_strb_o,
    .bank_wuser_o ( bank_atop_o ),
    .bank_we_o,
    .bank_rvalid_i,
    .bank_rdata_i,
    .bank_ruser_i ('0)
  );

endmodule
",mem_to_banks.sv.txt,common_cells\mem_to_banks.sv.txt
"[Keyword]: mem_to_banks_detailed.sv

[Design Category]: Memory Circuits

[Design Function Description]:
The module `mem_to_banks_detailed` is designed to split memory access requests over multiple parallel memory banks. Each bank has its own request/grant mechanism, allowing for parallel processing of memory operations. The module handles both read and write requests, distributing data and control signals across the specified number of banks. It also manages the alignment of addresses and the distribution of data and strobe signals to ensure correct memory operations.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing operations.
- `rst_ni`: Asynchronous reset signal, active low, to reset the module.
- `req_i`: Input signal indicating a valid memory request.
- `addr_i`: Address input for the memory request, byte-wise.
- `wdata_i`: Write data input for the memory request.
- `strb_i`: Write strobe input, indicating which bytes of `wdata_i` are valid.
- `wuser_i`: Sideband input for additional request information.
- `we_i`: Write enable input, active high, indicating a write operation.
- `bank_gnt_i`: Grant signals from each memory bank, indicating readiness to accept a request.
- `bank_rvalid_i`: Valid signals from each memory bank, indicating valid read data is available.
- `bank_rdata_i`: Read data from each memory bank.
- `bank_ruser_i`: Sideband data from each memory bank.

[Output Signal Description]:
- `gnt_o`: Output signal indicating the request can be granted.
- `rvalid_o`: Output signal indicating a valid response is available.
- `rdata_o`: Output read data from the memory banks.
- `ruser_o`: Output sideband data from the memory banks.
- `bank_req_o`: Request signals to each memory bank, indicating a valid request.
- `bank_addr_o`: Address signals to each memory bank, byte-wise.
- `bank_wdata_o`: Write data signals to each memory bank.
- `bank_strb_o`: Write strobe signals to each memory bank.
- `bank_wuser_o`: Sideband signals to each memory bank.
- `bank_we_o`: Write enable signals to each memory bank.


[Design Detail]:
// Copyright (c) 2022 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Wolfgang Roenninger <wroennin@ethz.ch>

`include ""common_cells/assertions.svh""

/// Split memory access over multiple parallel banks, where each bank has its own req/gnt
/// request and valid response direction.
module mem_to_banks_detailed #(
  /// Input address width.
  parameter int unsigned AddrWidth = 32'd0,
  /// Input data width, must be a power of two.
  parameter int unsigned DataWidth = 32'd0,
  /// Request sideband width.
  parameter int unsigned WUserWidth = 32'd0,
  /// Response sideband width.
  parameter int unsigned RUserWidth = 32'd0,
  /// Number of banks at output, must evenly divide `DataWidth`.
  parameter int unsigned NumBanks  = 32'd1,
  /// Remove transactions that have zero strobe
  parameter bit          HideStrb  = 1'b0,
  /// Number of outstanding transactions
  parameter int unsigned MaxTrans  = 32'd1,
  /// FIFO depth, must be >=1
  parameter int unsigned FifoDepth = 32'd1,
  /// Request sideband type.
  parameter  type wuser_t     = logic [WUserWidth-1:0],
  /// Dependent parameter, do not override! Address type.
  localparam type addr_t      = logic [AddrWidth-1:0],
  /// Dependent parameter, do not override! Input data type.
  localparam type inp_data_t  = logic [DataWidth-1:0],
  /// Dependent parameter, do not override! Input write strobe type.
  localparam type inp_strb_t  = logic [DataWidth/8-1:0],
  /// Dependent parameter, do not override! Input response sideband type.
  localparam type inp_ruser_t = logic [NumBanks-1:0][RUserWidth-1:0],
  /// Dependent parameter, do not override! Output data type.
  localparam type oup_data_t  = logic [DataWidth/NumBanks-1:0],
  /// Dependent parameter, do not override! Output write strobe type.
  localparam type oup_strb_t  = logic [DataWidth/NumBanks/8-1:0],
  /// Dependent parameter, do not override! Output response sideband type.
  localparam type oup_ruser_t = logic [RUserWidth-1:0]
) (
  /// Clock input.
  input  logic                       clk_i,
  /// Asynchronous reset, active low.
  input  logic                       rst_ni,
  /// Memory request to split, request is valid.
  input  logic                       req_i,
  /// Memory request to split, request can be granted.
  output logic                       gnt_o,
  /// Memory request to split, request address, byte-wise.
  input  addr_t                      addr_i,
  /// Memory request to split, request write data.
  input  inp_data_t                  wdata_i,
  /// Memory request to split, request write strobe.
  input  inp_strb_t                  strb_i,
  /// Memory request to split, request sideband.
  input  wuser_t                     wuser_i,
  /// Memory request to split, request write enable, active high.
  input  logic                       we_i,
  /// Memory request to split, response is valid. Required for read and write requests
  output logic                       rvalid_o,
  /// Memory request to split, response read data.
  output inp_data_t                  rdata_o,
  /// Memory request to split, response sideband.
  output inp_ruser_t                 ruser_o,
  /// Memory bank request, request is valid.
  output logic       [NumBanks-1:0]  bank_req_o,
  /// Memory bank request, request can be granted.
  input  logic       [NumBanks-1:0]  bank_gnt_i,
  /// Memory bank request, request address, byte-wise. Will be different for each bank.
  output addr_t      [NumBanks-1:0]  bank_addr_o,
  /// Memory bank request, request write data.
  output oup_data_t  [NumBanks-1:0]  bank_wdata_o,
  /// Memory bank request, request write strobe.
  output oup_strb_t  [NumBanks-1:0]  bank_strb_o,
  /// Memory bank request, request sideband.
  output wuser_t     [NumBanks-1:0]  bank_wuser_o,
  /// Memory bank request, request write enable, active high.
  output logic       [NumBanks-1:0]  bank_we_o,
  /// Memory bank request, response is valid. Required for read and write requests
  input  logic       [NumBanks-1:0]  bank_rvalid_i,
  /// Memory bank request, response read data.
  input  oup_data_t  [NumBanks-1:0]  bank_rdata_i,
  /// Memory bank request, response sideband.
  input  oup_ruser_t [NumBanks-1:0]  bank_ruser_i
);

  localparam int unsigned DataBytes    = $bits(inp_strb_t);
  localparam int unsigned BitsPerBank  = $bits(oup_data_t);
  localparam int unsigned BytesPerBank = $bits(oup_strb_t);

  typedef struct packed {
    addr_t     addr;
    oup_data_t wdata;
    oup_strb_t strb;
    wuser_t    wuser;
    logic      we;
  } req_t;

  logic                 req_valid;
  logic [NumBanks-1:0]              req_ready,
                        resp_valid, resp_ready;
  req_t [NumBanks-1:0]  bank_req,
                        bank_oup;
  logic [NumBanks-1:0]  bank_req_internal,
                        bank_gnt_internal,
                        zero_strobe,
                        dead_response,
                        dead_response_unmasked;
  logic                 dead_write_fifo_full,
                        dead_write_fifo_empty;

  function automatic addr_t align_addr(input addr_t addr);
    return (addr >> $clog2(DataBytes)) << $clog2(DataBytes);
  endfunction

  // Handle requests.
  assign req_valid = req_i & gnt_o;
  for (genvar i = 0; unsigned'(i) < NumBanks; i++) begin : gen_reqs
    assign bank_req[i].addr  = align_addr(addr_i) + i * BytesPerBank;
    assign bank_req[i].wdata = wdata_i[i*BitsPerBank+:BitsPerBank];
    assign bank_req[i].strb  = strb_i[i*BytesPerBank+:BytesPerBank];
    assign bank_req[i].wuser = wuser_i;
    assign bank_req[i].we    = we_i;
    stream_fifo #(
      .FALL_THROUGH ( 1'b1         ),
      .DATA_WIDTH   ( $bits(req_t) ),
      .DEPTH        ( FifoDepth    ),
      .T            ( req_t        )
    ) i_ft_reg (
      .clk_i,
      .rst_ni,
      .flush_i    ( 1'b0          ),
      .testmode_i ( 1'b0          ),
      .usage_o    (),
      .data_i     ( bank_req[i]   ),
      .valid_i    ( req_valid     ),
      .ready_o    ( req_ready[i]  ),
      .data_o     ( bank_oup[i]   ),
      .valid_o    ( bank_req_internal[i] ),
      .ready_i    ( bank_gnt_internal[i] )
    );
    assign bank_addr_o[i]  = bank_oup[i].addr;
    assign bank_wdata_o[i] = bank_oup[i].wdata;
    assign bank_strb_o[i]  = bank_oup[i].strb;
    assign bank_wuser_o[i] = bank_oup[i].wuser;
    assign bank_we_o[i]    = bank_oup[i].we;

    assign zero_strobe[i] = (bank_req[i].strb == '0);

    if (HideStrb) begin : gen_hide_strb
      assign bank_req_o[i] = (bank_oup[i].we && (bank_oup[i].strb == '0)) ?
                               1'b0 : bank_req_internal[i];
      assign bank_gnt_internal[i] = (bank_oup[i].we && (bank_oup[i].strb == '0)) ?
                                      1'b1 : bank_gnt_i[i];
    end else begin : gen_legacy_strb
      assign bank_req_o[i] = bank_req_internal[i];
      assign bank_gnt_internal[i] = bank_gnt_i[i];
    end
  end

  // Grant output if all our requests have been granted.
  assign gnt_o = (&req_ready) & (&resp_ready) & !dead_write_fifo_full;

  if (HideStrb) begin : gen_dead_write_fifo
    fifo_v3 #(
      .FALL_THROUGH ( 1'b0     ),
      .DEPTH        ( MaxTrans+1 ),
      .DATA_WIDTH   ( NumBanks )
    ) i_dead_write_fifo (
      .clk_i,
      .rst_ni,
      .flush_i    ( 1'b0                           ),
      .testmode_i ( 1'b0                           ),
      .full_o     ( dead_write_fifo_full           ),
      .empty_o    ( dead_write_fifo_empty          ),
      .usage_o    (),
      .data_i     ( {NumBanks{we_i}} & zero_strobe ),
      .push_i     ( req_i & gnt_o                  ),
      .data_o     ( dead_response_unmasked         ),
      .pop_i      ( rvalid_o                       )
    );
    assign dead_response = dead_response_unmasked & {NumBanks{~dead_write_fifo_empty}};
  end else begin : gen_no_dead_write_fifo
    assign dead_response_unmasked = '0;
    assign dead_response = '0;
    assign dead_write_fifo_full = 1'b0;
    assign dead_write_fifo_empty = 1'b1;
  end

  // Handle responses.
  for (genvar i = 0; unsigned'(i) < NumBanks; i++) begin : gen_resp_regs
    stream_fifo #(
      .FALL_THROUGH ( 1'b1              ),
      .DATA_WIDTH   ( $bits(oup_data_t) + $bits(oup_ruser_t) ),
      .DEPTH        ( FifoDepth         )
    ) i_ft_reg (
      .clk_i,
      .rst_ni,
      .flush_i    ( 1'b0                                              ),
      .testmode_i ( 1'b0                                              ),
      .usage_o    (),
      .data_i     ( {bank_rdata_i[i], bank_ruser_i[i]}                ),
      .valid_i    ( bank_rvalid_i[i]                                  ),
      .ready_o    ( resp_ready[i]                                     ),
      .data_o     ( {rdata_o[i*BitsPerBank+:BitsPerBank], ruser_o[i]} ),
      .valid_o    ( resp_valid[i]                                     ),
      .ready_i    ( rvalid_o & !dead_response[i]                      )
    );
  end
  assign rvalid_o = &(resp_valid | dead_response);

  // Assertions
  `ifndef COMMON_CELLS_ASSERTS_OFF
    initial begin
      `ASSUME_I(datawidth_not_power_of_2, DataWidth != 0 && 2**$clog2(DataWidth) == DataWidth,
               ""Data width must be a power of two!"")
      `ASSUME_I(datawidth_not_divisible_by_banks, DataWidth % NumBanks == 0,
               ""Data width must be evenly divisible over banks!"")
      `ASSUME_I(bank_datawidth_not_divisible_by_8, (DataWidth / NumBanks) % 8 == 0,
               ""Data width of each bank must be divisible into 8-bit bytes!"")
    end
  `endif
endmodule
",mem_to_banks_detailed.sv.txt,common_cells\mem_to_banks_detailed.sv.txt
"[Keyword]: multiaddr_decode.sv

[Design Category]: Combinational Logic

[Design Function Description]:
The design is a multi-address decoder that takes an address set represented by an address and a mask and determines which rules in a given address map match the input address set. It outputs a bitmask indicating the matching rules and provides the subset of addresses that match each rule. The design also indicates whether a valid match was found or if there was an error due to no matching rules.

[Input Signal Description]:
- `addr_i`: The input address to be decoded, represented in a specific address type (`addr_t`).
- `mask_i`: The mask associated with the input address, indicating which bits are ""don't care"" in the address.
- `addr_map_i`: An array of rules, each containing an index, an address, and a mask, representing the address map to be checked against the input address.

[Output Signal Description]:
- `select_o`: A bitmask indicating which rules in the address map match the input address set.
- `addr_o`: The subset of addresses from the input address set that match each rule.
- `mask_o`: The corresponding masks for the matched addresses.
- `dec_valid_o`: A signal indicating if a valid match was found.
- `dec_error_o`: A signal indicating if no matching rule was found, resulting in an error.


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Luca Colagrande <colluca@ethz.ch>

`include ""common_cells/assertions.svh""

/// Multi-address Decoder: Combinational module which takes an address set
/// in {addr, mask} representation and returns a bit mask `select_o` indicating which
/// address map rules in `addr_map_i` it matches.
///
/// An address set is a set of addresses. The {addr, mask} pair is one possible way of encoding
/// an address set. Asserted bits in the mask indicate that the corresponding bit in addr can
/// be treated as a ""don't care"", meaning it can assume any value (0 or 1) to produce a valid
/// address in the address set.
///
/// The address map `addr_map_i` is a packed array of rule_t structs. Each rule is itself an
/// address set.
///
/// For each rule the decoder checks if there is an address in the {`addr_i`, `mask_i`} address
/// set which belongs to the address set of the rule. If so, the corresponding bit in `select_o`
/// is set.
/// For each rule, it also returns the subset of addresses in {`addr_i`, `mask_i`} which
/// match the rule {`addr_o[i]`, `mask_o[i]`}.
module multiaddr_decode #(
  /// Highest index which can happen in a rule.
  parameter int unsigned NoIndices = 32'd0,
  /// Total number of rules.
  parameter int unsigned NoRules   = 32'd0,
  /// Address type inside the rules and to decode.
  parameter type         addr_t    = logic,
  /// Rule packed struct type.
  /// The address decoder expects three fields in `rule_t`:
  ///
  /// typedef struct packed {
  ///   int unsigned idx;
  ///   addr_t       addr;
  ///   addr_t       mask;
  /// } rule_t;
  ///
  ///  - `idx`:   index of the rule, has to be < `NoIndices`.
  ///  - `addr`:  any address in the address space described by the rule
  ///  - `mask`:  a bitmask of the same length as the address which transforms the address
  ///             above in a multi-address encoding. A '1' in this mask indicates that the
  ///             corresponding bit in address can take any value and it will still be part
  ///             of this rule's address space.
  ///
  /// {addr, mask} is an alternative representation to the typical interval [start, end)
  /// representation for a collection of addresses. With {addr, mask} we can represent contiguous
  /// intervals of the form [start, end) so long that the latter satisfies the following properties:
  /// - the length of the interval (end - start) is a power of 2 (i.e. 2^N for some integer N)
  /// - the offset of the interval (start) is a multiple of the length
  ///   (i.e. M*2^N for some integer M)
  /// When these properties are satisfied we can go from the [start, end) representation
  /// to the {addr, mask} representation (and viceversa) using the following equations:
  /// - mask =  {'0, {log2(end - start){1'b1}}}
  /// - addr = start
  parameter type         rule_t    = logic
) (
  /// Multi-address to decode.
  input  addr_t                 addr_i,
  input  addr_t                 mask_i,
  /// Address map.
  input  rule_t [NoRules-1:0]   addr_map_i,
  /// Decoded indices.
  output logic  [NoIndices-1:0] select_o,
  /// Decoded multi-address.
  output addr_t [NoIndices-1:0] addr_o,
  output addr_t [NoIndices-1:0] mask_o,
  /// Decode is valid.
  output logic                  dec_valid_o,
  /// Decode is not valid, no matching rule found.
  output logic                  dec_error_o
);

  logic [NoRules-1:0] matched_rules; // purely for address map debugging

  always_comb begin
    // default assignments
    matched_rules = '0;
    dec_valid_o   = 1'b0;
    dec_error_o   = 1'b1;
    select_o      = '0;
    addr_o        = '0;
    mask_o        = '0;

    // Match the rules
    for (int unsigned i = 0; i < NoRules; i++) begin
      automatic int unsigned idx = addr_map_i[i].idx;
      // We have a match if at least one address of the input
      // address set is a part of the rule's address set.
      // We have this condition when all bits in the input address match
      // all bits in `addr_map_i[i].addr`, with possible exception
      // of those bits which are either masked in the input address
      // or in the addrmap rule. In other words, any bit which is masked
      // either in the input address or in the addrmap rule is treated as a don't care
      automatic addr_t dont_care = mask_i | addr_map_i[i].mask;
      automatic addr_t matching_bits = ~(addr_i ^ addr_map_i[i].addr);
      automatic logic match = &(dont_care | matching_bits);
      if (match) begin
        matched_rules[i] = 1'b1;
        dec_valid_o      = 1'b1;
        dec_error_o      = 1'b0;
        select_o[idx]   |= 1'b1;
        // When there is a partial match, i.e. only a subset of the input address set
        // falls in the address set of the rule, we want to return this subset
        // {addr_o, mask_o}.
        // Bits which are masked in the input address but not in the addrmap rule
        // are resolved to the value in the addrmap, and are thus unmasked in the
        // output address set. All other bits remain masked or unchanged.
        mask_o[idx] = mask_i & addr_map_i[i].mask;
        addr_o[idx] = (~mask_i & addr_i) | (mask_i & addr_map_i[i].addr);
      end
    end
  end

  // Assumptions and assertions
  `ifndef COMMON_CELLS_ASSERTS_OFF
  initial begin : proc_check_parameters
    `ASSUME_I(norules_0, NoRules > 0, $sformatf(""At least one rule needed""))
    `ASSUME_I(addr_width_not_equal, $bits(addr_i) == $bits(addr_map_i[0].addr),
             $sformatf(""Input address has %d bits and address map has %d bits."",
                       $bits(addr_i), $bits(addr_map_i[0].addr)))
  end

  // These following assumptions check the validity of the address map.
  // check_idx: Enforces a valid index in the rule.
  `ifndef SYNTHESIS
  always_comb begin : proc_check_addr_map
    if (!$isunknown(addr_map_i)) begin
      for (int unsigned i = 0; i < NoRules; i++) begin
        // check the SLV ids
        `ASSUME_I(check_idx, addr_map_i[i].idx < NoIndices,
            $sformatf(""This rule has a IDX that is not allowed!!!\n\
            Violating rule %d.\n\
            Rule> IDX: %h\n\
            Rule> MAX_IDX: %h\n\
            #####################################################"",
            i, addr_map_i[i].idx, (NoIndices-1)))
      end
    end
  end
  `endif
  `endif
endmodule
",multiaddr_decode.sv.txt,common_cells\multiaddr_decode.sv.txt
"[Keyword]: mv_filter.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a moving average filter with a threshold mechanism. It counts the number of consecutive high input samples (`d_i`) and sets the output (`q_o`) high if the count reaches a specified threshold. The counter can be reset asynchronously with `rst_ni` or synchronously with `clear_i`.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the sequential logic.
- `rst_ni`: Active-low asynchronous reset signal to initialize the counter and output.
- `sample_i`: Signal indicating when to sample the input `d_i`.
- `clear_i`: Signal to synchronously clear the counter and reset the output.
- `d_i`: Input data signal to be sampled and counted.

[Output Signal Description]:
- `q_o`: Output signal that goes high when the count of consecutive high samples reaches the threshold.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>

module mv_filter #(
    parameter int unsigned WIDTH     = 4,
    parameter int unsigned THRESHOLD = 10
)(
    input  logic clk_i,
    input  logic rst_ni,
    input  logic sample_i,
    input  logic clear_i,
    input  logic d_i,
    output logic q_o
);
    logic [WIDTH-1:0] counter_q, counter_d;
    logic d, q;

    assign q_o = q;

    always_comb begin
        counter_d = counter_q;
        d = q;

        if (counter_q >= THRESHOLD[WIDTH-1:0]) begin
            d = 1'b1;
        end else if (sample_i && d_i) begin
            counter_d = counter_q + 1;
        end

        // sync reset
        if (clear_i) begin
            counter_d = '0;
            d = 1'b0;
        end
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (~rst_ni) begin
            counter_q <= '0;
            q         <= 1'b0;
        end else begin
            counter_q <= counter_d;
            q         <= d;
        end
    end
endmodule
",mv_filter.sv.txt,common_cells\mv_filter.sv.txt
"[Keyword]: onehot_to_bin.sv

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit converts a one-hot encoded input signal into a binary representation. A one-hot encoded signal has exactly one bit set to '1' and all other bits set to '0'. This module takes such a signal and outputs the binary index of the bit that is set to '1'.

[Input Signal Description]:
`onehot[ONEHOT_WIDTH-1:0]`: A one-hot encoded input signal of width `ONEHOT_WIDTH`. Only one bit in this vector should be set to '1', and the rest should be '0'.

[Output Signal Description]:
`bin[BIN_WIDTH-1:0]`: A binary output signal representing the index of the bit set to '1' in the `onehot` input. The width of this output is determined by the parameter `BIN_WIDTH`, which is calculated as the ceiling of the logarithm base 2 of `ONEHOT_WIDTH`.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Franceco Conti <fconti@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

module onehot_to_bin #(
    parameter int unsigned ONEHOT_WIDTH = 16,
    // Do Not Change
    parameter int unsigned BIN_WIDTH    = ONEHOT_WIDTH == 1 ? 1 : $clog2(ONEHOT_WIDTH)
)   (
    input  logic [ONEHOT_WIDTH-1:0] onehot,
    output logic [BIN_WIDTH-1:0]    bin
);

    for (genvar j = 0; j < BIN_WIDTH; j++) begin : gen_jl
        logic [ONEHOT_WIDTH-1:0] tmp_mask;
            for (genvar i = 0; i < ONEHOT_WIDTH; i++) begin : gen_il
                logic [BIN_WIDTH-1:0] tmp_i;
                assign tmp_i = BIN_WIDTH'(i);
                assign tmp_mask[i] = tmp_i[j];
            end
        assign bin[j] = |(tmp_mask & onehot);
    end

`ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_FINAL(more_than_2_bits, $onehot0(onehot), ""More than two bit set in the one-hot signal"")
`endif
endmodule
",onehot_to_bin.sv.txt,common_cells\onehot_to_bin.sv.txt
"[Keyword]: passthrough_stream_fifo.sv

[Design Category]: Memory Circuits

[Design Function Description]:
The design is a passthrough stream FIFO (First-In-First-Out) buffer that allows simultaneous read and write operations when full, provided data is popped in the same cycle. This design aims to efficiently utilize buffer space by allowing data to be pushed into the FIFO even when it is full, as long as data is also being read out in the same cycle. This can create longer timing paths but improves buffer utilization.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the operations.
- `rst_ni`: Asynchronous reset signal, active low, used to reset the FIFO.
- `flush_i`: Signal to flush the FIFO, resetting read and write pointers.
- `testmode_i`: Bypass clock gate for testing purposes.
- `data_i`: Input data to be pushed into the FIFO.
- `valid_i`: Indicates that the input data is valid and ready to be pushed into the FIFO.
- `ready_i`: Indicates that the FIFO is ready to pop data from the head.

[Output Signal Description]:
- `ready_o`: Indicates that the FIFO is not full and can accept more data.
- `data_o`: Output data from the FIFO.
- `valid_o`: Indicates that the FIFO is not empty and data is available to be read.


[Design Detail]:
// Copyright 2024 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// Authors:
// - Thomas Benz  <tbenz@iis.ee.ethz.ch>
// - Tobias Senti <tsenti@ethz.ch>

`include ""common_cells/assertions.svh""
`include ""common_cells/registers.svh""

/// Stream FIFO that does not cut the timing path. When full; pushing data is allowed if in
/// the same cycle data is popped. Creates longer timing paths but can use buffer space more
/// efficiently.
module passthrough_stream_fifo #(
    /// Depth can be arbitrary from 2 to 2**32
    parameter int unsigned Depth       = 32'd8,
    /// Print information when the simulation launches
    parameter bit          PrintInfo   = 1'b0,
    /// If the FIFO is full, allow reading and writing in the same cycle
    parameter bit          SameCycleRW = 1'b1,
    /// Type of the FIFO
    parameter type         type_t      = logic
) (
    /// Clock
    input  logic                 clk_i,
    /// Asynchronous reset active low
    input  logic                 rst_ni,
    /// Fifo flush
    input  logic                 flush_i,
    /// Bypass clock gate
    input  logic                 testmode_i,
    /// data to push into the FIFO
    input  type_t                data_i,
    /// input data valid
    input  logic                 valid_i,
    /// FIFO is not full
    output logic                 ready_o,
    /// output data
    output type_t                data_o,
    /// FIFO is not empty
    output logic                 valid_o,
    /// pop head from FIFO
    input  logic                 ready_i
);
    /// Bit Width of the read and write pointers
    /// One additional bit to detect overflows
    localparam int unsigned PointerWidth = $clog2(Depth) + 1;

    // Read and write pointers
    logic [PointerWidth-1:0]  read_ptr_d,  read_ptr_q;
    logic [PointerWidth-1:0] write_ptr_d, write_ptr_q;

    // Data
    type_t [Depth-1 :0] data_d, data_q;

    // Enable storage
    logic load_data;

    assign data_o = data_q[read_ptr_q[PointerWidth-2:0]];

    // Logic
    always_comb begin
        // Default
        load_data   = 1'b0;
        read_ptr_d  = read_ptr_q;
        write_ptr_d = write_ptr_q;
        data_d      = data_q;

        if (flush_i) begin // Flush
            read_ptr_d  = '0;
            write_ptr_d = '0;
            valid_o     = 1'b0;
            ready_o     = 1'b0;
        end else begin
            // Read
            valid_o = read_ptr_q[PointerWidth-1] == write_ptr_q[PointerWidth-1]
                ? read_ptr_q[PointerWidth-2:0] != write_ptr_q[PointerWidth-2:0] : 1'b1;
            if (ready_i) begin
                if (read_ptr_q[PointerWidth-2:0] == (Depth-1)) begin
                    // On overflow reset pointer to zero and flip imaginary bit
                    read_ptr_d[PointerWidth-2:0] = '0;
                    read_ptr_d[PointerWidth-1]   = !read_ptr_q[PointerWidth-1];
                end else begin
                    // Increment counter
                    read_ptr_d = read_ptr_q + 'd1;
                end
            end

            // Write -> Also able to write if we read in the same cycle
            ready_o     = (read_ptr_q[PointerWidth-1] == write_ptr_q[PointerWidth-1]
                ? 1'b1 : write_ptr_q[PointerWidth-2:0] != read_ptr_q[PointerWidth-2:0])
                || (SameCycleRW && ready_i && valid_o);

            if (valid_i) begin
                load_data = 1'b1;
                data_d[write_ptr_q[PointerWidth-2:0]] = data_i;

                if (write_ptr_q[PointerWidth-2:0] == (Depth-1)) begin
                    // On overflow reset pointer to zero and flip imaginary bit
                    write_ptr_d[PointerWidth-2:0] = '0;
                    write_ptr_d[PointerWidth-1]   = !write_ptr_q[PointerWidth-1];
                end else begin
                    // Increment pointer
                    write_ptr_d = write_ptr_q + 'd1;
                end
            end
        end
    end

    // Flip Flops
    `FF( read_ptr_q,  read_ptr_d, '0, clk_i, rst_ni)
    `FF(write_ptr_q, write_ptr_d, '0, clk_i, rst_ni)

    `FFL(data_q, data_d, load_data, '0, clk_i, rst_ni)

    // no full push
    `ASSERT_NEVER(CheckFullPush, (!ready_o & valid_i), clk_i, !rst_ni)
    // empty pop
    `ASSERT_NEVER(CheckEmptyPop, (!valid_o & ready_i), clk_i, !rst_ni)

endmodule
",passthrough_stream_fifo.sv.txt,common_cells\passthrough_stream_fifo.sv.txt
"[Keyword]: plru_tree.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design implements a Pseudo Least Recently Used (PLRU) tree, which is a cache replacement policy used to track the usage of cache lines and determine the least recently used line for replacement. The PLRU tree structure efficiently updates and determines the least recently used entry in a set-associative cache.

[Input Signal Description]:
- `clk_i`: Clock input signal used to synchronize the updates of the PLRU tree.
- `rst_ni`: Active-low reset signal to initialize or reset the PLRU tree state.
- `used_i[ENTRIES-1:0]`: One-hot input signal indicating which cache entry was recently used. Each bit corresponds to a specific entry.

[Output Signal Description]:
- `plru_o[ENTRIES-1:0]`: One-hot output signal indicating which cache entry is the least recently used and should be replaced. Each bit corresponds to a specific entry.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: David Schaffenrath, TU Graz
// Author: Florian Zaruba, ETH Zurich
//
// Description: Pseudo Least Recently Used Tree (PLRU)
// See: https://en.wikipedia.org/wiki/Pseudo-LRU

`include ""common_cells/assertions.svh""

module plru_tree #(
  parameter int unsigned ENTRIES = 16
) (
  input  logic               clk_i,
  input  logic               rst_ni,
  input  logic [ENTRIES-1:0] used_i, // element i was used (one hot)
  output logic [ENTRIES-1:0] plru_o  // element i is the least recently used (one hot)
);

    localparam int unsigned LogEntries = $clog2(ENTRIES);

    logic [2*(ENTRIES-1)-1:0] plru_tree_q, plru_tree_d;

    always_comb begin : plru_replacement
        automatic int unsigned idx_base, shift;
        automatic logic new_index;
        idx_base    = 0;
        shift       = 0;
        new_index   = 1'b0;
        plru_tree_d = plru_tree_q;
        // The PLRU-tree indexing:
        // lvl0        0
        //            / \
        //           /   \
        // lvl1     1     2
        //         / \   / \
        // lvl2   3   4 5   6
        //       / \ /\/\  /\
        //      ... ... ... ...
        // Just predefine which nodes will be set/cleared
        // E.g. for a TLB with 8 entries, the for-loop is semantically
        // equivalent to the following pseudo-code:
        // unique case (1'b1)
        // used_i[7]: plru_tree_d[0, 2, 6] = {1, 1, 1};
        // used_i[6]: plru_tree_d[0, 2, 6] = {1, 1, 0};
        // used_i[5]: plru_tree_d[0, 2, 5] = {1, 0, 1};
        // used_i[4]: plru_tree_d[0, 2, 5] = {1, 0, 0};
        // used_i[3]: plru_tree_d[0, 1, 4] = {0, 1, 1};
        // used_i[2]: plru_tree_d[0, 1, 4] = {0, 1, 0};
        // used_i[1]: plru_tree_d[0, 1, 3] = {0, 0, 1};
        // used_i[0]: plru_tree_d[0, 1, 3] = {0, 0, 0};
        // default: begin /* No hit */ end
        // endcase
        for (int unsigned i = 0; i < ENTRIES; i++) begin
            // we got a hit so update the pointer as it was least recently used
            if (used_i[i]) begin
                // Set the nodes to the values we would expect
                for (int unsigned lvl = 0; lvl < LogEntries; lvl++) begin
                  idx_base = $unsigned((2**lvl)-1);
                  // lvl0 <=> MSB, lvl1 <=> MSB-1, ...
                  shift = LogEntries - lvl;
                  // to circumvent the 32 bit integer arithmetic assignment
                  new_index = 1'(~(i >> (shift-1)));
                  plru_tree_d[idx_base + (i >> shift)] = new_index;
                end
            end
        end
    end

    always_comb begin : plru_output
        automatic int unsigned idx_base, shift;
        automatic logic new_index;
        idx_base  = 0;
        shift     = 0;
        new_index = 1'b0;
        plru_o    = '1;
        // Decode tree to write enable signals
        // Next for-loop basically creates the following logic for e.g. an 8 entry
        // TLB (note: pseudo-code obviously):
        // plru_o[7] = &plru_tree_q[ 6, 2, 0]; //plru_tree_q[0,2,6]=={1,1,1}
        // plru_o[6] = &plru_tree_q[~6, 2, 0]; //plru_tree_q[0,2,6]=={1,1,0}
        // plru_o[5] = &plru_tree_q[ 5,~2, 0]; //plru_tree_q[0,2,5]=={1,0,1}
        // plru_o[4] = &plru_tree_q[~5,~2, 0]; //plru_tree_q[0,2,5]=={1,0,0}
        // plru_o[3] = &plru_tree_q[ 4, 1,~0]; //plru_tree_q[0,1,4]=={0,1,1}
        // plru_o[2] = &plru_tree_q[~4, 1,~0]; //plru_tree_q[0,1,4]=={0,1,0}
        // plru_o[1] = &plru_tree_q[ 3,~1,~0]; //plru_tree_q[0,1,3]=={0,0,1}
        // plru_o[0] = &plru_tree_q[~3,~1,~0]; //plru_tree_q[0,1,3]=={0,0,0}
        // For each entry traverse the tree. If every tree-node matches,
        // the corresponding bit of the entry's index, this is
        // the next entry to replace.
        for (int unsigned i = 0; i < ENTRIES; i += 1) begin
            for (int unsigned lvl = 0; lvl < LogEntries; lvl++) begin
                idx_base = $unsigned((2**lvl)-1);
                // lvl0 <=> MSB, lvl1 <=> MSB-1, ...
                shift = LogEntries - lvl;
                // plru_o[i] &= plru_tree_q[idx_base + (i>>shift)] == ((i >> (shift-1)) & 1'b1);
                new_index = 1'(i >> (shift-1));
                if (new_index) begin
                  plru_o[i] &= plru_tree_q[idx_base + (i>>shift)];
                end else begin
                  plru_o[i] &= ~plru_tree_q[idx_base + (i>>shift)];
                end
            end
        end
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (!rst_ni) begin
            plru_tree_q <= '0;
        end else begin
            plru_tree_q <= plru_tree_d;
        end
    end

`ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(entries_not_power_of_2, ENTRIES == 2**LogEntries, ""Entries must be a power of two"")

    `ASSERT(output_onehot, $onehot0(plru_o), clk_i, !rst_ni,
            ""More than one bit set in PLRU output."")
`endif

endmodule
",plru_tree.sv.txt,common_cells\plru_tree.sv.txt
"[Keyword]: popcount.sv

[Design Category]: Combinational Logic

[Design Function Description]:  
This module calculates the Hamming weight, which is the number of '1's in the input vector. The module is parameterized to handle any input width greater than or equal to 1. The output width is determined by the ceiling of the logarithm base 2 of the input width plus one, ensuring it can represent the count of '1's in the input.

[Input Signal Description]:  
`data_i[INPUT_WIDTH-1:0]`: A vector input of width specified by the parameter `INPUT_WIDTH`, containing the bits whose Hamming weight is to be calculated.

[Output Signal Description]:  
`popcount_o[PopcountWidth-1:0]`: The output signal representing the number of '1's in the input vector. The width of this output is determined by `PopcountWidth`, which is calculated as the ceiling of the logarithm base 2 of `INPUT_WIDTH` plus one.


[Design Detail]:
// Copyright (C) 2013-2018 ETH Zurich, University of Bologna
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Manuel Eggimann <meggimann@iis.ee.ethz.ch>

// Description: This module calculates the hamming weight (number of ones) in
// its input vector. Any unsigned INPUT_WIDTH larger or equal 1 is legal. The output result
// width is ceil(log2(INPUT_WIDTH))+1.
//
// This module used to be implemented using a binary added tree. However,
// the heuristics of modern logic Synthesizers work much better with a flat high
// level description using a for loop and yield exactly the same or even better results.


module popcount #(
    parameter  int unsigned INPUT_WIDTH   = 256,
    localparam int unsigned PopcountWidth = $clog2(INPUT_WIDTH) + 1
) (
    input  logic [  INPUT_WIDTH-1:0] data_i,
    output logic [PopcountWidth-1:0] popcount_o
);

  if (INPUT_WIDTH < 1)
    $error(""INPUT_WIDTH must be larger or equal to 1."");

  always_comb begin
    popcount_o = 0;
    for (int i = 0; i < INPUT_WIDTH; i++) begin
      popcount_o += data_i[i];
    end
  end

endmodule : popcount
",popcount.sv.txt,common_cells\popcount.sv.txt
"[Keyword]: prioarbiter.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design is a priority arbiter with a lock-in feature. It manages multiple request signals, granting access based on a fixed priority order. Port 0 has the highest priority, followed by port 1, and so on. If the lock-in feature is enabled, the arbiter retains its decision even when the enable signal is low, until a reset or flush occurs.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronous operations.
- `rst_ni`: Active-low reset signal to initialize or reset the arbiter.
- `flush_i`: Signal to clear the finite state machine and control signal registers.
- `en_i`: Enable signal for the arbiter to process requests.
- `req_i[NUM_REQ-1:0]`: Request signals from different ports, where each bit represents a request from a specific port.

[Output Signal Description]:
- `ack_o[NUM_REQ-1:0]`: Acknowledge signals corresponding to each request, indicating which request has been granted.
- `vld_o`: Valid output signal indicating that a request has been acknowledged.
- `idx_o[$clog2(NUM_REQ)-1:0]`: Index output representing the port number of the granted request.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>, ETH Zurich
// Date: 16.03.2019
// Description: Priority arbiter with Lock in. Port 0 has priority over port 1, port 1 over port2
//              and so on. If the `LOCK_IN` feature is activated the arbitration decision is kept
//              when the `en_i` is low.

// Dependencies: relies on fast leading zero counter tree ""onehot_to_bin"" in common_cells
module prioarbiter #(
  parameter int unsigned NUM_REQ = 13,
  parameter int unsigned LOCK_IN = 0
) (
  input logic                         clk_i,
  input logic                         rst_ni,

  input logic                         flush_i, // clears the fsm and control signal registers
  input logic                         en_i,    // arbiter enable
  input logic [NUM_REQ-1:0]           req_i,   // request signals

  output logic [NUM_REQ-1:0]          ack_o,   // acknowledge signals
  output logic                        vld_o,   // request ack'ed
  output logic [$clog2(NUM_REQ)-1:0]  idx_o    // idx output
);

  localparam SEL_WIDTH = $clog2(NUM_REQ);

  logic [SEL_WIDTH-1:0] arb_sel_lock_d, arb_sel_lock_q;
  logic lock_d, lock_q;

  logic [$clog2(NUM_REQ)-1:0] idx;

  // shared
  assign vld_o = (|req_i) & en_i;
  assign idx_o  = (lock_q) ? arb_sel_lock_q : idx;

  // Arbiter
  // Port 0 has priority over all other ports
  assign ack_o[0] = (req_i[0]) ? en_i : 1'b0;
  // check that the priorities
  for (genvar i = 1; i < NUM_REQ; i++) begin : gen_arb_req_ports
      // for every subsequent port check the priorities of the previous port
      assign ack_o[i] = (req_i[i] & ~(|ack_o[i-1:0])) ? en_i : 1'b0;
  end

  onehot_to_bin #(
    .ONEHOT_WIDTH ( NUM_REQ )
  ) i_onehot_to_bin (
    .onehot ( ack_o ),
    .bin    ( idx   )
  );

  if (LOCK_IN) begin : gen_lock_in
    // latch decision in case we got at least one req and no acknowledge
    assign lock_d         = (|req_i) & ~en_i;
    assign arb_sel_lock_d = idx_o;
  end else begin
    // disable
    assign lock_d         = '0;
    assign arb_sel_lock_d = '0;
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
    if (!rst_ni) begin
      lock_q         <= 1'b0;
      arb_sel_lock_q <= '0;
    end else begin
      if (flush_i) begin
        lock_q         <= 1'b0;
        arb_sel_lock_q <= '0;
      end else begin
        lock_q         <= lock_d;
        arb_sel_lock_q <= arb_sel_lock_d;
      end
    end
  end

endmodule : prioarbiter



",prioarbiter.sv.txt,common_cells\prioarbiter.sv.txt
"[Keyword]: pulp_sync.sv

[Design Category]: Sequential Logic

[Design Function Description]: 
The design is a multi-stage synchronizer used to safely transfer a serial input signal across clock domains. It consists of a series of flip-flops (determined by the parameter STAGES) that help mitigate metastability issues by synchronizing the input signal to the clock domain of the output.

[Input Signal Description]:
- clk_i: Clock input signal used to synchronize the flip-flops.
- rstn_i: Active-low reset signal that initializes the flip-flops to zero.
- serial_i: Serial input signal that is to be synchronized to the clock domain of the output.

[Output Signal Description]:
- serial_o: Synchronized output signal that is the result of the input signal passing through the series of flip-flops.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module pulp_sync
  #(
    parameter STAGES = 2
    )
   (
    input  logic clk_i,
    input  logic rstn_i,
    input  logic serial_i,
    output logic serial_o
    );
   
   logic [STAGES-1:0] r_reg;
   
   always_ff @(posedge clk_i, negedge rstn_i)
     begin
	if(!rstn_i)
          r_reg <= 'h0;
	else
          r_reg <= {r_reg[STAGES-2:0], serial_i};
     end
   
   assign serial_o   =  r_reg[STAGES-1];
   
endmodule
",pulp_sync.sv.txt,common_cells\pulp_sync.sv.txt
"[Keyword]: pulp_sync_wedge.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a synchronization and edge detection module. It synchronizes an input signal across clock domains and detects rising and falling edges of the input signal. The module uses a parameterized number of synchronization stages and includes clock gating for power efficiency.

[Input Signal Description]:
- `clk_i`: Clock input signal used for synchronization.
- `rstn_i`: Active-low reset signal to initialize or reset the module.
- `en_i`: Enable signal for clock gating, allowing the clock to be gated for power savings.
- `serial_i`: Serial input signal that is synchronized and monitored for edge detection.

[Output Signal Description]:
- `r_edge_o`: Output signal indicating a rising edge has been detected on the `serial_i` input.
- `f_edge_o`: Output signal indicating a falling edge has been detected on the `serial_i` input.
- `serial_o`: Synchronized output of the `serial_i` input signal.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module pulp_sync_wedge #(
    parameter int unsigned STAGES = 2
) (
    input  logic clk_i,
    input  logic rstn_i,
    input  logic en_i,
    input  logic serial_i,
    output logic r_edge_o,
    output logic f_edge_o,
    output logic serial_o
);
    logic clk;
    logic serial, serial_q;

    assign serial_o =  serial_q;
    assign f_edge_o = ~serial &  serial_q;
    assign r_edge_o =  serial & ~serial_q;

    pulp_sync #(
        .STAGES(STAGES)
    ) i_pulp_sync (
        .clk_i,
        .rstn_i,
        .serial_i,
        .serial_o ( serial )
    );

    pulp_clock_gating i_pulp_clock_gating (
        .clk_i,
        .en_i,
        .test_en_i ( 1'b0    ),
        .clk_o     ( clk )
    );

    always_ff @(posedge clk, negedge rstn_i) begin
        if (!rstn_i) begin
            serial_q <= 1'b0;
        end else begin
            serial_q <= serial;
        end
    end

endmodule
",pulp_sync_wedge.sv.txt,common_cells\pulp_sync_wedge.sv.txt
"[Keyword]: read.sv

[Design Category]: Combinational Logic

[Design Function Description]:
This is a simple pass-through circuit that assigns the input signal directly to the output signal. It is designed to prevent the signal from being removed during synthesis by using the `(* no_ungroup *)` attribute, which ensures that the module is not optimized away or altered during synthesis.

[Input Signal Description]:
d_i: A parameterized input signal of type T, which is a logic vector of width specified by the parameter `Width`. The default width is 1.

[Output Signal Description]:
d_o: A parameterized output signal of type T, which is a logic vector of the same width as the input signal `d_i`. It directly reflects the value of `d_i`.


[Design Detail]:
// Copyright 2022 EPFL
// Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1

// Author: Davide Schiavone, EPFL, OpenHW Group
// Date: 07.11.2022
// Description: Dummy circuit to assign a signal, prevent signal being removed after non-ungroupped synthesis compilation

(* no_ungroup *)
module read #(
    parameter int unsigned Width = 1,
    parameter type T = logic [Width-1:0]
) (
    input  T d_i,
    output T d_o
);

  assign d_o = d_i;

endmodule
",read.sv.txt,common_cells\read.sv.txt
"[Keyword]: rrarbiter.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design is a fair round-robin arbiter with a lock feature. It manages multiple request signals and grants access to one request at a time in a rotating priority order. The lock feature ensures that once a request is granted, the arbiter maintains the decision until it is re-enabled, even if the arbiter is disabled in the meantime.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronization.
- `rst_ni`: Active-low reset signal to initialize the arbiter.
- `flush_i`: Signal to clear the arbiter's state.
- `en_i`: Enable signal for the arbiter to process requests.
- `req_i[NUM_REQ-1:0]`: Array of request signals from different sources, where `NUM_REQ` is the number of requests.

[Output Signal Description]:
- `ack_o[NUM_REQ-1:0]`: Array of acknowledge signals corresponding to the request signals, indicating which request has been granted.
- `vld_o`: Valid signal indicating that a request has been acknowledged.
- `idx_o[$clog2(NUM_REQ)-1:0]`: Index output indicating which request has been granted.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
// Date: 16.08.2018
// Description: Fair round robin arbiter with lock feature.
//
// The rrarbiter employs fair round robin arbitration - i.e. the priorities
// rotate each cycle.
//
// The lock-in feature prevents the arbiter from changing the arbitration
// decision when the arbiter is disabled. I.e., the index of the first request
// that wins the arbitration will be locked until en_i is asserted again.
//
// Dependencies: relies on rr_arb_tree from common_cells.

module rrarbiter #(
  parameter int unsigned NUM_REQ   = 64,
  parameter bit          LOCK_IN   = 1'b0
) (
  input logic                         clk_i,
  input logic                         rst_ni,

  input logic                         flush_i, // clears arbiter state
  input logic                         en_i,    // arbiter enable
  input logic [NUM_REQ-1:0]           req_i,   // request signals

  output logic [NUM_REQ-1:0]          ack_o,   // acknowledge signals
  output logic                        vld_o,   // request ack'ed
  output logic [$clog2(NUM_REQ)-1:0]  idx_o    // idx output
);

  logic req;
  assign vld_o = (|req_i) & en_i;

  rr_arb_tree #(
    .NumIn     ( NUM_REQ ),
    .DataWidth ( 1       ),
    .LockIn    ( LOCK_IN ))
  i_rr_arb_tree (
    .clk_i   ( clk_i      ),
    .rst_ni  ( rst_ni     ),
    .flush_i ( flush_i    ),
    .rr_i    ( '0         ),
    .req_i   ( req_i      ),
    .gnt_o   ( ack_o      ),
    .data_i  ( '0         ),
    .gnt_i   ( en_i & req ),
    .req_o   ( req        ),
    .data_o  (            ),
    .idx_o   ( idx_o      )
  );

endmodule : rrarbiter
",rrarbiter.sv.txt,common_cells\rrarbiter.sv.txt
"[Keyword]: rr_arb_tree.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design is a logarithmic arbitration tree that implements a round-robin arbitration scheme. It is used to manage access to a shared resource among multiple requesters in a fair manner. The circuit ensures that each input request is given a chance to access the resource, rotating priorities each cycle to prevent starvation. The design can be configured for fair or unfair arbitration, and it supports external priority control and AXI-style valid/ready handshaking.

[Input Signal Description]:
- `clk_i`: Clock signal, positive edge triggered.
- `rst_ni`: Asynchronous reset signal, active low.
- `flush_i`: Signal to clear the arbiter state.
- `rr_i`: External round-robin priority input, used if `ExtPrio` is enabled.
- `req_i`: Input request signals, one for each input to be arbitrated.
- `data_i`: Input data associated with each request, to be arbitrated.

[Output Signal Description]:
- `gnt_o`: Output grant signals, indicating which input request has been granted.
- `req_o`: Output request valid signal, indicating a request is being made to the next stage.
- `gnt_i`: Input grant signal from the next stage, indicating the request has been accepted.
- `data_o`: Output data corresponding to the granted request.
- `idx_o`: Output index indicating which input request was granted.


[Design Detail]:
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
//         Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>, ETH Zurich
// Date: 02.04.2019
// Description: logarithmic arbitration tree with round robin arbitration scheme.

`include ""common_cells/assertions.svh""

/// The rr_arb_tree employs non-starving round robin-arbitration - i.e., the priorities
/// rotate each cycle.
///
/// ## Fair vs. unfair Arbitration
///
/// This refers to fair throughput distribution when not all inputs have active requests.
/// This module has an internal state `rr_q` which defines the highest priority input. (When
/// `ExtPrio` is `1'b1` this state is provided from the outside.) The arbitration tree will
/// choose the input with the same index as currently defined by the state if it has an active
/// request. Otherwise a *random* other active input is selected. The parameter `FairArb` is used
/// to distinguish between two methods of calculating the next state.
/// * `1'b0`: The next state is calculated by advancing the current state by one. This leads to the
///           state being calculated without the context of the active request. Leading to an
///           unfair throughput distribution if not all inputs have active requests.
/// * `1'b1`: The next state jumps to the next unserved request with higher index.
///           This is achieved by using two trailing-zero-counters (`lzc`). The upper has the masked
///           `req_i` signal with all indices which will have a higher priority in the next state.
///           The trailing zero count defines the input index with the next highest priority after
///           the current one is served. When the upper is empty the lower `lzc` provides the
///           wrapped index if there are outstanding requests with lower or same priority.
/// The implication of throughput fairness on the module timing are:
/// * The trailing zero counter (`lzc`) has a loglog relation of input to output timing. This means
///   that in this module the input to register path scales with Log(Log(`NumIn`)).
/// * The `rr_arb_tree` data multiplexing scales with Log(`NumIn`). This means that the input to output
///   timing path of this module also scales scales with Log(`NumIn`).
/// This implies that in this module the input to output path is always longer than the input to
/// register path. As the output data usually also terminates in a register the parameter `FairArb`
/// only has implications on the area. When it is `1'b0` a static plus one adder is instantiated.
/// If it is `1'b1` two `lzc`, a masking logic stage and a two input multiplexer are instantiated.
/// However these are small in respect of the data multiplexers needed, as the width of the `req_i`
/// signal is usually less as than `DataWidth`.
module rr_arb_tree #(
  /// Number of inputs to be arbitrated.
  parameter int unsigned NumIn      = 64,
  /// Data width of the payload in bits. Not needed if `DataType` is overwritten.
  parameter int unsigned DataWidth  = 32,
  /// Data type of the payload, can be overwritten with custom type. Only use of `DataWidth`.
  parameter type         DataType   = logic [DataWidth-1:0],
  /// The `ExtPrio` option allows to override the internal round robin counter via the
  /// `rr_i` signal. This can be useful in case multiple arbiters need to have
  /// rotating priorities that are operating in lock-step. If static priority arbitration
  /// is needed, just connect `rr_i` to '0.
  ///
  /// Set to 1'b1 to enable.
  parameter bit          ExtPrio    = 1'b0,
  /// If `AxiVldRdy` is set, the req/gnt signals are compliant with the AXI style vld/rdy
  /// handshake. Namely, upstream vld (req) must not depend on rdy (gnt), as it can be deasserted
  /// again even though vld is asserted. Enabling `AxiVldRdy` leads to a reduction of arbiter
  /// delay and area.
  ///
  /// Set to `1'b1` to treat req/gnt as vld/rdy.
  parameter bit          AxiVldRdy  = 1'b0,
  /// The `LockIn` option prevents the arbiter from changing the arbitration
  /// decision when the arbiter is disabled. I.e., the index of the first request
  /// that wins the arbitration will be locked in case the destination is not
  /// able to grant the request in the same cycle.
  ///
  /// Set to `1'b1` to enable.
  parameter bit          LockIn     = 1'b0,
  /// When set, ensures that throughput gets distributed evenly between all inputs.
  ///
  /// Set to `1'b0` to disable.
  parameter bit          FairArb    = 1'b1,
  /// Dependent parameter, do **not** overwrite.
  /// Width of the arbitration priority signal and the arbitrated index.
  parameter int unsigned IdxWidth   = (NumIn > 32'd1) ? unsigned'($clog2(NumIn)) : 32'd1,
  /// Dependent parameter, do **not** overwrite.
  /// Type for defining the arbitration priority and arbitrated index signal.
  parameter type         idx_t      = logic [IdxWidth-1:0]
) (
  /// Clock, positive edge triggered.
  input  logic                clk_i,
  /// Asynchronous reset, active low.
  input  logic                rst_ni,
  /// Clears the arbiter state. Only used if `ExtPrio` is `1'b0` or `LockIn` is `1'b1`.
  input  logic                flush_i,
  /// External round-robin priority. Only used if `ExtPrio` is `1'b1.`
  input  idx_t                rr_i,
  /// Input requests arbitration.
  input  logic    [NumIn-1:0] req_i,
  /* verilator lint_off UNOPTFLAT */
  /// Input request is granted.
  output logic    [NumIn-1:0] gnt_o,
  /* verilator lint_on UNOPTFLAT */
  /// Input data for arbitration.
  input  DataType [NumIn-1:0] data_i,
  /// Output request is valid.
  output logic                req_o,
  /// Output request is granted.
  input  logic                gnt_i,
  /// Output data.
  output DataType             data_o,
  /// Index from which input the data came from.
  output idx_t                idx_o
);

  // just pass through in this corner case
  if (NumIn == unsigned'(1)) begin : gen_pass_through
    assign req_o    = req_i[0];
    assign gnt_o[0] = gnt_i;
    assign data_o   = data_i[0];
    assign idx_o    = '0;
  // non-degenerate cases
  end else begin : gen_arbiter
    localparam int unsigned NumLevels = unsigned'($clog2(NumIn));

    /* verilator lint_off UNOPTFLAT */
    idx_t    [2**NumLevels-2:0] index_nodes; // used to propagate the indices
    DataType [2**NumLevels-2:0] data_nodes;  // used to propagate the data
    logic    [2**NumLevels-2:0] gnt_nodes;   // used to propagate the grant to masters
    logic    [2**NumLevels-2:0] req_nodes;   // used to propagate the requests to slave
    /* lint_off */
    idx_t                       rr_q;
    logic [NumIn-1:0]           req_d;

    // the final arbitration decision can be taken from the root of the tree
    assign req_o        = req_nodes[0];
    assign data_o       = data_nodes[0];
    assign idx_o        = index_nodes[0];

    if (ExtPrio) begin : gen_ext_rr
      assign rr_q       = rr_i;
      assign req_d      = req_i;
    end else begin : gen_int_rr
      idx_t rr_d;

      // lock arbiter decision in case we got at least one req and no acknowledge
      if (LockIn) begin : gen_lock
        logic  lock_d, lock_q;
        logic [NumIn-1:0] req_q;

        assign lock_d     = req_o & ~gnt_i;
        assign req_d      = (lock_q) ? req_q : req_i;

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_lock_reg
          if (!rst_ni) begin
            lock_q <= '0;
          end else begin
            if (flush_i) begin
              lock_q <= '0;
            end else begin
              lock_q <= lock_d;
            end
          end
        end

        `ifndef COMMON_CELLS_ASSERTS_OFF
          `ASSERT(lock, req_o && (!gnt_i && !flush_i) |=> idx_o == $past(idx_o),
                  clk_i, !rst_ni || flush_i,
                  ""Lock implies same arbiter decision in next cycle if output is not ready."")

          logic [NumIn-1:0] req_tmp;
          assign req_tmp = req_q & req_i;
          `ASSUME(lock_req, lock_d |=> req_tmp == req_q, clk_i, !rst_ni || flush_i,
                  ""It is disallowed to deassert unserved request signals when LockIn is enabled."")
        `endif

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_req_regs
          if (!rst_ni) begin
            req_q  <= '0;
          end else begin
            if (flush_i) begin
              req_q  <= '0;
            end else begin
              req_q  <= req_d;
            end
          end
        end
      end else begin : gen_no_lock
        assign req_d = req_i;
      end

      if (FairArb) begin : gen_fair_arb
        logic [NumIn-1:0] upper_mask,  lower_mask;
        idx_t             upper_idx,   lower_idx,   next_idx;
        logic             upper_empty, lower_empty;

        for (genvar i = 0; i < NumIn; i++) begin : gen_mask
          assign upper_mask[i] = (i >  rr_q) ? req_d[i] : 1'b0;
          assign lower_mask[i] = (i <= rr_q) ? req_d[i] : 1'b0;
        end

        lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_upper (
          .in_i    ( upper_mask  ),
          .cnt_o   ( upper_idx   ),
          .empty_o ( upper_empty )
        );

        lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_lower (
          .in_i    ( lower_mask  ),
          .cnt_o   ( lower_idx   ),
          .empty_o ( /*unused*/  )
        );

        assign next_idx = upper_empty      ? lower_idx : upper_idx;
        assign rr_d     = (gnt_i && req_o) ? next_idx  : rr_q;

      end else begin : gen_unfair_arb
        assign rr_d = (gnt_i && req_o) ? ((rr_q == idx_t'(NumIn-1)) ? '0 : rr_q + 1'b1) : rr_q;
      end

      // this holds the highest priority
      always_ff @(posedge clk_i or negedge rst_ni) begin : p_rr_regs
        if (!rst_ni) begin
          rr_q   <= '0;
        end else begin
          if (flush_i) begin
            rr_q   <= '0;
          end else begin
            rr_q   <= rr_d;
          end
        end
      end
    end

    assign gnt_nodes[0] = gnt_i;

    // arbiter tree
    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : gen_levels
      for (genvar l = 0; l < 2**level; l++) begin : gen_level
        // local select signal
        logic sel;
        // index calcs
        localparam int unsigned Idx0 = 2**level-1+l;// current node
        localparam int unsigned Idx1 = 2**(level+1)-1+l*2;
        //////////////////////////////////////////////////////////////
        // uppermost level where data is fed in from the inputs
        if (unsigned'(level) == NumLevels-1) begin : gen_first_level
          // if two successive indices are still in the vector...
          if (unsigned'(l) * 2 < NumIn-1) begin : gen_reduce
            assign req_nodes[Idx0]   = req_d[l*2] | req_d[l*2+1];

            // arbitration: round robin
            assign sel =  ~req_d[l*2] | req_d[l*2+1] & rr_q[NumLevels-1-level];

            assign index_nodes[Idx0] = idx_t'(sel);
            assign data_nodes[Idx0]  = (sel) ? data_i[l*2+1] : data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2])   & ~sel;
            assign gnt_o[l*2+1]      = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2+1]) & sel;
          end
          // if only the first index is still in the vector...
          if (unsigned'(l) * 2 == NumIn-1) begin : gen_first
            assign req_nodes[Idx0]   = req_d[l*2];
            assign index_nodes[Idx0] = '0;// always zero in this case
            assign data_nodes[Idx0]  = data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2]);
          end
          // if index is out of range, fill up with zeros (will get pruned)
          if (unsigned'(l) * 2 > NumIn-1) begin : gen_out_of_range
            assign req_nodes[Idx0]   = 1'b0;
            assign index_nodes[Idx0] = idx_t'('0);
            assign data_nodes[Idx0]  = DataType'('0);
          end
        //////////////////////////////////////////////////////////////
        // general case for other levels within the tree
        end else begin : gen_other_levels
          assign req_nodes[Idx0]   = req_nodes[Idx1] | req_nodes[Idx1+1];

          // arbitration: round robin
          assign sel =  ~req_nodes[Idx1] | req_nodes[Idx1+1] & rr_q[NumLevels-1-level];

          assign index_nodes[Idx0] = (sel) ?
            idx_t'({1'b1, index_nodes[Idx1+1][NumLevels-unsigned'(level)-2:0]}) :
            idx_t'({1'b0, index_nodes[Idx1][NumLevels-unsigned'(level)-2:0]});

          assign data_nodes[Idx0]  = (sel) ? data_nodes[Idx1+1] : data_nodes[Idx1];
          assign gnt_nodes[Idx1]   = gnt_nodes[Idx0] & ~sel;
          assign gnt_nodes[Idx1+1] = gnt_nodes[Idx0] & sel;
        end
        //////////////////////////////////////////////////////////////
      end
    end

    `ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(numin_0, NumIn, ""Input must be at least one element wide."")
    `ASSERT_INIT(lockin_and_extprio, !(LockIn && ExtPrio),
                 ""Cannot use LockIn feature together with external ExtPrio."")

    `ASSERT(hot_one, $onehot0(gnt_o), clk_i, !rst_ni || flush_i,
            ""Grant signal must be hot1 or zero."")

    `ASSERT(gnt0, |gnt_o |-> gnt_i, clk_i, !rst_ni || flush_i, ""Grant out implies grant in."")

    `ASSERT(gnt1, req_o |-> gnt_i |-> |gnt_o, clk_i, !rst_ni || flush_i,
            ""Req out and grant in implies grant out."")

    `ASSERT(gnt_idx, req_o |->  gnt_i |-> gnt_o[idx_o], clk_i, !rst_ni || flush_i,
            ""Idx_o / gnt_o do not match."")

    `ASSERT(req0, |req_i |-> req_o, clk_i, !rst_ni || flush_i, ""Req in implies req out."")

    `ASSERT(req1, req_o |-> |req_i, clk_i, !rst_ni || flush_i, ""Req out implies req in."")
    `endif
  end

endmodule : rr_arb_tree
",rr_arb_tree.sv.txt,common_cells\rr_arb_tree.sv.txt
"[Keyword]: rstgen.sv

[Design Category]: Control Circuits

[Design Function Description]:
The design is a reset generation circuit. It manages the reset signals in a digital system, ensuring that the system can be properly initialized and reset. It includes a bypass mechanism for test mode operations.

[Input Signal Description]:
- `clk_i`: Clock input signal, used to synchronize the reset generation process.
- `rst_ni`: Active-low reset input signal, used to initiate a reset of the system.
- `test_mode_i`: Input signal indicating whether the system is in test mode, which may alter the behavior of the reset generation.

[Output Signal Description]:
- `rst_no`: Active-low reset output signal, used to reset other parts of the system.
- `init_no`: Initialization output signal, indicating the completion of the reset process and readiness for normal operation.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Davide Rossi <davide.rossi@unibo.it>

module rstgen (
    input  logic clk_i,
    input  logic rst_ni,
    input  logic test_mode_i,
    output logic rst_no,
    output logic init_no
);

    rstgen_bypass i_rstgen_bypass (
        .clk_i            ( clk_i       ),
        .rst_ni           ( rst_ni      ),
        .rst_test_mode_ni ( rst_ni      ),
        .test_mode_i      ( test_mode_i ),
        .rst_no           ( rst_no      ),
        .init_no          ( init_no     )
    );

endmodule
",rstgen.sv.txt,common_cells\rstgen.sv.txt
"[Keyword]: rstgen_bypass.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This module is a reset synchronizer with a dedicated reset bypass pin for test mode reset. It ensures that the reset signal is synchronized with the clock and provides a mechanism to bypass the synchronization in test mode. The design uses a series of registers to synchronize the reset signal and includes clock multiplexers to select between normal and test mode reset signals.

[Input Signal Description]:
- `clk_i`: Clock input signal used to synchronize the reset signal.
- `rst_ni`: Active-low reset input signal for normal operation.
- `rst_test_mode_ni`: Active-low reset input signal for test mode operation.
- `test_mode_i`: Input signal to select between normal and test mode operation.

[Output Signal Description]:
- `rst_no`: Synchronized reset output signal.
- `init_no`: Initialization output signal, indicating the completion of the reset synchronization process.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Description: This module is a reset synchronizer with a dedicated reset bypass pin for testmode reset.
// Pro Tip: The wise Dr. Schaffner recommends at least 4 registers!

module rstgen_bypass #(
    parameter int unsigned NumRegs = 4
) (
    input  logic clk_i,
    input  logic rst_ni,
    input  logic rst_test_mode_ni,
    input  logic test_mode_i,
    output logic rst_no,
    output logic init_no
);

    // internal reset
    logic rst_n;

    logic [NumRegs-1:0] synch_regs_q;

    // bypass mode: use (clock) multiplexers
    tc_clk_mux2 i_tc_clk_mux2_rst_n (
        .clk0_i     ( rst_ni ),
        .clk1_i     ( rst_test_mode_ni ),
        .clk_sel_i  ( test_mode_i ),
        .clk_o      ( rst_n )
    );

    tc_clk_mux2 i_tc_clk_mux2_rst_no (
        .clk0_i     ( synch_regs_q[NumRegs-1] ),
        .clk1_i     ( rst_test_mode_ni ),
        .clk_sel_i  ( test_mode_i ),
        .clk_o      ( rst_no )
    );

    tc_clk_mux2 i_tc_clk_mux2_init_no (
        .clk0_i     ( synch_regs_q[NumRegs-1] ),
        .clk1_i     ( 1'b1 ),
        .clk_sel_i  ( test_mode_i ),
        .clk_o      ( init_no )
    );

    always @(posedge clk_i or negedge rst_n) begin
        if (~rst_n) begin
            synch_regs_q <= 0;
        end else begin
            synch_regs_q <= {synch_regs_q[NumRegs-2:0], 1'b1};
        end
    end
    `ifndef SYNTHESIS
    `ifndef COMMON_CELLS_ASSERTS_OFF
    initial begin : p_assertions
        if (NumRegs < 1) $fatal(1, ""At least one register is required."");
    end
    `endif
    `endif
endmodule
",rstgen_bypass.sv.txt,common_cells\rstgen_bypass.sv.txt
"[Keyword]: serial_deglitch.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit is designed to deglitch a serial input line by sampling the input multiple times before asserting the output high or low. This helps in filtering out transient glitches in the input signal, ensuring that only stable signals are passed through.

[Input Signal Description]:
- `clk_i`: Clock signal used to synchronize the operations of the circuit.
- `rst_ni`: Asynchronous reset signal, active low, used to initialize the circuit.
- `en_i`: Enable signal that allows the circuit to process the input data.
- `d_i`: Serial data input signal that is being deglitched.

[Output Signal Description]:
- `q_o`: The filtered output signal that reflects the stable state of the input after deglitching.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba
// Description: Deglitches a serial line by taking multiple samples until
//              asserting the output high/low.

module serial_deglitch #(
    parameter int unsigned SIZE = 4
)(
    input  logic clk_i,    // clock
    input  logic rst_ni,   // asynchronous reset active low
    input  logic en_i,     // enable
    input  logic d_i,      // serial data in
    output logic q_o       // filtered data out
);
    logic [SIZE-1:0] count_q;
    logic q;

    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (~rst_ni) begin
            count_q <= '0;
            q       <= 1'b0;
        end else begin
            if (en_i) begin
                if (d_i == 1'b1 && count_q != SIZE[SIZE-1:0]) begin
                    count_q <= count_q + 1;
                end else if (d_i == 1'b0 && count_q != SIZE[SIZE-1:0]) begin
                    count_q <= count_q - 1;
                end
            end
        end
    end

    // output process
    always_comb begin
        if (count_q == SIZE[SIZE-1:0]) begin
            q_o = 1'b1;
        end else if (count_q == 0) begin
            q_o = 1'b0;
        end
    end
endmodule
",serial_deglitch.sv.txt,common_cells\serial_deglitch.sv.txt
"[Keyword]: shift_reg.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple shift register with configurable depth and data type. A shift register is a sequential logic circuit that is used to store and shift data. The data is shifted in on each clock cycle, and the output is the data that has been shifted through the register.

[Input Signal Description]:
- `clk_i`: Clock input signal that drives the shifting operation.
- `rst_ni`: Asynchronous reset input signal, active low, used to reset the shift register.
- `d_i`: Input data of type `dtype` that is to be shifted into the register.

[Output Signal Description]:
- `d_o`: Output data of type `dtype` that represents the data shifted out of the register after passing through the specified depth.


[Design Detail]:

// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: <zarubaf@iis.ee.ethz.ch>
//
// Description: Simple shift register for arbitrary depth and types

module shift_reg #(
    parameter type dtype         = logic,
    parameter int unsigned Depth = 1
)(
    input  logic clk_i,    // Clock
    input  logic rst_ni,   // Asynchronous reset active low
    input  dtype d_i,
    output dtype d_o
);

    shift_reg_gated #(
        .Depth(Depth),
        .dtype(dtype)
    ) i_shift_reg_gated (
        .clk_i  (clk_i),
        .rst_ni (rst_ni),
        .valid_i(1'b1),
        .data_i (d_i),
        .valid_o(),
        .data_o (d_o)
    );


endmodule
",shift_reg.sv.txt,common_cells\shift_reg.sv.txt
"[Keyword]: shift_reg_gated.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a shift register with integrated clock gating (ICG) for arbitrary depth and data types. The shift register can pass data through directly if the depth is zero, or shift data through a series of registers if the depth is greater than zero. The design is optimized for power consumption by using clock gating based on a valid signal.

[Input Signal Description]:
- `clk_i`: Clock input signal used to synchronize the shift register operations.
- `rst_ni`: Asynchronous reset input, active low, used to reset the shift register.
- `valid_i`: Input signal indicating whether the input data is valid and should be processed.
- `data_i`: Input data of a parameterized type `dtype` that is to be shifted through the register.

[Output Signal Description]:
- `valid_o`: Output signal indicating whether the output data is valid.
- `data_o`: Output data of the same type as `data_i`, representing the data after being shifted through the register.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Description: A Simple shift register with ICG for arbitrary depth and types.

`include ""common_cells/registers.svh""

module shift_reg_gated #(
  parameter int unsigned Depth = 32'd8,
  parameter type         dtype = logic
) (
  input  logic clk_i,    // Clock
  input  logic rst_ni,   // Asynchronous reset active low

  input  logic valid_i,
  input  dtype data_i,
  output logic valid_o,
  output dtype data_o
);

  // Register of depth 0 is a wire.
  if (Depth == 0) begin : gen_pass_through

    assign valid_o = valid_i;
    assign data_o  = data_i;

  // It's a shift register if depth is greater than 0
  end else begin : gen_shift_reg

    logic [Depth-1 : 0] valid_d, valid_q;
    dtype [Depth-1 : 0] data_d, data_q;

    for (genvar i = 0; i < Depth; i++) begin : gen_regs

      // Prepare D port for each shift register.
      if (i == 0) begin : gen_shift_in
        assign valid_d[i] = valid_i;
        assign data_d[i]  = data_i;
      end else begin : gen_shift
        assign valid_d[i] = valid_q[i-1];
        assign data_d[i]  = data_q[i-1];
      end

      // shift valid flag without clock gate
      `FF(valid_q[i], valid_d[i], '0, clk_i, rst_ni)

      // Gate each shift register with a valid flag to enable the synthsis tools to insert ICG for
      // better power comsumption.
      `FFL(data_q[i], data_d[i], valid_d[i], dtype'('0), clk_i, rst_ni)
    end

    // Output the shifted result.
    assign valid_o = valid_q[Depth-1];
    assign data_o  = data_q[Depth-1];

  end

endmodule
",shift_reg_gated.sv.txt,common_cells\shift_reg_gated.sv.txt
"[Keyword]: spill_register.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a wrapper module for a flushable spill register, which is used to temporarily store data and maintain backward compatibility. It can be configured to be transparent, meaning it can bypass the storage functionality if needed.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the register operations.
- `rst_ni`: Active-low reset signal to initialize or reset the register.
- `valid_i`: Input signal indicating that the input data is valid and ready to be processed.
- `data_i`: Input data of type `T` that needs to be stored in the register.
- `ready_i`: Input signal indicating that the downstream logic is ready to accept data.

[Output Signal Description]:
- `ready_o`: Output signal indicating that the register is ready to accept new data.
- `valid_o`: Output signal indicating that the output data is valid and ready to be used by downstream logic.
- `data_o`: Output data of type `T` that is stored in the register and ready to be passed to the next stage.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>


/// Wrapper around the flushable spill register to maintain back-ward
/// compatibility.
module spill_register #(
  parameter type T      = logic,
  parameter bit  Bypass = 1'b0     // make this spill register transparent
) (
  input  logic clk_i   ,
  input  logic rst_ni  ,
  input  logic valid_i ,
  output logic ready_o ,
  input  T     data_i  ,
  output logic valid_o ,
  input  logic ready_i ,
  output T     data_o
);

  spill_register_flushable #(
    .T(T),
    .Bypass(Bypass)
  ) spill_register_flushable_i (
    .clk_i,
    .rst_ni,
    .valid_i,
    .flush_i(1'b0),
    .ready_o,
    .data_i,
    .valid_o,
    .ready_i,
    .data_o
  );

endmodule
",spill_register.sv.txt,common_cells\spill_register.sv.txt
"[Keyword]: spill_register_flushable.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a flushable spill register with handshakes that completely cuts any combinational paths between the input and output. It consists of two internal registers (A and B) that manage data flow with the ability to flush the stored data. The module can operate in a bypass mode where it becomes transparent, directly passing input to output.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the register operations.
- `rst_ni`: Active-low reset signal to initialize or reset the register states.
- `valid_i`: Input signal indicating that the input data is valid and ready to be processed.
- `flush_i`: Input signal to flush the data from the registers, effectively clearing them.
- `data_i`: Input data of type `T` that is to be stored in the register.
- `ready_i`: Input signal indicating that the downstream circuit is ready to accept data.

[Output Signal Description]:
- `ready_o`: Output signal indicating that the register is ready to accept new input data.
- `valid_o`: Output signal indicating that the output data is valid and ready to be used by the downstream circuit.
- `data_o`: Output data of type `T` that is provided to the downstream circuit.


[Design Detail]:
// Copyright 2021 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

/// A register with handshakes that completely cuts any combinational paths
/// between the input and output. This spill register can be flushed.
module spill_register_flushable #(
  parameter type T           = logic,
  parameter bit  Bypass      = 1'b0   // make this spill register transparent
) (
  input  logic clk_i   ,
  input  logic rst_ni  ,
  input  logic valid_i ,
  input  logic flush_i ,
  output logic ready_o ,
  input  T     data_i  ,
  output logic valid_o ,
  input  logic ready_i ,
  output T     data_o
);

  if (Bypass) begin : gen_bypass
    assign valid_o = valid_i;
    assign ready_o = ready_i;
    assign data_o  = data_i;
  end else begin : gen_spill_reg
    // The A register.
    T a_data_q;
    logic a_full_q;
    logic a_fill, a_drain;

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_a_data
      if (!rst_ni)
        a_data_q <= T'('0);
      else if (a_fill)
        a_data_q <= data_i;
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_a_full
      if (!rst_ni)
        a_full_q <= 0;
      else if (a_fill || a_drain)
        a_full_q <= a_fill;
    end

    // The B register.
    T b_data_q;
    logic b_full_q;
    logic b_fill, b_drain;

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_b_data
      if (!rst_ni)
        b_data_q <= T'('0);
      else if (b_fill)
        b_data_q <= a_data_q;
    end

    always_ff @(posedge clk_i or negedge rst_ni) begin : ps_b_full
      if (!rst_ni)
        b_full_q <= 0;
      else if (b_fill || b_drain)
        b_full_q <= b_fill;
    end

    // Fill the A register when the A or B register is empty. Drain the A register
    // whenever it is full and being filled, or if a flush is requested.
    assign a_fill = valid_i && ready_o && (!flush_i);
    assign a_drain = (a_full_q && !b_full_q) || flush_i;

    // Fill the B register whenever the A register is drained, but the downstream
    // circuit is not ready. Drain the B register whenever it is full and the
    // downstream circuit is ready, or if a flush is requested.
    assign b_fill = a_drain && (!ready_i) && (!flush_i);
    assign b_drain = (b_full_q && ready_i) || flush_i;

    // We can accept input as long as register B is not full.
    // Note: flush_i and valid_i must not be high at the same time,
    // otherwise an invalid handshake may occur
    assign ready_o = !a_full_q || !b_full_q;

    // The unit provides output as long as one of the registers is filled.
    assign valid_o = a_full_q | b_full_q;

    // We empty the spill register before the slice register.
    assign data_o = b_full_q ? b_data_q : a_data_q;

    `ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT(flush_valid, flush_i |-> ~valid_i, clk_i, !rst_ni,
           ""Trying to flush and feed the spill register simultaneously. You will lose data!"")
   `endif
  end
endmodule
",spill_register_flushable.sv.txt,common_cells\spill_register_flushable.sv.txt
"[Keyword]: sram.sv

[Design Category]: Memory Circuits

[Design Function Description]: 
This design is a behavioral model of an SRAM (Static Random-Access Memory). It allows for reading and writing data to a memory array. The SRAM can store a specified number of words, each of a specified data width. The design supports byte-enable functionality for selective writing of data bits.

[Input Signal Description]:
- `clk_i`: Clock input signal used to synchronize read and write operations.
- `req_i`: Request input signal indicating whether a read or write operation is requested.
- `we_i`: Write enable signal; when high, a write operation is performed, otherwise a read operation is performed.
- `addr_i`: Address input signal used to specify the memory location for read or write operations. Its width is determined by the number of words in the memory.
- `wdata_i`: Write data input signal containing the data to be written to the memory.
- `be_i`: Byte enable input signal used to selectively enable writing of specific bits in the data word.

[Output Signal Description]:
- `rdata_o`: Read data output signal that provides the data read from the memory at the specified address.


[Design Detail]:
// Copyright 2017, 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Date: 13.10.2017
// Description: SRAM Behavioral Model

module sram #(
    int unsigned DATA_WIDTH = 64,
    int unsigned NUM_WORDS  = 1024
)(
   input  logic                          clk_i,

   input  logic                          req_i,
   input  logic                          we_i,
   input  logic [$clog2(NUM_WORDS)-1:0]  addr_i,
   input  logic [DATA_WIDTH-1:0]         wdata_i,
   input  logic [DATA_WIDTH-1:0]         be_i,
   output logic [DATA_WIDTH-1:0]         rdata_o
);
    localparam ADDR_WIDTH = $clog2(NUM_WORDS);

    logic [DATA_WIDTH-1:0] ram [NUM_WORDS-1:0];
    logic [ADDR_WIDTH-1:0] raddr_q;

    // 1. randomize array
    // 2. randomize output when no request is active
    always_ff @(posedge clk_i) begin
        if (req_i) begin
            if (!we_i)
                raddr_q <= addr_i;
            else
            for (int i = 0; i < DATA_WIDTH; i++)
                if (be_i[i]) ram[addr_i][i] <= wdata_i[i];
        end
    end

    assign rdata_o = ram[raddr_q];

endmodule
",sram.sv.txt,common_cells\sram.sv.txt
"[Keyword]: stream_arbiter.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream arbiter that arbitrates multiple input streams to a single output stream. It uses a round-robin arbitration scheme with a ""look ahead"" feature to manage the valid-ready handshaking protocol, similar to AXI4. The arbiter ensures that once the output is valid, the data remains constant until the handshake is completed.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronization.
- `rst_ni`: Active-low reset signal to initialize the circuit.
- `inp_data_i[N_INP-1:0]`: Array of input data streams, where each stream is of type `DATA_T`.
- `inp_valid_i[N_INP-1:0]`: Array of valid signals indicating if the corresponding input data is valid.
- `oup_ready_i`: Signal indicating if the output is ready to accept data.

[Output Signal Description]:
- `inp_ready_o[N_INP-1:0]`: Array of ready signals indicating if the corresponding input can send data.
- `oup_data_o`: Output data stream of type `DATA_T`, selected from one of the input streams.
- `oup_valid_o`: Signal indicating if the output data is valid and ready to be transferred.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Stream arbiter: Arbitrates a parametrizable number of input streams (i.e., valid-ready
// handshaking with dependency rules as in AXI4) to a single output stream.  Once `oup_valid_o` is
// asserted, `oup_data_o` remains invariant until the output handshake has occurred.  The
// arbitration scheme is round-robin with ""look ahead"", see the `rrarbiter` for details.

module stream_arbiter #(
    parameter type      DATA_T = logic,   // Vivado requires a default value for type parameters.
    parameter integer   N_INP = -1,       // Synopsys DC requires a default value for parameters.
    parameter           ARBITER = ""rr""    // ""rr"" or ""prio""
) (
    input  logic              clk_i,
    input  logic              rst_ni,

    input  DATA_T [N_INP-1:0] inp_data_i,
    input  logic  [N_INP-1:0] inp_valid_i,
    output logic  [N_INP-1:0] inp_ready_o,

    output DATA_T             oup_data_o,
    output logic              oup_valid_o,
    input  logic              oup_ready_i
);

  stream_arbiter_flushable #(
    .DATA_T   (DATA_T),
    .N_INP    (N_INP),
    .ARBITER  (ARBITER)
  ) i_arb (
    .clk_i        (clk_i),
    .rst_ni       (rst_ni),
    .flush_i      (1'b0),
    .inp_data_i   (inp_data_i),
    .inp_valid_i  (inp_valid_i),
    .inp_ready_o  (inp_ready_o),
    .oup_data_o   (oup_data_o),
    .oup_valid_o  (oup_valid_o),
    .oup_ready_i  (oup_ready_i)
  );

endmodule
",stream_arbiter.sv.txt,common_cells\stream_arbiter.sv.txt
"[Keyword]: stream_arbiter_flushable.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream arbiter that arbitrates a configurable number of input streams to a single output stream. It uses a valid-ready handshaking protocol similar to AXI4. The arbiter can operate in either a round-robin (""rr"") or priority (""prio"") mode, ensuring fair access to the output stream. Once the output is valid, it remains stable until the handshake is completed. The design also supports a flush operation to reset the arbitration process.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronization.
- `rst_ni`: Active-low reset signal to initialize the arbiter.
- `flush_i`: Signal to flush or reset the arbitration process.
- `inp_data_i`: Array of input data streams, each of type `DATA_T`.
- `inp_valid_i`: Array of valid signals corresponding to each input data stream, indicating if the data is valid.
- `oup_ready_i`: Signal indicating if the output stream is ready to accept data.

[Output Signal Description]:
- `inp_ready_o`: Array of ready signals for each input stream, indicating if the arbiter is ready to accept data from the corresponding input.
- `oup_data_o`: Output data stream of type `DATA_T`, selected from one of the input streams.
- `oup_valid_o`: Signal indicating if the output data is valid and ready to be transferred.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Stream arbiter: Arbitrates a parametrizable number of input streams (i.e., valid-ready
// handshaking with dependency rules as in AXI4) to a single output stream.  Once `oup_valid_o` is
// asserted, `oup_data_o` remains invariant until the output handshake has occurred.  The
// arbitration scheme is fair round-robin tree, see `rr_arb_tree` for details.

module stream_arbiter_flushable #(
    parameter type      DATA_T = logic,   // Vivado requires a default value for type parameters.
    parameter integer   N_INP = -1,       // Synopsys DC requires a default value for parameters.
    parameter           ARBITER = ""rr""    // ""rr"" or ""prio""
) (
    input  logic              clk_i,
    input  logic              rst_ni,
    input  logic              flush_i,

    input  DATA_T [N_INP-1:0] inp_data_i,
    input  logic  [N_INP-1:0] inp_valid_i,
    output logic  [N_INP-1:0] inp_ready_o,

    output DATA_T             oup_data_o,
    output logic              oup_valid_o,
    input  logic              oup_ready_i
);

  if (ARBITER == ""rr"") begin : gen_rr_arb
    rr_arb_tree #(
      .NumIn      (N_INP),
      .DataType   (DATA_T),
      .ExtPrio    (1'b0),
      .AxiVldRdy  (1'b1),
      .LockIn     (1'b1)
    ) i_arbiter (
      .clk_i,
      .rst_ni,
      .flush_i,
      .rr_i   ('0),
      .req_i  (inp_valid_i),
      .gnt_o  (inp_ready_o),
      .data_i (inp_data_i),
      .gnt_i  (oup_ready_i),
      .req_o  (oup_valid_o),
      .data_o (oup_data_o),
      .idx_o  ()
    );

  end else if (ARBITER == ""prio"") begin : gen_prio_arb
    rr_arb_tree #(
      .NumIn      (N_INP),
      .DataType   (DATA_T),
      .ExtPrio    (1'b1),
      .AxiVldRdy  (1'b1),
      .LockIn     (1'b0)
    ) i_arbiter (
      .clk_i,
      .rst_ni,
      .flush_i,
      .rr_i   ('0),
      .req_i  (inp_valid_i),
      .gnt_o  (inp_ready_o),
      .data_i (inp_data_i),
      .gnt_i  (oup_ready_i),
      .req_o  (oup_valid_o),
      .data_o (oup_data_o),
      .idx_o  ()
    );

  end else begin : gen_arb_error
    `ifndef SYNTHESIS
    $fatal(1, ""Invalid value for parameter 'ARBITER'!"");
    `endif
  end

endmodule
",stream_arbiter_flushable.sv.txt,common_cells\stream_arbiter_flushable.sv.txt
"[Keyword]: stream_delay.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements a delay mechanism for AXI-like handshaking signals. It can introduce a fixed or random delay to the handshaking process, allowing for testing and validation of data flow under different timing conditions. The delay can be configured to be a fixed number of cycles or determined randomly using a linear feedback shift register (LFSR).

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the circuit operations.
- `rst_ni`: Active-low reset signal to initialize the circuit.
- `payload_i`: Input data payload that needs to be delayed.
- `valid_i`: Input signal indicating the validity of the `payload_i`.
- `ready_i`: Input signal indicating the readiness of the downstream component to accept data.

[Output Signal Description]:
- `ready_o`: Output signal indicating the readiness of the circuit to accept new data.
- `valid_o`: Output signal indicating the validity of the `payload_o`.
- `payload_o`: Output data payload after the delay.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba, zarubaf@iis.ee.ethz.ch
// Description: Delay (or randomize) AXI-like handshaking

module stream_delay #(
    parameter bit   StallRandom = 0,
    parameter int   FixedDelay  = 1,
    parameter type  payload_t  = logic,
    parameter logic [15:0] Seed = '0
)(
    input  logic     clk_i,
    input  logic     rst_ni,

    input  payload_t payload_i,
    output logic     ready_o,
    input  logic     valid_i,

    output payload_t payload_o,
    input  logic     ready_i,
    output logic     valid_o
);

    if (FixedDelay == 0 && !StallRandom) begin : gen_pass_through
        assign ready_o = ready_i;
        assign valid_o = valid_i;
        assign payload_o = payload_i;
    end else begin : gen_delay

        localparam int unsigned CounterBits = 32;

        typedef enum logic [1:0] {
            Idle, Valid, Ready
        } state_e;

        state_e state_d, state_q;

        logic       load;
        logic [CounterBits-1:0] count_out;
        logic       en;

        logic [CounterBits-1:0] counter_load;

        assign payload_o = payload_i;

        always_comb begin
            state_d = state_q;
            valid_o = 1'b0;
            ready_o = 1'b0;
            load    = 1'b0;
            en      = 1'b0;

            unique case (state_q)
                Idle: begin
                    if (valid_i) begin
                        load = 1'b1;
                        state_d = Valid;
                        // Just one cycle delay
                        if (FixedDelay == 1 || (StallRandom && counter_load == 1)) begin
                            state_d = Ready;
                        end

                        if (StallRandom && counter_load == 0) begin
                            valid_o = 1'b1;
                            ready_o = ready_i;
                            if (ready_i) state_d = Idle;
                            else state_d = Ready;
                        end
                    end
                end
                Valid: begin
                    en = 1'b1;
                    if (count_out == 0) begin
                        state_d = Ready;
                    end
                end

                Ready: begin
                    valid_o = 1'b1;
                    ready_o = ready_i;
                    if (ready_i) state_d = Idle;
                end
                default : /* default */;
            endcase

        end

        if (StallRandom) begin : gen_random_stall
            lfsr_16bit #(
              .WIDTH ( 16   ),
              .SEED  ( Seed )
            ) i_lfsr_16bit (
              .clk_i          ( clk_i        ),
              .rst_ni         ( rst_ni       ),
              .en_i           ( load         ),
              .refill_way_oh  (              ),
              .refill_way_bin ( counter_load )
            );
        end else begin : gen_fixed_delay
            assign counter_load = FixedDelay;
        end

        counter #(
            .WIDTH      ( CounterBits )
        ) i_counter (
            .clk_i      ( clk_i        ),
            .rst_ni     ( rst_ni       ),
            .clear_i    ( 1'b0         ),
            .en_i       ( en           ),
            .load_i     ( load         ),
            .down_i     ( 1'b1         ),
            .d_i        ( counter_load ),
            .q_o        ( count_out    ),
            .overflow_o (              )
        );

        always_ff @(posedge clk_i or negedge rst_ni) begin
            if (~rst_ni) begin
                state_q <= Idle;
            end else begin
                state_q <= state_d;
            end
        end
    end

endmodule
",stream_delay.sv.txt,common_cells\stream_delay.sv.txt
"[Keyword]: stream_demux.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream demultiplexer that connects an input stream (using a valid-ready handshake protocol) to one of multiple output streams. The selection of which output stream to connect to is determined by a selection input. The data itself is not demultiplexed; instead, the valid signal is routed to the selected output stream, and the ready signal is received from the selected output stream.

[Input Signal Description]:
- `inp_valid_i`: A logic signal indicating the validity of the input stream data.
- `oup_sel_i`: A logic vector used to select which output stream the input stream should be connected to. Its width is determined by the logarithm of the number of outputs (`LOG_N_OUP`).
- `oup_ready_i`: A logic vector indicating the readiness of each output stream to receive data.

[Output Signal Description]:
- `inp_ready_o`: A logic signal indicating whether the input stream can send more data, based on the readiness of the selected output stream.
- `oup_valid_o`: A logic vector where only the bit corresponding to the selected output stream is set to the value of `inp_valid_i`, indicating the validity of the data for that specific output stream.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// Connects the input stream (valid-ready) handshake to one of `N_OUP` output stream handshakes.
///
/// This module has no data ports because stream data does not need to be demultiplexed: the data of
/// the input stream can just be applied at all output streams.
module stream_demux #(
  /// Number of connected outputs.
  parameter int unsigned N_OUP     = 32'd1,
  /// Dependent parameters, DO NOT OVERRIDE!
  parameter int unsigned LOG_N_OUP = (N_OUP > 32'd1) ? unsigned'($clog2(N_OUP)) : 1'b1
) (
  input  logic                 inp_valid_i,
  output logic                 inp_ready_o,

  input  logic [LOG_N_OUP-1:0] oup_sel_i,

  output logic [N_OUP-1:0]     oup_valid_o,
  input  logic [N_OUP-1:0]     oup_ready_i
);

  always_comb begin
    oup_valid_o = '0;
    oup_valid_o[oup_sel_i] = inp_valid_i;
  end
  assign inp_ready_o = oup_ready_i[oup_sel_i];

endmodule
",stream_demux.sv.txt,common_cells\stream_demux.sv.txt
"[Keyword]: stream_fifo.sv

[Design Category]: Memory Circuits

[Design Function Description]:
The design implements a FIFO (First-In-First-Out) memory buffer, which is used to temporarily store data. It supports a fall-through mode and can handle data of configurable width and depth. The FIFO allows for data to be pushed into it when it is not full and popped from it when it is not empty, providing a mechanism for buffering data between different parts of a system.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the FIFO operations.
- `rst_ni`: Asynchronous reset signal, active low, used to reset the FIFO.
- `flush_i`: Signal to flush the FIFO, clearing its contents.
- `testmode_i`: Signal to enable test mode, potentially bypassing clock gating for testing purposes.
- `data_i`: Input data to be pushed into the FIFO.
- `valid_i`: Indicates that the input data is valid and ready to be pushed into the FIFO.
- `ready_i`: Indicates that the system is ready to pop data from the FIFO.

[Output Signal Description]:
- `usage_o`: Indicates the current fill level of the FIFO.
- `ready_o`: Indicates that the FIFO is not full and can accept more data.
- `data_o`: Output data from the FIFO.
- `valid_o`: Indicates that the FIFO is not empty and data is available to be popped.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Georg Rutishauser <georgr@iis.ee.ethz.ch>

module stream_fifo #(
    /// FIFO is in fall-through mode
    parameter bit          FALL_THROUGH = 1'b0,
    /// Default data width if the fifo is of type logic
    parameter int unsigned DATA_WIDTH   = 32,
    /// Depth can be arbitrary from 0 to 2**32
    parameter int unsigned DEPTH        = 8,
    parameter type         T            = logic [DATA_WIDTH-1:0],
    // DO NOT OVERWRITE THIS PARAMETER
    parameter int unsigned ADDR_DEPTH  = (DEPTH > 1) ? $clog2(DEPTH) : 1
) (
    input  logic                  clk_i,      // Clock
    input  logic                  rst_ni,     // Asynchronous reset active low
    input  logic                  flush_i,    // flush the fifo
    input  logic                  testmode_i, // test_mode to bypass clock gating
    output logic [ADDR_DEPTH-1:0] usage_o,    // fill pointer
    // input interface
    input  T                      data_i,     // data to push into the fifo
    input  logic                  valid_i,    // input data valid
    output logic                  ready_o,    // fifo is not full
    // output interface
    output T                      data_o,     // output data
    output logic                  valid_o,    // fifo is not empty
    input  logic                  ready_i     // pop head from fifo
);

    logic push, pop;
    logic empty, full;

    assign push    = valid_i & ~full;
    assign pop     = ready_i & ~empty;
    assign ready_o = ~full;
    assign valid_o = ~empty;

    fifo_v3 #(
        .FALL_THROUGH   (FALL_THROUGH),
        .DATA_WIDTH     (DATA_WIDTH),
        .DEPTH          (DEPTH),
        .dtype(T)
    ) fifo_i (
        .clk_i,
        .rst_ni,
        .flush_i,
        .testmode_i,
        .full_o     (full),
        .empty_o    (empty),
        .usage_o,
        .data_i,
        .push_i     (push),
        .data_o,
        .pop_i      (pop)
    );

endmodule
",stream_fifo.sv.txt,common_cells\stream_fifo.sv.txt
"[Keyword]: stream_fifo_optimal_wrap.sv

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements an optimal stream FIFO (First-In-First-Out) buffer. It dynamically selects between a spill register for a depth of 2 and a full FIFO for depths greater than 2. The design throws an error for invalid configurations with a depth of 0 or 1. The FIFO is used to manage data flow, ensuring that data is read in the same order it was written.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the operations.
- `rst_ni`: Asynchronous reset signal, active low, to reset the FIFO.
- `flush_i`: Signal to flush the FIFO, clearing its contents.
- `testmode_i`: Signal to enable test mode, bypassing clock gating.
- `data_i`: Input data to be pushed into the FIFO.
- `valid_i`: Indicates that the input data is valid and ready to be pushed into the FIFO.
- `ready_i`: Indicates that the FIFO is ready to pop the head data.

[Output Signal Description]:
- `usage_o`: Indicates the fill level of the FIFO, represented by the fill pointer.
- `ready_o`: Indicates that the FIFO is not full and can accept more data.
- `data_o`: Output data from the FIFO.
- `valid_o`: Indicates that the FIFO is not empty and data is available to be read.


[Design Detail]:
// Copyright 2022 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Thomas Benz <tbenz@ethz.ch>

/// Optimal implementation of a stream FIFO based on the common cells modules.
/// Selects the smaller and faster spill register if the depth is 2 and the FIFO if
/// the depth is >2. Throws an error for the meaningless configurations depth 0 and 1.
module stream_fifo_optimal_wrap #(
    /// Depth can be arbitrary from 2 to 2**32
    parameter int unsigned Depth = 32'd8,
    /// Type of the FIFO
    parameter type type_t = logic,
    /// Print information when the simulation launches
    parameter bit PrintInfo = 1'b0,
    // DO NOT OVERWRITE THIS PARAMETER
    parameter int unsigned AddrDepth  = (Depth > 32'd1) ? $clog2(Depth) : 32'd1
) (
    input  logic                 clk_i,      // Clock
    input  logic                 rst_ni,     // Asynchronous reset active low
    input  logic                 flush_i,    // flush the fifo
    input  logic                 testmode_i, // test_mode to bypass clock gating
    output logic [AddrDepth-1:0] usage_o,    // fill pointer
    // input interface
    input  type_t                data_i,     // data to push into the fifo
    input  logic                 valid_i,    // input data valid
    output logic                 ready_o,    // fifo is not full
    // output interface
    output type_t                data_o,     // output data
    output logic                 valid_o,    // fifo is not empty
    input  logic                 ready_i     // pop head from fifo
);

    //--------------------------------------
    // Prevent Depth 0 and 1
    //--------------------------------------
    // Throw an error if depth is 0 or 1
    `ifndef SYNTHESIS
    if (Depth < 32'd2) begin : gen_fatal
        initial begin
            $fatal(1, ""FIFO of depth %d does not make any sense!"", Depth);
        end
    end
    `endif

    //--------------------------------------
    // Spill register (depth 2)
    //--------------------------------------
    // Instantiate a spill register for depth 2
    if (Depth == 32'd2) begin : gen_spill

        // print info
        `ifndef SYNTHESIS
        if (PrintInfo) begin : gen_info
            initial begin
                $display(""[%m] Instantiate spill register (of depth %d)"", Depth);
            end
        end
        `endif

        // spill register
        spill_register_flushable #(
            .T       ( type_t ),
            .Bypass  ( 1'b0   )
        ) i_spill_register_flushable (
            .clk_i,
            .rst_ni,
            .flush_i,
            .valid_i,
            .ready_o,
            .data_i,
            .valid_o,
            .ready_i,
            .data_o
        );

        // usage is not supported
        assign usage_o = 'x;
    end


    //--------------------------------------
    // FIFO register (depth 3+)
    //--------------------------------------
    // default to stream fifo
    if (Depth > 32'd2) begin : gen_fifo

        // print info
        `ifndef SYNTHESIS
        if (PrintInfo) begin : gen_info
            initial begin
                $info(""[%m] Instantiate stream FIFO of depth %d"", Depth);
            end
        end
        `endif

        // stream fifo
        stream_fifo #(
            .DEPTH        ( Depth  ),
            .T            ( type_t )
        ) i_stream_fifo (
            .clk_i,
            .rst_ni,
            .flush_i,
            .testmode_i,
            .usage_o,
            .data_i,
            .valid_i,
            .ready_o,
            .data_o,
            .valid_o,
            .ready_i
        );
    end

endmodule : stream_fifo_optimal_wrap
",stream_fifo_optimal_wrap.sv.txt,common_cells\stream_fifo_optimal_wrap.sv.txt
"[Keyword]: stream_filter.sv

[Design Category]: Control Circuits

[Design Function Description]:
The circuit functions as a stream filter that controls the flow of data between upstream and downstream components. If the `drop_i` signal is asserted (set to 1), the circuit signals readiness to the upstream component regardless of the downstream's state and prevents the propagation of the `valid` signal downstream. If `drop_i` is not asserted, the circuit allows the `valid` signal to pass from upstream to downstream and the `ready` signal to pass from downstream to upstream.

[Input Signal Description]:
- `valid_i`: A logic signal indicating whether the upstream data is valid and ready to be processed.
- `drop_i`: A control signal that determines whether the data should be dropped (1) or allowed to pass through (0).
- `ready_i`: A logic signal from the downstream component indicating whether it is ready to receive data.

[Output Signal Description]:
- `valid_o`: A logic signal indicating whether the data is valid and should be propagated to the downstream component. It is set to 0 if `drop_i` is 1, otherwise it follows `valid_i`.
- `ready_o`: A logic signal indicating to the upstream component whether the circuit is ready to receive more data. It is set to 1 if `drop_i` is 1, otherwise it follows `ready_i`.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Stream filter: If `drop_i` is `1`, signal `ready` to the upstream regardless of the downstream,
// and do not propagate `valid` downstream.  Otherwise, connect upstream to downstream.
module stream_filter (
    input  logic valid_i,
    output logic ready_o,

    input  logic drop_i,

    output logic valid_o,
    input  logic ready_i
);

    assign valid_o = drop_i ? 1'b0 : valid_i;
    assign ready_o = drop_i ? 1'b1 : ready_i;

endmodule
",stream_filter.sv.txt,common_cells\stream_filter.sv.txt
"[Keyword]: stream_fork.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream fork module that manages the ready-valid handshake protocol for streaming data. It connects a single input stream to multiple output streams, ensuring that each output stream handshakes exactly once for each input stream handshake. The input stream only handshakes when all output streams have completed their handshakes, but the output streams do not need to handshake simultaneously.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronizing the operations.
- `rst_ni`: Active-low reset signal to initialize the state of the module.
- `valid_i`: Input signal indicating the validity of the input stream data.
- `ready_i[N_OUP-1:0]`: Array of input signals indicating the readiness of each output stream to receive data.

[Output Signal Description]:
- `ready_o`: Output signal indicating the readiness of the input stream to send data.
- `valid_o[N_OUP-1:0]`: Array of output signals indicating the validity of data for each output stream.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Stream fork: Connects the input stream (ready-valid) handshake to *all* of `N_OUP` output stream
// handshakes. For each input stream handshake, every output stream handshakes exactly once. The
// input stream only handshakes when all output streams have handshaked, but the output streams do
// not have to handshake simultaneously.
//
// This module has no data ports because stream data does not need to be forked: the data of the
// input stream can just be applied at all output streams.

`include ""common_cells/assertions.svh""

module stream_fork #(
    parameter int unsigned N_OUP = 0    // Synopsys DC requires a default value for parameters.
) (
    input  logic                clk_i,
    input  logic                rst_ni,
    input  logic                valid_i,
    output logic                ready_o,
    output logic [N_OUP-1:0]    valid_o,
    input  logic [N_OUP-1:0]    ready_i
);

    typedef enum logic {READY, WAIT} state_t;

    logic [N_OUP-1:0]   oup_ready,
                        all_ones;

    state_t inp_state_d, inp_state_q;

    // Input control FSM
    always_comb begin
        // ready_o     = 1'b0;
        inp_state_d = inp_state_q;

        unique case (inp_state_q)
            READY: begin
                if (valid_i) begin
                    if (valid_o == all_ones && ready_i == all_ones) begin
                        // If handshake on all outputs, handshake on input.
                        ready_o = 1'b1;
                    end else begin
                        ready_o = 1'b0;
                        // Otherwise, wait for inputs that did not handshake yet.
                        inp_state_d = WAIT;
                    end
                end else begin
                    ready_o = 1'b0;
                end
            end
            WAIT: begin
                if (valid_i && oup_ready == all_ones) begin
                    ready_o = 1'b1;
                    inp_state_d = READY;
                end else begin
                    ready_o = 1'b0;
                end
            end
            default: begin
                inp_state_d = READY;
                ready_o = 1'b0;
            end
        endcase
    end

    always_ff @(posedge clk_i, negedge rst_ni) begin
        if (!rst_ni) begin
            inp_state_q <= READY;
        end else begin
            inp_state_q <= inp_state_d;
        end
    end

    // Output control FSM
    for (genvar i = 0; i < N_OUP; i++) begin: gen_oup_state
        state_t oup_state_d, oup_state_q;

        always_comb begin
            oup_ready[i]    = 1'b1;
            valid_o[i]      = 1'b0;
            oup_state_d     = oup_state_q;

            unique case (oup_state_q)
                READY: begin
                    if (valid_i) begin
                        valid_o[i] = 1'b1;
                        if (ready_i[i]) begin   // Output handshake
                            if (!ready_o) begin     // No input handshake yet
                                oup_state_d = WAIT;
                            end
                        end else begin          // No output handshake
                            oup_ready[i] = 1'b0;
                        end
                    end
                end
                WAIT: begin
                    if (valid_i && ready_o) begin   // Input handshake
                        oup_state_d = READY;
                    end
                end
                default: begin
                    oup_state_d = READY;
                end
            endcase
        end

        always_ff @(posedge clk_i, negedge rst_ni) begin
            if (!rst_ni) begin
                oup_state_q <= READY;
            end else begin
                oup_state_q <= oup_state_d;
            end
        end
    end

    assign all_ones = '1;   // Synthesis fix for Vivado, which does not correctly compute the width
                            // of the '1 literal when assigned to a port of parametrized width.

`ifndef COMMON_CELLS_ASSERTS_OFF
    `ASSERT_INIT(n_oup_0, N_OUP >= 1, ""Number of outputs must be at least 1!"")
`endif

endmodule
",stream_fork.sv.txt,common_cells\stream_fork.sv.txt
"[Keyword]: stream_fork_dynamic.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements a dynamic stream fork for ready-valid handshake protocols. It connects an input stream to multiple output streams based on a dynamically provided bitmask. Each output stream is handshaked exactly once for each input stream handshake. The input stream only handshakes when all selected output streams have completed their handshakes.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronization.
- `rst_ni`: Asynchronous reset signal, active low, used to reset the circuit.
- `valid_i`: Indicates when the input stream is valid and ready for processing.
- `sel_i[N_OUP-1:0]`: Bitmask selection for determining which output streams should be active.
- `sel_valid_i`: Indicates when the selection mask is valid and can be used for output stream selection.
- `ready_i[N_OUP-1:0]`: Indicates when each output stream is ready to accept data.

[Output Signal Description]:
- `ready_o`: Indicates when the input stream is ready to accept new data.
- `sel_ready_o`: Indicates when the selection mask can be updated.
- `valid_o[N_OUP-1:0]`: Indicates when each output stream is valid and ready to send data.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Authors:
// - Andreas Kurth <akurth@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

/// Dynamic stream fork: Connects the input stream (ready-valid) handshake to a combination of output
/// stream handshake.  The combination is determined dynamically through another stream, which
/// provides a bitmask for the fork.  For each input stream handshake, every output stream handshakes
/// exactly once. The input stream only handshakes when all output streams have handshaked, but the
/// output streams do not have to handshake simultaneously.
///
/// This module has no data ports because stream data does not need to be forked: the data of the
/// input stream can just be applied at all output streams.
module stream_fork_dynamic #(
  /// Number of output streams
  parameter int unsigned N_OUP = 32'd0 // Synopsys DC requires a default value for parameters.
) (
  /// Clock
  input  logic             clk_i,
  /// Asynchronous reset, active low
  input  logic             rst_ni,
  /// Input stream valid handshake,
  input  logic             valid_i,
  /// Input stream ready handshake
  output logic             ready_o,
  /// Selection mask for the output handshake
  input  logic [N_OUP-1:0] sel_i,
  /// Selection mask valid
  input  logic             sel_valid_i,
  /// Selection mask ready
  output logic             sel_ready_o,
  /// Output streams valid handshakes
  output logic [N_OUP-1:0] valid_o,
  /// Output streams ready handshakes
  input  logic [N_OUP-1:0] ready_i
);

  logic             int_inp_valid,  int_inp_ready;
  logic [N_OUP-1:0] int_oup_valid,  int_oup_ready;

  // Output handshaking
  for (genvar i = 0; i < N_OUP; i++) begin : gen_oups
    always_comb begin
      valid_o[i]       = 1'b0;
      int_oup_ready[i] = 1'b0;
      if (sel_valid_i) begin
        if (sel_i[i]) begin
          valid_o[i]       = int_oup_valid[i];
          int_oup_ready[i] = ready_i[i];
        end else begin
          int_oup_ready[i] = 1'b1;
        end
      end
    end
  end

  // Input handshaking
  always_comb begin
    int_inp_valid = 1'b0;
    ready_o       = 1'b0;
    sel_ready_o   = 1'b0;
    if (sel_valid_i) begin
      int_inp_valid = valid_i;
      ready_o       = int_inp_ready;
      sel_ready_o   = int_inp_ready;
    end
  end

  stream_fork #(
    .N_OUP  ( N_OUP )
  ) i_fork (
    .clk_i,
    .rst_ni,
    .valid_i ( int_inp_valid ),
    .ready_o ( int_inp_ready ),
    .valid_o ( int_oup_valid ),
    .ready_i ( int_oup_ready )
  );

`ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(n_oup_0, N_OUP >= 1, ""N_OUP must be at least 1!"")
`endif
endmodule
",stream_fork_dynamic.sv.txt,common_cells\stream_fork_dynamic.sv.txt
"[Keyword]: stream_intf.sv

[Design Category]: Interface Circuits

[Design Function Description]:
This design defines a stream interface with a custom payload type, following the handshaking rules as defined in the AXI standard. It facilitates data transfer between modules using a valid-ready handshake mechanism, ensuring data stability during the transfer process.

[Input Signal Description]:
- `clk_i`: The clock input signal for the interface, used to synchronize the data transfer.
- `valid`: An input signal in the In modport indicating that the data is valid and ready to be transferred.
- `data`: The custom payload data of type `payload_t` that is to be transferred.
- `ready`: An input signal in the Out modport indicating that the receiving end is ready to accept the data.

[Output Signal Description]:
- `ready`: An output signal in the In modport indicating that the receiving end is ready to accept the data.
- `valid`: An output signal in the Out modport indicating that the data is valid and ready to be transferred.
- `data`: The custom payload data of type `payload_t` that is to be transferred.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

/// A stream interface with custom payload of type `payload_t`.
/// Handshaking rules as defined in the AXI standard.
interface STREAM_DV #(
  /// Custom payload type.
  parameter type payload_t = logic
)(
  /// Interface clock.
  input logic clk_i
);
  payload_t data;
  logic valid;
  logic ready;

  modport In (
    output ready,
    input valid, data
  );

  modport Out (
    output valid, data,
    input ready
  );

  /// Passive modport for scoreboard and monitors.
  modport Passive (
    input valid, ready, data
  );

  // Make sure that the handshake and payload is stable
  `ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT(data_unstable, (valid && !ready |=> $stable(data)), clk_i, 1'b0)
  `ASSERT(valid_unstable, (valid && !ready |=> valid), clk_i, 1'b0)
  `endif
endinterface
",stream_intf.sv.txt,common_cells\stream_intf.sv.txt
"[Keyword]: stream_join.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream join module that combines multiple input streams into a single output stream. It uses a valid-ready handshaking protocol similar to AXI4, where the output handshake occurs only when all input streams are valid. This module does not handle the data channel directly; it focuses on the control signals for stream synchronization.

[Input Signal Description]:
- `inp_valid_i[N_INP-1:0]`: An array of valid signals for each input stream. Each bit indicates whether the corresponding input stream is valid.
- `oup_ready_i`: A single ready signal for the output stream, indicating whether the downstream component is ready to accept data.

[Output Signal Description]:
- `inp_ready_o[N_INP-1:0]`: An array of ready signals for each input stream. Each bit indicates whether the corresponding input stream can send data.
- `oup_valid_o`: A single valid signal for the output stream, indicating that the output data is valid and ready to be transferred.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Authors:
// - Andreas Kurth <akurth@iis.ee.ethz.ch>

/// Stream join: Joins a parametrizable number of input streams (i.e., valid-ready handshaking with
/// dependency rules as in AXI4) to a single output stream.  The output handshake happens only once
/// all inputs are valid.  The data channel flows outside of this module.
module stream_join #(
  /// Number of input streams
  parameter int unsigned N_INP = 32'd0 // Synopsys DC requires a default value for parameters.
) (
  /// Input streams valid handshakes
  input  logic  [N_INP-1:0] inp_valid_i,
  /// Input streams ready handshakes
  output logic  [N_INP-1:0] inp_ready_o,
  /// Output stream valid handshake
  output logic              oup_valid_o,
  /// Output stream ready handshake
  input  logic              oup_ready_i
);

  stream_join_dynamic #(
    .N_INP(N_INP)
  ) i_stream_join_dynamic (
    .inp_valid_i(inp_valid_i),
    .inp_ready_o(inp_ready_o),
    .sel_i      ({N_INP{1'b1}}),
    .oup_valid_o(oup_valid_o),
    .oup_ready_i(oup_ready_i)
  );

endmodule
",stream_join.sv.txt,common_cells\stream_join.sv.txt
"[Keyword]: stream_join_dynamic.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream joiner that dynamically combines multiple input streams into a single output stream. It uses a valid-ready handshake protocol, similar to AXI4, to manage the flow of data. The selection of which input streams to join is controlled dynamically by a selection mask (`sel_i`). The output stream is only valid when there is a valid handshake on the selected input streams.

[Input Signal Description]:
- `inp_valid_i[N_INP-1:0]`: An array of valid signals for each input stream, indicating whether the data on the corresponding input stream is valid.
- `sel_i[N_INP-1:0]`: A selection mask that determines which input streams are to be joined and considered for the output stream. Each bit corresponds to an input stream.
- `oup_ready_i`: A ready signal for the output stream, indicating whether the downstream component is ready to accept data.

[Output Signal Description]:
- `inp_ready_o[N_INP-1:0]`: An array of ready signals for each input stream, indicating whether the module is ready to accept data from the corresponding input stream.
- `oup_valid_o`: A valid signal for the output stream, indicating that the output data is valid and can be consumed by the downstream component.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Authors:
// - Luca Colagrande <colluca@iis.ee.ethz.ch>

`include ""common_cells/assertions.svh""

// Stream join dynamic: Joins a parametrizable number of input streams (i.e. valid-ready
// handshaking with dependency rules as in AXI4) to a single output stream. The subset of streams
// to join can be configured dynamically via `sel_i`. The output handshake happens only after
// there has been a handshake. The data channel flows outside of this module.
module stream_join_dynamic #(
  /// Number of input streams
  parameter int unsigned N_INP = 32'd0 // Synopsys DC requires a default value for parameters.
) (
  /// Input streams valid handshakes
  input  logic [N_INP-1:0] inp_valid_i,
  /// Input streams ready handshakes
  output logic [N_INP-1:0] inp_ready_o,
  /// Selection mask for the output handshake
  input  logic [N_INP-1:0] sel_i,
  /// Output stream valid handshake
  output logic             oup_valid_o,
  /// Output stream ready handshake
  input  logic             oup_ready_i
);

  // Corner case when `sel_i` is all 0s should not generate valid
  assign oup_valid_o = &(inp_valid_i | ~sel_i) && |sel_i;
  for (genvar i = 0; i < N_INP; i++) begin : gen_inp_ready
    assign inp_ready_o[i] = oup_valid_o & oup_ready_i & sel_i[i];
  end

`ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(n_inp_0, N_INP >= 1, ""N_INP must be at least 1!"")
`endif
endmodule
",stream_join_dynamic.sv.txt,common_cells\stream_join_dynamic.sv.txt
"[Keyword]: stream_mux.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream multiplexer that connects the output to one of multiple data streams using valid-ready handshaking. It selects one of the input data streams based on a selection signal and forwards it to the output, along with its valid signal. The ready signal is also managed to ensure proper handshaking.

[Input Signal Description]:
- `inp_data_i[N_INP-1:0]`: An array of input data streams, each of type `DATA_T`.
- `inp_valid_i[N_INP-1:0]`: An array of valid signals corresponding to each input data stream, indicating if the data is valid.
- `inp_sel_i[LOG_N_INP-1:0]`: A selection signal used to choose which input data stream to connect to the output.
- `oup_ready_i`: A ready signal from the output side, indicating if the output is ready to accept data.

[Output Signal Description]:
- `inp_ready_o[N_INP-1:0]`: An array of ready signals for each input data stream, indicating if the corresponding input can send data.
- `oup_data_o`: The selected output data stream of type `DATA_T`, based on the selection signal.
- `oup_valid_o`: A valid signal for the output data, indicating if the output data is valid.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

`include ""common_cells/assertions.svh""

/// Stream multiplexer: connects the output to one of `N_INP` data streams with valid-ready
/// handshaking.

module stream_mux #(
  parameter type DATA_T = logic,  // Vivado requires a default value for type parameters.
  parameter integer N_INP = 0,    // Synopsys DC requires a default value for value parameters.
  /// Dependent parameters, DO NOT OVERRIDE!
  parameter integer LOG_N_INP = $clog2(N_INP)
) (
  input  DATA_T [N_INP-1:0]     inp_data_i,
  input  logic  [N_INP-1:0]     inp_valid_i,
  output logic  [N_INP-1:0]     inp_ready_o,

  input  logic  [LOG_N_INP-1:0] inp_sel_i,

  output DATA_T                 oup_data_o,
  output logic                  oup_valid_o,
  input  logic                  oup_ready_i
);

  always_comb begin
    inp_ready_o = '0;
    inp_ready_o[inp_sel_i] = oup_ready_i;
  end
  assign oup_data_o   = inp_data_i[inp_sel_i];
  assign oup_valid_o  = inp_valid_i[inp_sel_i];

`ifndef COMMON_CELLS_ASSERTS_OFF
  `ASSERT_INIT(n_inp_0, N_INP >= 1, ""The number of inputs must be at least 1!"")
`endif

endmodule
",stream_mux.sv.txt,common_cells\stream_mux.sv.txt
"[Keyword]: stream_omega_net.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements an Omega network, which is a type of multistage interconnection network used for routing data between multiple inputs and outputs. It uses multiple `stream_xbar` modules as switches to facilitate data routing. The network is isomorphic to a butterfly network and adheres to the handshaking rules defined by the AMBA AXI standard. The Omega network can handle a configurable number of inputs and outputs, with support for different radix values for the switch points. It includes features like spill registers, external priority, and strict AXI valid-ready handshaking.

[Input Signal Description]:
- `clk_i`: Clock input, positive edge triggered.
- `rst_ni`: Asynchronous reset, active low.
- `flush_i`: Signal to flush the state of internal `rr_arb_tree` modules.
- `rr_i`: External state for `rr_arb_tree` models, used if `ExtPrio` is set.
- `data_i`: Input data ports, stable when `valid_i` is asserted if `AxiVldRdy` is set.
- `sel_i`: Selection of the output port for routing data, stable when `valid_i` is asserted if `AxiVldRdy` is set.
- `valid_i`: Indicates if the input data is valid.
- `ready_i`: Indicates if the output can accept data.

[Output Signal Description]:
- `ready_o`: Indicates if the input is ready to accept data.
- `data_o`: Output data ports, valid if `valid_o` is asserted.
- `idx_o`: Index of the input port from which the data originated.
- `valid_o`: Indicates if the output data is valid.


[Design Detail]:
// Copyright (c) 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Wolfgang Roenninger <wroennin@ethz.ch>

`include ""common_cells/assertions.svh""

/// Omega network using multiple `stream_xbar` as switches.
///
/// An omega network is isomorphic to a butterfly network.
///
/// Handshaking rules as defined by the `AMBA AXI` standard on default.
module stream_omega_net #(
  /// Number of inputs into the network (`> 0`).
  parameter int unsigned NumInp      = 32'd0,
  /// Number of outputs from the network (`> 0`).
  parameter int unsigned NumOut      = 32'd0,
  /// Radix of the individual switch points of the network.
  /// Currently supported are `32'd2` and `32'd4`.
  parameter int unsigned Radix       = 32'd2,
  /// Data width of the stream. Can be overwritten by defining the type parameter `payload_t`.
  parameter int unsigned DataWidth   = 32'd1,
  /// Payload type of the data ports, only usage of parameter `DataWidth`.
  parameter type         payload_t   = logic [DataWidth-1:0],
  /// Adds a spill register stage at each output.
  parameter bit          SpillReg = 1'b0,
  /// Use external priority for the individual `rr_arb_trees`.
  parameter int unsigned ExtPrio     = 1'b0,
  /// Use strict AXI valid ready handshaking.
  /// To be protocol conform also the parameter `LockIn` has to be set.
  parameter int unsigned AxiVldRdy   = 1'b1,
  /// Lock in the arbitration decision of the `rr_arb_tree`.
  /// When this is set, valids have to be asserted until the corresponding transaction is indicated
  /// by ready.
  parameter int unsigned LockIn      = 1'b1,
  /// If `AxiVldReady` is 1, which bits of the payload to check for stability on valid inputs.
  /// In some cases, we may want to allow parts of the payload to change depending on the value of
  /// other parts (e.g. write data in read requests), requiring more nuanced external assertions.
  parameter payload_t    AxiVldMask  = '1,
  /// Derived parameter, do **not** overwrite!
  ///
  /// Width of the output selection signal.
  parameter int unsigned SelWidth = (NumOut > 32'd1) ? unsigned'($clog2(NumOut)) : 32'd1,
  /// Derived parameter, do **not** overwrite!
  ///
  /// Signal type definition for selecting the output at the inputs.
  parameter type sel_oup_t = logic[SelWidth-1:0],
  /// Derived parameter, do **not** overwrite!
  ///
  /// Width of the input index signal.
  parameter int unsigned IdxWidth = (NumInp > 32'd1) ? unsigned'($clog2(NumInp)) : 32'd1,
  /// Derived parameter, do **not** overwrite!
  ///
  /// Signal type definition indicating from which input the output came.
  parameter type idx_inp_t = logic[IdxWidth-1:0]
) (
  /// Clock, positive edge triggered.
  input  logic                  clk_i,
  /// Asynchronous reset, active low.
  input  logic                  rst_ni,
  /// Flush the state of the internal `rr_arb_tree` modules.
  /// If not used set to `0`.
  /// Flush should only be used if there are no active `valid_i`, otherwise it will
  /// not adhere to the AXI handshaking.
  input  logic                  flush_i,
  /// Provide an external state for the `rr_arb_tree` models.
  /// Will only do something if ExtPrio is `1` otherwise tie to `0`.
  input  idx_inp_t [NumOut-1:0] rr_i,
  /// Input data ports.
  /// Has to be stable as long as `valid_i` is asserted when parameter `AxiVldRdy` is set.
  input  payload_t [NumInp-1:0] data_i,
  /// Selection of the output port where the data should be routed.
  /// Has to be stable as long as `valid_i` is asserted and parameter `AxiVldRdy` is set.
  input  sel_oup_t [NumInp-1:0] sel_i,
  /// Input is valid.
  input  logic     [NumInp-1:0] valid_i,
  /// Input is ready to accept data.
  output logic     [NumInp-1:0] ready_o,
  /// Output data ports. Valid if `valid_o = 1`
  output payload_t [NumOut-1:0] data_o,
  /// Index of the input port where data came from.
  output idx_inp_t [NumOut-1:0] idx_o,
  /// Output is valid.
  output logic     [NumOut-1:0] valid_o,
  /// Output can be accepted.
  input  logic     [NumOut-1:0] ready_i
);
  if (NumInp <= Radix && NumOut <= Radix) begin : gen_degenerate_omega_net
    // If both Number of inputs and number of outputs are smaller or the same as the radix
    // just instantiate a `stream_xbar`.
    stream_xbar #(
      .NumInp      ( NumInp    ),
      .NumOut      ( NumOut    ),
      .payload_t   ( payload_t ),
      .OutSpillReg ( SpillReg  ),
      .ExtPrio     ( ExtPrio   ),
      .AxiVldRdy   ( AxiVldRdy ),
      .LockIn      ( LockIn    )
    ) i_stream_xbar (
      .clk_i,
      .rst_ni,
      .flush_i,
      .rr_i    ( rr_i    ),
      .data_i  ( data_i  ),
      .sel_i   ( sel_i   ),
      .valid_i ( valid_i ),
      .ready_o ( ready_o ),
      .data_o  ( data_o  ),
      .idx_o   ( idx_o   ),
      .valid_o ( valid_o ),
      .ready_i ( ready_i )
    );
  end else begin : gen_omega_net
    // Find the next power of radix of either the number of inputs or number of outputs.
    // This normalizes the network to a power of the radix. Unused inputs and outputs are tied off.
    // If the radix is poorly chosen with respect to the number of input/outputs ports
    // will lead to an explosion of tied off lanes, which will be removed during optimization.
    // Can lead however to RTL simulation overhead.
    // Dividing through the log base 2 of `Radix` leads to a change of base.
    localparam int unsigned NumLanes = (NumOut > NumInp) ?
        unsigned'(Radix**(cf_math_pkg::ceil_div($clog2(NumOut), $clog2(Radix)))) :
        unsigned'(Radix**(cf_math_pkg::ceil_div($clog2(NumInp), $clog2(Radix))));

    // Find the number of routing levels needed.
    localparam int unsigned NumLevels = unsigned'(($clog2(NumLanes)+$clog2(Radix)-1)/$clog2(Radix));

    // Find the number of routes per network stage. Can use a normal division here, as
    // `NumLanes % Radix == 0`.
    localparam int unsigned NumRouters = NumLanes / Radix;

    // Define the type of sel signal to send through the network. It has to be sliced for the
    // individual sel signals of a stage. This slicing has to align with `$clog2(Radix)`.
    // For example `Radix = 4`, `NumOut = 17` will lead to the sel signal of an individual stage to
    // be 2 bit wide, whereas signal `sel_i` of the module will be 5 bit wide.
    // To prevent slicing into an undefined field the overall sel signal is then defined with
    // width 6.
    typedef logic [$clog2(NumLanes)-1:0] sel_dst_t;

    // Selection signal type of an individual router
    localparam int unsigned SelW = unsigned'($clog2(Radix));
    initial begin : proc_selw
      $display(""SelW is:    %0d"", SelW);
      $display(""SelDstW is: %0d"", $bits(sel_dst_t));
    end
    typedef logic [SelW-1:0] sel_t;

    // Define the payload which should be routed through the network.
    typedef struct packed {
      sel_dst_t sel_oup; // Selection of output, where it should be routed
      payload_t payload; // External payload data
      idx_inp_t idx_inp; // Index of the input of this packet
    } omega_data_t;

    // signal definitions
    omega_data_t [NumLevels-1:0][NumRouters-1:0][Radix-1:0] inp_router_data;
    logic        [NumLevels-1:0][NumRouters-1:0][Radix-1:0] inp_router_valid, inp_router_ready;
    omega_data_t [NumLevels-1:0][NumRouters-1:0][Radix-1:0] out_router_data;
    logic        [NumLevels-1:0][NumRouters-1:0][Radix-1:0] out_router_valid, out_router_ready;

    // Generate the shuffling between the routers
    for (genvar i = 0; unsigned'(i) < NumLevels-1; i++) begin : gen_shuffle_levels
      for (genvar j = 0; unsigned'(j) < NumRouters; j++) begin : gen_shuffle_routers
        for (genvar k = 0; unsigned'(k) < Radix; k++) begin : gen_shuffle_radix
          // This parameter is from `0` to `NumLanes-1`
          localparam int unsigned IdxLane = Radix * j + k;
          // Do the perfect shuffle
          assign inp_router_data[i+1][IdxLane%NumRouters][IdxLane/NumRouters] =
              out_router_data[i][j][k];

          assign inp_router_valid[i+1][IdxLane%NumRouters][IdxLane/NumRouters] =
              out_router_valid[i][j][k];

          assign out_router_ready[i][j][k] =
              inp_router_ready[i+1][IdxLane%NumRouters][IdxLane/NumRouters];

          // Do the first input shuffle of layer 0.
          // The inputs are connected in reverse. The reason is that then the optimization
          // leaves then the biggest possible network diameter.
          if (i == 0) begin : gen_shuffle_inp
            // Reverse the order of the input ports
            if ((NumLanes-IdxLane) <= NumInp) begin : gen_inp_ports
              localparam int unsigned IdxInp = NumLanes - IdxLane - 32'd1;
              assign inp_router_data[0][IdxLane%NumRouters][IdxLane/NumRouters] = '{
                    sel_oup: sel_dst_t'(sel_i[IdxInp]),
                    payload: data_i[IdxInp],
                    idx_inp: idx_inp_t'(IdxInp)
                  };

              assign inp_router_valid[0][IdxLane%NumRouters][IdxLane/NumRouters] = valid_i[IdxInp];
              assign ready_o[IdxInp] = inp_router_ready[0][IdxLane%NumRouters][IdxLane/NumRouters];

            end else begin : gen_tie_off
              assign inp_router_data[0][IdxLane%NumRouters][IdxLane/NumRouters] = '{ default: '0};
              assign inp_router_valid[0][IdxLane%NumRouters][IdxLane/NumRouters] = 1'b0;
            end
          end
        end
      end
    end

    // Generate the `stream_xbar_routers`
    for (genvar i = 0; unsigned'(i) < NumLevels; i++) begin : gen_router_levels
      for (genvar j = 0; unsigned'(j) < NumRouters; j++) begin : gen_routers
        sel_t [Radix-1:0] sel_router;
        for (genvar k = 0; unsigned'(k) < Radix; k++) begin : gen_router_sel
          // For the inter stage routing some bits of the overall selection are important.
          // The `MSB` is for stage `0`, `MSB-1` for stage `1` and so on for the `Radix=2` case.
          // For higher radices's a bit slice following the same pattern is used.
          // This is the reason that the internal network is expanded to a power of two, so that
          // the selection slicing always has a valid index.
          assign sel_router[k] = inp_router_data[i][j][k].sel_oup[SelW*(NumLevels-i-1)+:SelW];
        end

        stream_xbar #(
          .NumInp      ( Radix        ),
          .NumOut      ( Radix        ),
          .payload_t   ( omega_data_t ),
          .OutSpillReg ( SpillReg     ),
          .ExtPrio     ( 1'b0         ),
          .AxiVldRdy   ( AxiVldRdy    ),
          .LockIn      ( LockIn       )
        ) i_stream_xbar (
          .clk_i,
          .rst_ni,
          .flush_i,
          .rr_i    ( '0                     ),
          .data_i  ( inp_router_data[i][j]  ),
          .sel_i   ( sel_router             ),
          .valid_i ( inp_router_valid[i][j] ),
          .ready_o ( inp_router_ready[i][j] ),
          .data_o  ( out_router_data[i][j]  ),
          .idx_o   ( /* not used */         ),
          .valid_o ( out_router_valid[i][j] ),
          .ready_i ( out_router_ready[i][j] )
        );
      end
    end

    // outputs are on the last level
    for (genvar i = 0; unsigned'(i) < NumLanes; i++) begin : gen_outputs
      if (i < NumOut) begin : gen_connect
        assign data_o[i]  = out_router_data[NumLevels-1][i/Radix][i%Radix].payload;
        assign idx_o[i]   = out_router_data[NumLevels-1][i/Radix][i%Radix].idx_inp;
        assign valid_o[i] = out_router_valid[NumLevels-1][i/Radix][i%Radix];
        assign out_router_ready[NumLevels-1][i/Radix][i%Radix] = ready_i[i];
      end else begin : gen_tie_off
        assign out_router_ready[NumLevels-1][i/Radix][i%Radix] = 1'b0;
      end
    end

    initial begin : proc_debug_print
      $display(""NumInp:     %0d"", NumInp);
      $display(""NumOut:     %0d"", NumOut);
      $display(""Radix:      %0d"", Radix);
      $display(""NumLanes:   %0d"", NumLanes);
      $display(""NumLevels:  %0d"", NumLevels);
      $display(""NumRouters: %0d"", NumRouters);
    end

    // Assertions
    // Make sure that the handshake and payload is stable
    `ifndef COMMON_CELLS_ASSERTS_OFF
    for (genvar i = 0; unsigned'(i) < NumInp; i++) begin : gen_sel_assertions
      `ASSERT(non_existing_output, valid_i[i] |-> sel_i[i] < NumOut, clk_i, !rst_ni,
              ""Non-existing output is selected!"")
    end

    if (AxiVldRdy) begin : gen_handshake_assertions
      for (genvar i = 0; unsigned'(i) < NumInp; i++) begin : gen_inp_assertions
        `ASSERT(input_data_unstable, valid_i[i] && !ready_o[i] |=> $stable(data_i[i] & AxiVldMask),
                clk_i, !rst_ni, $sformatf(""data_i is unstable at input: %0d"", i))
        `ASSERT(input_sel_unstable, valid_i[i] && !ready_o[i] |=> $stable(sel_i[i]),
                clk_i, !rst_ni, $sformatf(""sel_i is unstable at input: %0d"", i))
        `ASSERT(input_valid_taken, valid_i[i] && !ready_o[i] |=> valid_i[i], clk_i, !rst_ni,
                $sformatf(""valid_i at input %0d has been taken away without a ready."", i))
      end
      for (genvar i = 0; unsigned'(i) < NumOut; i++) begin : gen_out_assertions
        `ASSERT(output_data_unstable, valid_o[i] && !ready_i[i] |=> $stable(data_o[i] & AxiVldMask),
                clk_i, !rst_ni,
                $sformatf(""data_o is unstable at output: %0d Check that parameter LockIn is set."",
                          i))
        `ASSERT(output_idx_unstable, valid_o[i] && !ready_i[i] |=> $stable(idx_o[i]),
                clk_i, !rst_ni,
                $sformatf(""idx_o is unstable at output: %0d Check that parameter LockIn is set."",
                          i))
        `ASSERT(output_valid_taken, valid_o[i] && !ready_i[i] |=> valid_o[i], clk_i, !rst_ni,
                $sformatf(""valid_o at output %0d has been taken away without a ready."", i))
      end
    end

    `ASSERT_INIT(radix_not_power_of_2, (2**$clog2(Radix) == Radix) && (Radix > 32'd1),
                 ""Radix is not power of two."")
    `ASSERT_INIT(num_routers_not_power_of_2, 2**$clog2(NumRouters) == NumRouters,
                 ""NumRouters is not power of two."")
    `ASSERT_INIT(bit_slicing_broken, $clog2(NumLanes) % SelW == 0,
                 ""Bit slicing of the internal selection signal is broken."")
    `endif
  end
endmodule
",stream_omega_net.sv.txt,common_cells\stream_omega_net.sv.txt
"[Keyword]: stream_register.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a stream register that implements a simple ready/valid handshake protocol. It is used to manage data flow between two components, ensuring that data is only transferred when both the sender and receiver are ready. The register can be cleared synchronously and supports a test mode to bypass clock gating.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the register operations.
- `rst_ni`: Asynchronous active-low reset signal to initialize the register.
- `clr_i`: Synchronous clear signal to reset the register contents.
- `testmode_i`: Test mode signal to bypass clock gating for testing purposes.
- `valid_i`: Input signal indicating that the data on `data_i` is valid and ready to be transferred.
- `ready_i`: Input signal from the receiver indicating it is ready to accept data.
- `data_i`: Input data of type `T` to be stored in the register.

[Output Signal Description]:
- `ready_o`: Output signal indicating that the register is ready to accept new data.
- `valid_o`: Output signal indicating that the data on `data_o` is valid and ready to be read by the receiver.
- `data_o`: Output data of type `T` that is stored in the register and ready to be transferred to the receiver.


[Design Detail]:
// Copyright 2022 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

`include ""common_cells/registers.svh""

/// Register with a simple stream-like ready/valid handshake.
/// This register does not cut combinatorial paths on all control signals; if you need a complete
/// cut, use the `spill_register`.
module stream_register #(
    parameter type T = logic  // Vivado requires a default value for type parameters.
) (
    input  logic    clk_i,          // Clock
    input  logic    rst_ni,         // Asynchronous active-low reset
    input  logic    clr_i,          // Synchronous clear
    input  logic    testmode_i,     // Test mode to bypass clock gating
    // Input port
    input  logic    valid_i,
    output logic    ready_o,
    input  T        data_i,
    // Output port
    output logic    valid_o,
    input  logic    ready_i,
    output T        data_o
);

    logic reg_ena;
    assign ready_o = ready_i | ~valid_o;
    assign reg_ena = valid_i & ready_o;
    // Load-enable FFs with synch clear
    `FFLARNC(valid_o, valid_i, ready_o, clr_i, 1'b0  , clk_i, rst_ni)
    `FFLARNC(data_o,   data_i, reg_ena, clr_i, T'('0), clk_i, rst_ni)

endmodule
",stream_register.sv.txt,common_cells\stream_register.sv.txt
"[Keyword]: stream_throttle.sv

[Design Category]: Control Circuits

[Design Function Description]:
The module `stream_throttle` is designed to manage the flow of data in a ready-valid handshaked bus system. It controls the number of outstanding transfers by using a credit counter. The maximum number of allowable outstanding requests is set as a compile-time parameter, while the actual number of outstanding transfers can be adjusted during runtime. The module ensures that requests are processed in order or that requests/responses are indistinguishable.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing the operations.
- `rst_ni`: Asynchronous reset signal, active low, used to reset the state of the module.
- `req_valid_i`: Input signal indicating that a request is valid and ready to be processed.
- `req_ready_i`: Input signal indicating that the system is ready to accept a request.
- `rsp_valid_i`: Input signal indicating that a response is valid and ready to be processed.
- `rsp_ready_i`: Input signal indicating that the system is ready to accept a response.
- `credit_i`: Input signal representing the amount of credit, or the number of outstanding transfers allowed.

[Output Signal Description]:
- `req_valid_o`: Output signal indicating that a request is valid and can be passed on if there is available credit.
- `req_ready_o`: Output signal indicating that the system is ready to accept a request if there is available credit.


[Design Detail]:
// Copyright 2022 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Thomas Benz <tbenz@ethz.ch>

`include ""common_cells/registers.svh""

/// Throttles a ready valid handshaked bus. The maximum number of outstanding transfers have to
/// be set as a compile-time parameter, whereas the number of outstanding transfers can be set
/// during runtime. This module assumes either in-order processing of the requests or
/// indistinguishability of the request/responses.
module stream_throttle #(
    /// The maximum amount of allowable outstanding requests
    parameter int unsigned MaxNumPending = 1,
    /// The width of the credit counter (*DO NOT OVERWRITE*)
    parameter int unsigned CntWidth = cf_math_pkg::idx_width(MaxNumPending),
    /// The type of the credit counter (*DO NOT OVERWRITE*)
    parameter type credit_t = logic [CntWidth-1:0]
) (
    /// Clock
    input  logic clk_i,
    /// Asynchronous reset, active low
    input  logic rst_ni,

    /// Request valid in
    input  logic    req_valid_i,
    /// Request valid out
    output logic    req_valid_o,
    /// Request ready in
    input  logic    req_ready_i,
    /// Request ready out
    output logic    req_ready_o,

    /// Response valid in
    input  logic    rsp_valid_i,
    /// Response ready in
    input  logic    rsp_ready_i,

    /// Amount of credit (number of outstanding transfers)
    input  credit_t credit_i
);

    // we use a credit counter to keep track of how many transfers are pending at any point in
    // time. Valid is passed-through if there is credit.
    credit_t credit_d, credit_q;

    // we have credit available
    logic credit_available;

    // implement the counter. If credit is available let the valid pass, else block it. Increment
    // the counter once a request happens, decrement once a response arrives. Assumes in-order
    // responses.
    always_comb begin : proc_credit_counter

        // default: keep state
        credit_d = credit_q;

        // on valid outgoing request: count up
        if (req_ready_o & req_valid_o) begin
            credit_d = credit_d + 'd1;
        end

        // on valid response: count down
        if (rsp_valid_i & rsp_ready_i) begin
            credit_d = credit_d - 'd1;
        end
    end

    // credit is available
    assign credit_available = credit_q <= (credit_i - 'd1);

    // a request id passed on as valid if the input is valid and we have credit.
    assign req_valid_o = req_valid_i & credit_available;

    // a request id passed on as ready if the input is ready and we have credit.
    assign req_ready_o = req_ready_i & credit_available;

    // state
    `FF(credit_q, credit_d, '0, clk_i, rst_ni)

endmodule : stream_throttle
",stream_throttle.sv.txt,common_cells\stream_throttle.sv.txt
"[Keyword]: stream_to_mem.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The `stream_to_mem` module is designed to interface with memory systems that use flow control for requests but do not use flow control for output data. It manages the handshaking between a request stream and a memory interface, buffering responses if necessary, to ensure smooth data flow and prevent data loss or overflow.

[Input Signal Description]:
- `clk_i`: Clock signal for synchronizing operations.
- `rst_ni`: Asynchronous reset signal, active low, used to initialize or reset the module.
- `req_i`: Memory request payload, which typically includes information like write enable and write data.
- `req_valid_i`: Indicates that the request payload is valid and ready for transfer.
- `resp_ready_i`: Indicates that the response payload can be accepted by the receiving end.
- `mem_req_ready_i`: Indicates that the memory interface can accept a request.
- `mem_resp_i`: Memory response payload, typically includes read data.
- `mem_resp_valid_i`: Indicates that the memory response payload is valid.

[Output Signal Description]:
- `req_ready_o`: Indicates that the request payload can be accepted by the module.
- `resp_o`: Output for the memory response payload.
- `resp_valid_o`: Indicates that the response payload is valid and ready for transfer.
- `mem_req_o`: Output for the memory request payload.
- `mem_req_valid_o`: Indicates that the memory request payload is valid and ready for transfer.


[Design Detail]:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Authors:
// - Andreas Kurth <akurth@iis.ee.ethz.ch>

`include ""common_cells/registers.svh""
`include ""common_cells/assertions.svh""

/// `stream_to_mem`: Allows to use memories with flow control (`valid`/`ready`) for requests but without flow
/// control for output data to be used in streams.
module stream_to_mem #(
  /// Memory request payload type, usually write enable, write data, etc.
  parameter type         mem_req_t  = logic,
  /// Memory response payload type, usually read data
  parameter type         mem_resp_t = logic,
  /// Number of buffered responses (fall-through, thus no additional latency).  This defines the
  /// maximum number of outstanding requests on the memory interface. If the attached memory
  /// responds in the same cycle a request is applied, this MUST be 0. If the attached memory
  /// responds at least one cycle after a request, this MUST be >= 1 and should be equal to the
  /// response latency of the memory to saturate bandwidth.
  parameter int unsigned BufDepth   = 32'd1
) (
  /// Clock
  input  logic      clk_i,
  /// Asynchronous reset, active low
  input  logic      rst_ni,
  /// Request stream interface, payload
  input  mem_req_t  req_i,
  /// Request stream interface, payload is valid for transfer
  input  logic      req_valid_i,
  /// Request stream interface, payload can be accepted
  output logic      req_ready_o,
  /// Response stream interface, payload
  output mem_resp_t resp_o,
  /// Response stream interface, payload is valid for transfer
  output logic      resp_valid_o,
  /// Response stream interface, payload can be accepted
  input  logic      resp_ready_i,
  /// Memory request interface, payload
  output mem_req_t  mem_req_o,
  /// Memory request interface, payload is valid for transfer
  output logic      mem_req_valid_o,
  /// Memory request interface, payload can be accepted
  input  logic      mem_req_ready_i,
  /// Memory response interface, payload
  input  mem_resp_t mem_resp_i,
  /// Memory response interface, payload is valid
  input  logic      mem_resp_valid_i
);

  typedef logic [$clog2(BufDepth+1):0] cnt_t;

  cnt_t cnt_d, cnt_q;
  logic buf_ready,
        req_ready;

  if (BufDepth > 0) begin : gen_buf
    // Count number of outstanding requests.
    always_comb begin
      cnt_d = cnt_q;
      if (req_valid_i && req_ready_o) begin
        cnt_d++;
      end
      if (resp_valid_o && resp_ready_i) begin
        cnt_d--;
      end
    end

    // Can issue another request if the counter is not at its limit or a response is delivered in
    // the current cycle.
    assign req_ready = (cnt_q < BufDepth) | (resp_valid_o & resp_ready_i);

    // Control request and memory request interface handshakes.
    assign req_ready_o = mem_req_ready_i & req_ready;
    assign mem_req_valid_o = req_valid_i & req_ready;

    // Buffer responses.
    stream_fifo #(
      .FALL_THROUGH ( 1'b1       ),
      .DEPTH        ( BufDepth   ),
      .T            ( mem_resp_t )
    ) i_resp_buf (
      .clk_i,
      .rst_ni,
      .flush_i    ( 1'b0             ),
      .testmode_i ( 1'b0             ),
      .data_i     ( mem_resp_i       ),
      .valid_i    ( mem_resp_valid_i ),
      .ready_o    ( buf_ready        ),
      .data_o     ( resp_o           ),
      .valid_o    ( resp_valid_o     ),
      .ready_i    ( resp_ready_i     ),
      .usage_o    ( /* unused */     )
    );

    // Register
    `FFARN(cnt_q, cnt_d, '0, clk_i, rst_ni)

  end else begin : gen_no_buf
    // Control request, memory request, and response interface handshakes.
    assign mem_req_valid_o = req_valid_i;
    assign resp_valid_o    = mem_req_valid_o & mem_req_ready_i & mem_resp_valid_i;
    assign req_ready_o     = resp_ready_i    & resp_valid_o;

    // Forward responses.
    assign resp_o = mem_resp_i;
  end

  // Forward requests.
  assign mem_req_o = req_i;

// Assertions
`ifndef COMMON_CELLS_ASSERTS_OFF
  if (BufDepth > 0) begin : gen_buf_asserts
    `ASSERT(memory_response_lost, mem_resp_valid_i |-> buf_ready, clk_i, !rst_ni,
            ""Memory response lost!"")
    `ASSERT(counter_underflowed, cnt_q == '0 |=> cnt_q != '1, clk_i, !rst_ni,
            ""Counter underflowed!"")
    `ASSERT(counter_overflowed, cnt_q == BufDepth |=> cnt_q != BufDepth + 1, clk_i, !rst_ni,
            ""Counter overflowed!"")
  end else begin : gen_no_buf_asserts
    `ASSUME(no_memory_response, mem_req_valid_o & mem_req_ready_i |-> mem_resp_valid_i,
            clk_i, !rst_ni, ""Without BufDepth = 0, the memory must respond in the same cycle!"")
  end
`endif
endmodule
",stream_to_mem.sv.txt,common_cells\stream_to_mem.sv.txt
"[Keyword]: stream_xbar.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a fully connected stream crossbar that routes data streams from multiple input ports to multiple output ports. It adheres to the AMBA AXI handshaking protocol, ensuring proper data transfer and synchronization between inputs and outputs. The crossbar supports configurable numbers of inputs and outputs, data width, and optional spill registers for output buffering. It also includes round-robin arbitration for managing multiple data streams and ensuring fair access to the outputs.

[Input Signal Description]:
- `clk_i`: Clock signal, positive edge triggered.
- `rst_ni`: Asynchronous reset signal, active low.
- `flush_i`: Signal to flush the state of internal round-robin arbiter trees, should be used when no valid inputs are active.
- `rr_i`: External state for round-robin arbiter trees, used if external priority is enabled.
- `data_i`: Input data ports, stable when `valid_i` is asserted and `AxiVldRdy` is set.
- `sel_i`: Selection signal for routing data to the appropriate output port, stable when `valid_i` is asserted and `AxiVldRdy` is set.
- `valid_i`: Indicates if the input data is valid.
- `ready_i`: Indicates if the output can accept data.

[Output Signal Description]:
- `ready_o`: Indicates if the input is ready to accept data.
- `data_o`: Output data ports, valid when `valid_o` is asserted.
- `idx_o`: Index of the input port from which the data originated.
- `valid_o`: Indicates if the output data is valid.


[Design Detail]:
// Copyright (c) 2020 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Wolfgang Roenninger <wroennin@ethz.ch>

`include ""common_cells/assertions.svh""

/// Fully connected stream crossbar.
///
/// Handshaking rules as defined by the `AMBA AXI` standard on default.
module stream_xbar #(
  /// Number of inputs into the crossbar (`> 0`).
  parameter int unsigned NumInp      = 32'd0,
  /// Number of outputs from the crossbar (`> 0`).
  parameter int unsigned NumOut      = 32'd0,
  /// Data width of the stream. Can be overwritten by defining the type parameter `payload_t`.
  parameter int unsigned DataWidth   = 32'd1,
  /// Payload type of the data ports, only usage of parameter `DataWidth`.
  parameter type         payload_t   = logic [DataWidth-1:0],
  /// Adds a spill register stage at each output.
  parameter bit          OutSpillReg = 1'b0,
  /// Use external priority for the individual `rr_arb_trees`.
  parameter int unsigned ExtPrio     = 1'b0,
  /// Use strict AXI valid ready handshaking.
  /// To be protocol conform also the parameter `LockIn` has to be set.
  parameter int unsigned AxiVldRdy   = 1'b1,
  /// Lock in the arbitration decision of the `rr_arb_tree`.
  /// When this is set, valids have to be asserted until the corresponding transaction is indicated
  /// by ready.
  parameter int unsigned LockIn      = 1'b1,
  /// If `AxiVldReady` is 1, which bits of the payload to check for stability on valid inputs.
  /// In some cases, we may want to allow parts of the payload to change depending on the value of
  /// other parts (e.g. write data in read requests), requiring more nuanced external assertions.
  parameter payload_t    AxiVldMask  = '1,
  /// Derived parameter, do **not** overwrite!
  ///
  /// Width of the output selection signal.
  parameter int unsigned SelWidth = (NumOut > 32'd1) ? unsigned'($clog2(NumOut)) : 32'd1,
  /// Derived parameter, do **not** overwrite!
  ///
  /// Signal type definition for selecting the output at the inputs.
  parameter type sel_oup_t = logic[SelWidth-1:0],
  /// Derived parameter, do **not** overwrite!
  ///
  /// Width of the input index signal.
  parameter int unsigned IdxWidth = (NumInp > 32'd1) ? unsigned'($clog2(NumInp)) : 32'd1,
  /// Derived parameter, do **not** overwrite!
  ///
  /// Signal type definition indicating from which input the output came.
  parameter type idx_inp_t = logic[IdxWidth-1:0]
) (
  /// Clock, positive edge triggered.
  input  logic                  clk_i,
  /// Asynchronous reset, active low.
  input  logic                  rst_ni,
  /// Flush the state of the internal `rr_arb_tree` modules.
  /// If not used set to `0`.
  /// Flush should only be used if there are no active `valid_i`, otherwise it will
  /// not adhere to the AXI handshaking.
  input  logic                  flush_i,
  /// Provide an external state for the `rr_arb_tree` models.
  /// Will only do something if ExtPrio is `1` otherwise tie to `0`.
  input  idx_inp_t [NumOut-1:0] rr_i,
  /// Input data ports.
  /// Has to be stable as long as `valid_i` is asserted when parameter `AxiVldRdy` is set.
  input  payload_t [NumInp-1:0] data_i,
  /// Selection of the output port where the data should be routed.
  /// Has to be stable as long as `valid_i` is asserted and parameter `AxiVldRdy` is set.
  input  sel_oup_t [NumInp-1:0] sel_i,
  /// Input is valid.
  input  logic     [NumInp-1:0] valid_i,
  /// Input is ready to accept data.
  output logic     [NumInp-1:0] ready_o,
  /// Output data ports. Valid if `valid_o = 1`
  output payload_t [NumOut-1:0] data_o,
  /// Index of the input port where data came from.
  output idx_inp_t [NumOut-1:0] idx_o,
  /// Output is valid.
  output logic     [NumOut-1:0] valid_o,
  /// Output can be accepted.
  input  logic     [NumOut-1:0] ready_i
);
  typedef struct packed {
    payload_t data;
    idx_inp_t idx;
  } spill_data_t;

  logic     [NumInp-1:0][NumOut-1:0] inp_valid;
  logic     [NumInp-1:0][NumOut-1:0] inp_ready;

  payload_t [NumOut-1:0][NumInp-1:0] out_data;
  logic     [NumOut-1:0][NumInp-1:0] out_valid;
  logic     [NumOut-1:0][NumInp-1:0] out_ready;

  // Generate the input selection
  for (genvar i = 0; unsigned'(i) < NumInp; i++) begin : gen_inps
    stream_demux #(
      .N_OUP ( NumOut )
    ) i_stream_demux (
      .inp_valid_i ( valid_i[i]   ),
      .inp_ready_o ( ready_o[i]   ),
      .oup_sel_i   ( sel_i[i]     ),
      .oup_valid_o ( inp_valid[i] ),
      .oup_ready_i ( inp_ready[i] )
    );

    // Do the switching cross of the signals.
    for (genvar j = 0; unsigned'(j) < NumOut; j++) begin : gen_cross
      // Propagate the data from this input to all outputs.
      assign out_data[j][i]  = data_i[i];
      // switch handshaking
      assign out_valid[j][i] = inp_valid[i][j];
      assign inp_ready[i][j] = out_ready[j][i];
    end
  end

  // Generate the output arbitration.
  for (genvar j = 0; unsigned'(j) < NumOut; j++) begin : gen_outs
    spill_data_t arb;
    logic        arb_valid, arb_ready;

    rr_arb_tree #(
      .NumIn     ( NumInp    ),
      .DataType  ( payload_t ),
      .ExtPrio   ( ExtPrio   ),
      .AxiVldRdy ( AxiVldRdy ),
      .LockIn    ( LockIn    )
    ) i_rr_arb_tree (
      .clk_i,
      .rst_ni,
      .flush_i,
      .rr_i    ( rr_i[j]      ),
      .req_i   ( out_valid[j] ),
      .gnt_o   ( out_ready[j] ),
      .data_i  ( out_data[j]  ),
      .req_o   ( arb_valid    ),
      .gnt_i   ( arb_ready    ),
      .data_o  ( arb.data     ),
      .idx_o   ( arb.idx      )
    );

    spill_data_t spill;

    spill_register #(
      .T      ( spill_data_t ),
      .Bypass ( !OutSpillReg )
    ) i_spill_register (
      .clk_i,
      .rst_ni,
      .valid_i ( arb_valid  ),
      .ready_o ( arb_ready  ),
      .data_i  ( arb        ),
      .valid_o ( valid_o[j] ),
      .ready_i ( ready_i[j] ),
      .data_o  ( spill      )
    );
    // Assign the outputs (deaggregate the data).
    always_comb begin
      data_o[j] = spill.data;
      idx_o[j]  = spill.idx;
    end
  end

  // Assertions
  // Make sure that the handshake and payload is stable
  `ifndef COMMON_CELLS_ASSERTS_OFF
  for (genvar i = 0; unsigned'(i) < NumInp; i++) begin : gen_sel_assertions
    `ASSERT(non_existing_output, valid_i[i] |-> sel_i[i] < NumOut, clk_i, !rst_ni,
            ""Non-existing output is selected!"")
  end

  if (AxiVldRdy) begin : gen_handshake_assertions
    for (genvar i = 0; unsigned'(i) < NumInp; i++) begin : gen_inp_assertions
      `ASSERT(input_data_unstable, valid_i[i] && !ready_o[i] |=> $stable(data_i[i] & AxiVldMask),
              clk_i, !rst_ni, $sformatf(""data_i is unstable at input: %0d"", i))
      `ASSERT(input_sel_unstable, valid_i[i] && !ready_o[i] |=> $stable(sel_i[i]), clk_i, !rst_ni,
              $sformatf(""sel_i is unstable at input: %0d"", i))
      `ASSERT(input_valid_taken, valid_i[i] && !ready_o[i] |=> valid_i[i], clk_i, !rst_ni,
              $sformatf(""valid_i at input %0d has been taken away without a ready."", i))
    end
    for (genvar i = 0; unsigned'(i) < NumOut; i++) begin : gen_out_assertions
      `ASSERT(output_data_unstable, valid_o[i] && !ready_i[i] |=> $stable(data_o[i] & AxiVldMask),
              clk_i, !rst_ni,
              $sformatf(""data_o is unstable at output: %0d Check that parameter LockIn is set."", i))
      `ASSERT(output_idx_unstable, valid_o[i] && !ready_i[i] |=> $stable(idx_o[i]), clk_i, !rst_ni,
              $sformatf(""idx_o is unstable at output: %0d Check that parameter LockIn is set."", i))
      `ASSERT(output_valid_taken, valid_o[i] && !ready_i[i] |=> valid_o[i], clk_i, !rst_ni,
              $sformatf(""valid_o at output %0d has been taken away without a ready."", i))
    end
  end

  `ASSERT_INIT(numinp_0, NumInp > 32'd0, ""NumInp has to be > 0!"")
  `ASSERT_INIT(numout_0, NumOut > 32'd0, ""NumOut has to be > 0!"")
  `endif
endmodule
",stream_xbar.sv.txt,common_cells\stream_xbar.sv.txt
"[Keyword]: sub_per_hash.sv

[Design Category]: Combinational Logic

[Design Function Description]:
The module implements a fully parameterizable substitution-permutation hash function. It processes an input vector through multiple stages of bit shuffling and XOR operations to produce a hash output. The hash function is not cryptographically secure but generates a sequence of pseudo-random numbers to determine permutations and substitutions. The permutations are based on a variant of the Fisher-Yates shuffle algorithm, and the substitutions involve XORing pseudo-random bits from the shuffled vector.

[Input Signal Description]:
- `data_i [InpWidth-1:0]`: The input data vector to be hashed. The width of this vector is determined by the `InpWidth` parameter.

[Output Signal Description]:
- `hash_o [HashWidth-1:0]`: The hash output vector, which is the result of the substitution-permutation process. Its width is determined by the `HashWidth` parameter.
- `hash_onehot_o [2**HashWidth-1:0]`: A one-hot encoded version of the hash output, where only one bit is set to '1' corresponding to the hash value.


[Design Detail]:
// Copyright (c) 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Author: Wolfgang Roenninger <wroennin@ethz.ch>

// This module implements a fully parameterizable substitution-permutation hash
// function. The hash is structured in stages consisting of a shuffle of the input bits
// and then xoring for each bit 3 pseudo-random bits of the shuffeled vector.
// The hash function is NOT cryptographically secure!
// From the keys it computes a sequence of pseudo-random numbers, which determine the permutations
// and substitutions. As pseudo random generator a multiplicative linear congruential
// generator is used and uses different constants for the computation of the permutation
// and substitution respectively.
// The permutation shuffles the bits using a variant of the Fisher-Yates shuffle algorithm.
// The substitution per stage is the xor of 3 pseudo random bits of the previous stage.
// As shifting and xoring of a signal do not change its distribution, the distribution
// of the output hash is the same as the one of the input data.
//
// Parameters:
// - `InpWidth`:   The input width of the vector `data_i`.
// - `HashWidth`:  The output width of the substitution-permutation hash.
// - `NoRounds`:   The amount of permutation, substitution stages generated. Translates
//                 into how many levels of xor's there will be before optimization.
// - `PermuteKey`: The Key for the pseudo-random generator used for determining the exact
//                 permutation (shuffled wiring between each xor stage) at compile/elaboration.
//                 Any `int unsigned` value can be used as key, however one should examine the
//                 output of the hash function.
// - `XorKey`:     The Key for the pseudo-random generator used for determining the xor
//                 of bits between stages. The same principles as for `PermuteKey` applies,
//                 however one should look that both keys have a greatest common divisor of 1.

module sub_per_hash #(
  parameter int unsigned InpWidth   = 32'd11,
  parameter int unsigned HashWidth  = 32'd5,
  parameter int unsigned NoRounds   = 32'd1,
  parameter int unsigned PermuteKey = 32'd299034753,
  parameter int unsigned XorKey     = 32'd4094834
) (
  // is purely combinational
  input  logic [InpWidth-1:0]     data_i,
  output logic [HashWidth-1:0]    hash_o,
  output logic [2**HashWidth-1:0] hash_onehot_o
);

  // typedefs and respective localparams
  typedef int unsigned perm_lists_t [NoRounds][InpWidth];
  perm_lists_t Permutations;
  assign Permutations = get_permutations(PermuteKey);
  // encoding for inner most array:
  // position 0 indicates the number of inputs, 2 or 3
  // the other positions 1 - 3 indicate the inputs
  typedef int unsigned xor_stages_t [NoRounds][InpWidth][3];
  xor_stages_t XorStages;
  assign XorStages = get_xor_stages(XorKey);

  // stage signals
  logic [NoRounds-1:0][InpWidth-1:0] permuted, xored;

  // for each round
  for (genvar r = 0; r < NoRounds; r++) begin : gen_round
    // for each bit
    for (genvar i = 0; i < InpWidth ; i++) begin : gen_sub_per

      // assign the permutation
      if (r == 0) begin : gen_input
        assign permuted[r][i] = data_i[Permutations[r][i]];
      end else begin : gen_permutation
        assign permuted[r][i] = permuted[r-1][Permutations[r][i]];
      end

      // assign the xor substitution
      assign xored[r][i] = permuted[r][XorStages[r][i][0]] ^
                           permuted[r][XorStages[r][i][1]] ^
                           permuted[r][XorStages[r][i][2]];
    end
  end

  // output assignment, take the bottom bits of the last round
  assign hash_o = xored[NoRounds-1][HashWidth-1:0];
  // for onehot run trough a decoder
  assign hash_onehot_o = 1 << hash_o;

  // PRG is MLCG (multiplicative linear congruential generator)
  // Constant values the same as RtlUniform from Native API
  // X(n+1) = (a*X(n)+c) mod m
  // a: large prime
  // c: increment
  // m: range
  // Shuffling is a variation of the Fisher-Yates shuffle algorithm
  function automatic perm_lists_t get_permutations(input int unsigned seed);
    perm_lists_t indices;
    perm_lists_t perm_array;
    longint unsigned A = 2147483629;
    longint unsigned C = 2147483587;
    longint unsigned M = 2**31 - 1;
    longint unsigned index   = 0;
    longint unsigned advance = 0;
    longint unsigned rand_number = (A * seed + C) % M;

    // do it for each round
    for (int unsigned r = 0; r < NoRounds; r++) begin
      // initialize the index array
      for (int unsigned i = 0; i < InpWidth; i++) begin
        indices[r][i] = i;
      end
      // do the shuffling
      for (int unsigned i = 0; i < InpWidth; i++) begin
        // get the 'random' number
        if (i > 0) begin
          rand_number = (A * rand_number + C) % M;
          index = rand_number % i;
        end
        // do the shuffling
        if (i != index) begin
          perm_array[r][i]     = perm_array[r][index];
          perm_array[r][index] = indices[r][i];
        end
      end
      // advance the PRG a bit
      rand_number = (A * rand_number + C) % M;
      advance     = rand_number % NoRounds;
      for (int unsigned i = 0; i < advance; i++) begin
        rand_number = (A * rand_number + C) % M;
      end
    end
    return perm_array;
  endfunction : get_permutations

  // PRG is MLCG (multiplicative linear congruential generator)
  // Constant values the same as Numerical Recipes
  // X(n+1) = (a*X(n)+c) mod m
  // a: large prime
  // c: increment
  // m: range
  function automatic xor_stages_t get_xor_stages(input int unsigned seed);
    xor_stages_t xor_array;
    longint unsigned A = 1664525;
    longint unsigned C = 1013904223;
    longint unsigned M = 2**32;
    longint unsigned index   = 0;
    // int unsigned even    = 0;
    longint unsigned advance = 0;
    longint unsigned rand_number = (A * seed + C) % M;

    // fill the array with 'randon' inputs
    // for each xor, a even random number is two input, uneven is tree
    // for each round
    for (int unsigned r = 0; r < NoRounds; r++) begin
      // for each bit
      for (int unsigned i = 0; i < InpWidth; i++) begin
        rand_number = (A * rand_number + C) % M;
        // even = rand_number[3];
        for (int unsigned j = 0; j < 3; j++) begin
          rand_number = (A * rand_number + C) % M;
          index = rand_number % InpWidth;
          xor_array[r][i][j] = index;
        end
      end
      // advance the PRG a bit
      rand_number = (A * rand_number + C) % M;
      advance     = rand_number % NoRounds;
      for (int unsigned i = 0; i < advance; i++) begin
        rand_number = (A * rand_number + C) % M;
      end
    end
    return xor_array;
  endfunction : get_xor_stages
endmodule
",sub_per_hash.sv.txt,common_cells\sub_per_hash.sv.txt
"[Keyword]: sync.sv

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a multi-stage synchronizer used to safely transfer a serial input signal from one clock domain to another. It helps in mitigating metastability issues by passing the input signal through a series of flip-flops (stages) before producing a stable output.

[Input Signal Description]:
- `clk_i`: Clock input signal that drives the flip-flops in the synchronizer.
- `rst_ni`: Active-low reset signal used to initialize the synchronizer stages to a known state.
- `serial_i`: Serial input signal that is to be synchronized across clock domains.

[Output Signal Description]:
- `serial_o`: Synchronized output signal that is stable and safe to use in the destination clock domain.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module sync #(
    parameter int unsigned STAGES = 2,
    parameter bit ResetValue = 1'b0
) (
    input  logic clk_i,
    input  logic rst_ni,
    input  logic serial_i,
    output logic serial_o
);

   (* dont_touch = ""true"" *)
   (* async_reg = ""true"" *)
   logic [STAGES-1:0] reg_q;

    always_ff @(posedge clk_i, negedge rst_ni) begin
        if (!rst_ni) begin
            reg_q <= {STAGES{ResetValue}};
        end else begin
            reg_q <= {reg_q[STAGES-2:0], serial_i};
        end
    end

    assign serial_o = reg_q[STAGES-1];

endmodule
",sync.sv.txt,common_cells\sync.sv.txt
"[Keyword]: sync_wedge.sv

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a synchronizer with edge detection capabilities. It synchronizes an input signal across clock domains and detects rising and falling edges of the input signal. The module uses a parameterized number of synchronization stages and includes clock gating for power efficiency.

[Input Signal Description]:
- `clk_i`: Clock input signal used for synchronization.
- `rst_ni`: Active-low reset signal to initialize or reset the circuit.
- `en_i`: Enable signal to control the operation of the synchronizer.
- `serial_i`: Serial input signal that needs to be synchronized and monitored for edge detection.

[Output Signal Description]:
- `r_edge_o`: Output signal indicating a rising edge has been detected on the input signal.
- `f_edge_o`: Output signal indicating a falling edge has been detected on the input signal.
- `serial_o`: Synchronized output of the input signal after passing through the synchronization stages.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Antonio Pullini <pullinia@iis.ee.ethz.ch>

module sync_wedge #(
    parameter int unsigned STAGES = 2
) (
    input  logic clk_i,
    input  logic rst_ni,
    input  logic en_i,
    input  logic serial_i,
    output logic r_edge_o,
    output logic f_edge_o,
    output logic serial_o
);
    logic clk;
    logic serial, serial_q;

    assign serial_o =  serial_q;
    assign f_edge_o = (~serial) & serial_q;
    assign r_edge_o =  serial & (~serial_q);

    sync #(
        .STAGES (STAGES)
    ) i_sync (
        .clk_i,
        .rst_ni,
        .serial_i,
        .serial_o ( serial )
    );

    pulp_clock_gating i_pulp_clock_gating (
        .clk_i,
        .en_i,
        .test_en_i ( 1'b0 ),
        .clk_o     ( clk  )
    );

    always_ff @(posedge clk, negedge rst_ni) begin
        if (!rst_ni) begin
            serial_q <= 1'b0;
        end else begin
            if (en_i) begin
                serial_q <= serial;
            end
        end
    end
endmodule
",sync_wedge.sv.txt,common_cells\sync_wedge.sv.txt
"[Keyword]: unread.sv

[Design Category]: Interface Circuits

[Design Function Description]:
This is a dummy circuit designed to mitigate Open Pin warnings in synthesis tools like Vivado. It serves as a placeholder to prevent warnings about unused input pins by assigning them to a logic variable.

[Input Signal Description]:
d_i: A logic input signal that is intended to be connected to prevent open pin warnings.

[Output Signal Description]:
There is no output signal in this design. The purpose is to handle the input signal to avoid synthesis warnings.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the ""License""); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Florian Zaruba, ETH Zurich
// Date: 29.10.2018
// Description: Dummy circuit to mitigate Open Pin warnings

/* verilator lint_off UNUSED */
module unread (
    input logic d_i
);
    // Vivado treats this module as black box otherwise
`ifdef TARGET_VIVADO
    logic x;
    assign d_i = x;
`endif
endmodule
/* verilator lint_on UNUSED */
",unread.sv.txt,common_cells\unread.sv.txt
"[Keyword]: adjust

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a finite state machine (FSM) that processes a series of decimal digits and outputs the six most significant digits. It operates in three states: idle, operation (op), and done. The FSM shifts the digits to the right until the most significant digit is zero, then outputs the six most significant digits.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the FSM operations.
- `rst_n`: Active-low reset signal to initialize the FSM to the idle state.
- `start`: Signal to initiate the FSM operation.
- `dig0` to `dig10`: 4-bit input signals representing decimal digits to be processed.

[Output Signal Description]:
- `in0` to `in5`: 5-bit output signals representing the six most significant digits after processing.
- `done_tick`: A signal that indicates the FSM has completed its operation and is ready to output the results.


[Design Detail]:
`timescale 1ns / 1ps

module adjust( //outputs the siz most significant bit with corresponding decimal
	input clk,rst_n,
	input start,
	input[3:0] dig0,dig1,dig2,dig3,dig4,dig5,dig6,dig7,dig8,dig9,dig10,
	output[4:0] in0,in1,in2,in3,in4,in5, //6 most significant digits 
	output reg done_tick
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							 op=2'd1,
							 done=2'd2;
	 reg[1:0] state_reg,state_nxt;
	 reg[4:0] dig0_reg,dig1_reg,dig2_reg,dig3_reg,dig4_reg,dig5_reg,dig6_reg,dig7_reg,dig8_reg,dig9_reg,dig10_reg;
	 reg[4:0] dig0_nxt,dig1_nxt,dig2_nxt,dig3_nxt,dig4_nxt,dig5_nxt,dig6_nxt,dig7_nxt,dig8_nxt,dig9_nxt,dig10_nxt;
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			dig0_reg<=0;
			dig1_reg<=0;
			dig2_reg<=0;
			dig3_reg<=0;
			dig4_reg<=0;
			dig5_reg<=0;
			dig6_reg<=0;
			dig7_reg<=0;
			dig8_reg<=0;
			dig9_reg<=0;
			dig10_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			dig0_reg<=dig0_nxt;
			dig1_reg<=dig1_nxt;
			dig2_reg<=dig2_nxt;
			dig3_reg<=dig3_nxt;
			dig4_reg<=dig4_nxt;
			dig5_reg<=dig5_nxt;
			dig6_reg<=dig6_nxt;
			dig7_reg<=dig7_nxt;
			dig8_reg<=dig8_nxt;
			dig9_reg<=dig9_nxt;
			dig10_reg<=dig10_nxt;
		end
	 end
	 //FSM next-state declarations
	 always @* begin
		state_nxt=state_reg;
		dig0_nxt=dig0_reg;
		dig1_nxt=dig1_reg;
		dig2_nxt=dig2_reg;
		dig3_nxt=dig3_reg;
		dig4_nxt=dig4_reg;
		dig5_nxt=dig5_reg;
		dig6_nxt=dig6_reg;
		dig7_nxt=dig7_reg;
		dig8_nxt=dig8_reg;
		dig9_nxt=dig9_reg;
		dig10_nxt=dig10_reg;
		done_tick=0;
		case(state_reg) 
			   idle: if(start) begin
							dig0_nxt={1'b0,dig0};
							dig1_nxt={1'b0,dig1};
							dig2_nxt={1'b0,dig2};
							dig3_nxt={1'b0,dig3};
							dig4_nxt={1'b0,dig4};
							dig5_nxt={1'b1,dig5};//decimal digit before the last 5 digits
							dig6_nxt={1'b0,dig6};
							dig7_nxt={1'b0,dig7};
							dig8_nxt={1'b0,dig8};
							dig9_nxt={1'b0,dig9};
							dig10_nxt={1'b0,dig10};
							state_nxt=op;
						end
			     op: begin
							if(dig10_nxt==0) begin
								{dig0_nxt,dig1_nxt,dig2_nxt,dig3_nxt,dig4_nxt,dig5_nxt,dig6_nxt,dig7_nxt,dig8_nxt,dig9_nxt,dig10_nxt}=
									{dig0_nxt,dig1_nxt,dig2_nxt,dig3_nxt,dig4_nxt,dig5_nxt,dig6_nxt,dig7_nxt,dig8_nxt,dig9_nxt,dig10_nxt}>>5;
							end
							else state_nxt=done;
						end
			   done: begin
							done_tick=1;
							state_nxt=idle;
						end
			default: state_nxt=idle;
		endcase
		
	 end
	 assign in5=dig10_reg,
				in4=dig9_reg,
				in3=dig8_reg,
				in2=dig7_reg,
				in1=dig6_reg,
				in0=dig5_reg;
	 
	 


endmodule
",adjust.txt,FPGA_Book_Experiments\adjust.txt
"[Keyword]: alt_bcd_counter

[Design Category]: Sequential Logic

[Design Function Description]:  
This design is a Binary Coded Decimal (BCD) counter that counts in decimal digits. It uses three 4-bit registers to represent the decimal digits, allowing it to count from 000 to 999. The counter increments every time the `go` signal is high and the internal counter reaches 4,999,999, effectively creating a time delay based on the clock frequency.

[Input Signal Description]:  
- `clk`: Clock signal that drives the counter.
- `rst_n`: Active-low reset signal that initializes the counter to zero.
- `go`: Control signal that enables the counting process when high.

[Output Signal Description]:  
- `s1`: 4-bit register representing the hundreds digit of the BCD counter.
- `s0`: 4-bit register representing the tens digit of the BCD counter.
- `ms0`: 4-bit register representing the units digit of the BCD counter.


[Design Detail]:
`timescale 1ns / 1ps

module alt_bcd_counter(
	input clk,rst_n,
	input go,
	output reg[3:0] s1,s0,ms0
    );
	 reg[22:0] counter_reg=0;
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			s1<=0;
			s0<=0;
			ms0<=0;
			counter_reg<=0;
		end
		else if(go) begin //nested-if for describing the BCD-counter
			if(counter_reg!=4_999_999)	counter_reg<=counter_reg+1;
			else begin
				counter_reg<=0;
				if(ms0!=9) ms0<=ms0+1;
				else begin
					ms0<=0;
					if(s0!=9) s0<=s0+1;
					else begin
						s0<=0;
						if(s1!=9) s1<=s1+1;
						else s1<=0;
					end
				end
			end
		end
	 end


endmodule
",alt_bcd_counter.txt,FPGA_Book_Experiments\alt_bcd_counter.txt
"[Keyword]: ascii_conv

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit converts keyboard scan codes into their corresponding ASCII values. It takes a 9-bit input representing the scan code and outputs an 8-bit ASCII code. This is useful for interpreting keyboard inputs in digital systems.

[Input Signal Description]:
`rd_data[8:0]`: A 9-bit input signal representing the scan code from a keyboard. The first bit indicates whether the key is a special key (like a shift key), and the remaining 8 bits represent the scan code of the key pressed.

[Output Signal Description]:
`ascii[7:0]`: An 8-bit output signal that provides the ASCII representation of the input scan code. If the scan code does not match any predefined case, it defaults to the ASCII value for '*'.




[Design Detail]:
`timescale 1ns / 1ps

module ascii_conv( //converts the real data from kb module to ASCII
	input[8:0] rd_data,
	output reg[7:0] ascii
    );
 always @* begin
		ascii=0;
		case(rd_data)
			{1'b0,8'h45}: ascii = 8'h30; //0
			{1'b0,8'h16}: ascii = 8'h31; //1
			{1'b0,8'h1e}: ascii = 8'h32; //2
			{1'b0,8'h26}: ascii = 8'h33; //3
			{1'b0,8'h25}: ascii = 8'h34; //4
			{1'b0,8'h2e}: ascii = 8'h35; //5
			{1'b0,8'h36}: ascii = 8'h36; //6
			{1'b0,8'h3d}: ascii = 8'h37; //7
			{1'b0,8'h3e}: ascii = 8'h38; //8
			{1'b0,8'h46}: ascii = 8'h39; //9
			
			{1'b1,8'h1c}: ascii = 8'h41; //A
			{1'b1,8'h32}: ascii = 8'h42; //B
			{1'b1,8'h21}: ascii = 8'h43; //C
			{1'b1,8'h23}: ascii = 8'h44; //D
			{1'b1,8'h24}: ascii = 8'h45; //E
			{1'b1,8'h2b}: ascii = 8'h46; //F
			{1'b1,8'h34}: ascii = 8'h47; //G
			{1'b1,8'h33}: ascii = 8'h48; //H
			{1'b1,8'h43}: ascii = 8'h49; //I
			{1'b1,8'h3b}: ascii = 8'h4a; //J
			{1'b1,8'h42}: ascii = 8'h4b; //K
			{1'b1,8'h4b}: ascii = 8'h4c; //L
			{1'b1,8'h3a}: ascii = 8'h4d; //M
			{1'b1,8'h31}: ascii = 8'h4e; //N
			{1'b1,8'h44}: ascii = 8'h4f; //O
			{1'b1,8'h4d}: ascii = 8'h50; //P
			{1'b1,8'h15}: ascii = 8'h51; //Q
			{1'b1,8'h2d}: ascii = 8'h52; //R
			{1'b1,8'h1b}: ascii = 8'h53; //S
			{1'b1,8'h2c}: ascii = 8'h54; //T
			{1'b1,8'h3c}: ascii = 8'h55; //U
			{1'b1,8'h2a}: ascii = 8'h56; //V
			{1'b1,8'h1d}: ascii = 8'h57; //W
			{1'b1,8'h22}: ascii = 8'h58; //X
			{1'b1,8'h35}: ascii = 8'h59; //Y
			{1'b1,8'h1a}: ascii = 8'h5a; //Z
			
			{1'b0,8'h1c}: ascii = 8'h61; //a
			{1'b0,8'h32}: ascii = 8'h62; //b
			{1'b0,8'h21}: ascii = 8'h63; //c
			{1'b0,8'h23}: ascii = 8'h64; //d
			{1'b0,8'h24}: ascii = 8'h65; //e
			{1'b0,8'h2b}: ascii = 8'h66; //f
			{1'b0,8'h34}: ascii = 8'h67; //g
			{1'b0,8'h33}: ascii = 8'h68; //h
			{1'b0,8'h43}: ascii = 8'h69; //i
			{1'b0,8'h3b}: ascii = 8'h6a; //j
			{1'b0,8'h42}: ascii = 8'h6b; //k
			{1'b0,8'h4b}: ascii = 8'h6c; //l
			{1'b0,8'h3a}: ascii = 8'h6d; //m
			{1'b0,8'h31}: ascii = 8'h6e; //n
			{1'b0,8'h44}: ascii = 8'h6f; //o
			{1'b0,8'h4d}: ascii = 8'h70; //p
			{1'b0,8'h15}: ascii = 8'h71; //q
			{1'b0,8'h2d}: ascii = 8'h72; //r
			{1'b0,8'h1b}: ascii = 8'h73; //s
			{1'b0,8'h2c}: ascii = 8'h74; //t
			{1'b0,8'h3c}: ascii = 8'h75; //u
			{1'b0,8'h2a}: ascii = 8'h76; //v
			{1'b0,8'h1d}: ascii = 8'h77; //w
			{1'b0,8'h22}: ascii = 8'h78; //x
			{1'b0,8'h35}: ascii = 8'h79; //y
			{1'b0,8'h1a}: ascii = 8'h7a; //z
			
			
			{1'b0,8'h0e}: ascii = 8'h60; // `
			{1'b0,8'h4e}: ascii = 8'h2d; // - 
			{1'b0,8'h55}: ascii = 8'h3d; // =
			{1'b0,8'h54}: ascii = 8'h5b; // [
			{1'b0,8'h5b}: ascii = 8'h5d; // ]
			{1'b0,8'h5d}: ascii = 8'h5c; // \
			{1'b0,8'h4c}: ascii = 8'h3b; // ;
			{1'b0,8'h52}: ascii = 8'h27; // '
			{1'b0,8'h41}: ascii = 8'h2c; // ,
			{1'b0,8'h49}: ascii = 8'h2e; // .
			{1'b0,8'h4a}: ascii = 8'h2f; // /
			
			{1'b0,8'h29}: ascii = 8'h20; //space
			{1'b0,8'h5a}: ascii = 8'h0d; //enter
			{1'b0,8'h66}: ascii = 8'h08; //backspace
			default: ascii = 8'h2a; //*
			
		endcase
	 end

endmodule
",ascii_conv.txt,FPGA_Book_Experiments\ascii_conv.txt
"[Keyword]: autobaud_plus_autoparity

[Design Category]: Control Circuits

[Design Function Description]:
This design implements an autobaud and autoparity detection circuit. It automatically detects the baud rate and parity of incoming serial data. The circuit uses a finite state machine (FSM) to process the incoming data, measure the time between specific bits to determine the baud rate, and detect the parity of the data.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `key0`: Input signal used for triggering certain operations, debounced internally.
- `rx`: Serial data input for which the baud rate and parity are to be detected.
- `s_tick`: Tick signal used for timing operations within the FSM.

[Output Signal Description]:
- `baud_dvsr[11:0]`: Output representing the baud rate divisor, calculated as the measured ticks divided by 128.
- `baud_rate[17:0]`: Output representing the calculated baud rate.
- `done_tick`: Signal indicating the completion of the baud rate and parity detection process.
- `paritybit[1:0]`: Output indicating the detected parity type (even, odd, or no parity).


[Design Detail]:
`timescale 1ns / 1ps

	module autobaud_plus_autoparity(
	input clk,rst_n,
	input key0,rx,s_tick,
	output[11:0] baud_dvsr,
	output[17:0] baud_rate,
	output reg done_tick,
	output reg[1:0] paritybit
    );
	 
	 //FSM state declarations
	 localparam[2:0]  idle=3'd0,
							zero=3'd1,
							one=3'd2,
							findparity=3'd3,
							secondbyte=3'd4,
							divide=3'd5,
							start=3'd6;
							
							
	 reg[2:0] state_reg,state_nxt;
	 reg[18:0] counter_reg,counter_nxt;
	 reg[18:0] baud_reg,baud_nxt;
	 reg[1:0] index_reg,index_nxt;
	 reg[5:0] s_reg,s_nxt;
	 reg parity0_reg,parity0_nxt,parity1_reg,parity1_nxt;
	 wire key0_tick;
	 reg start_div;
	 wire done_div;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			counter_reg<=0;
			baud_reg<=0;
			index_reg<=0;
			s_reg<=0;
			parity0_reg<=0;
			parity1_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			counter_reg<=counter_nxt;
			baud_reg<=baud_nxt;
			index_reg<=index_nxt;
			s_reg<=s_nxt;
			parity0_reg<=parity0_nxt;
			parity1_reg<=parity1_nxt;
		end
	 end
	 
	 //FSM next-state logic
	 always @* begin
		state_nxt=state_reg;
		counter_nxt=counter_reg;
		baud_nxt=baud_reg;
		index_nxt=index_reg;
		s_nxt=s_reg;
		parity0_nxt=parity0_reg;
		parity1_nxt=parity1_reg;
		
		done_tick=0;
		start_div=0;
		case(state_reg) 
			   idle: if(rx==0) begin //wait for start bit of 0 for ASCII code of ""x""
							counter_nxt=0;
							baud_nxt=0;
							index_nxt=0;
							state_nxt=zero;
						end
			   zero: begin //wait for bit 1 of ASCII code of x = 0001_1110
							counter_nxt=counter_reg+1;
							if(rx==1) state_nxt=one;
						end
			    one: begin //wait for bit 0 to come
							counter_nxt=counter_reg+1;
							if(rx==0) begin
								state_nxt=findparity;
								baud_nxt=counter_reg;
								s_nxt=0;
							end
						end
		findparity: if(s_tick==1) begin //ASCII code is x = 0_0001_1110_p  , 23 ticks from last bit ""1"" means
							if(s_reg==23) begin			//skipping to the middle bit of parity bit(or stopbit if no parity bit)
								s_nxt=24;
								if(index_reg==0) begin 
									parity0_nxt=rx;  //paritybit for ""x"" is now recorded at this point
									index_nxt=1;
								end
								else begin
									parity1_nxt=rx;  //paritybit for ""p"" (which is the second byte)is now recorded at this point
									index_nxt=2;
								end
							end
							else if(s_reg==24) begin
								if(index_reg==2) begin
									start_div=1;
									state_nxt=divide;
								end
								else if(rx==1) state_nxt=secondbyte;
							end
							else s_nxt=s_reg+1;
						end
		secondbyte: if(rx==0) begin //secondbyte to be tested is ASCII of ""p""
							counter_nxt=0;
							baud_nxt=0;
							state_nxt=zero;
						end
			 divide: if(done_div==1) begin //use division circuit to find baud rate
							state_nxt=start;
							done_tick=1;
						end
			  start: if(key0_tick==1) state_nxt=idle;
			default: state_nxt=idle;
		endcase
	 end
	 //Computation: Baud_rate=50Mhz*8/x  (note: x is the measured ticks for the 8 bits [start bit(0) to last bit of ""1""(7th data bit)]
	 //Baud_dvsr=50MHz*1/(16*Baud_rate)= .... = x/128
	 //division operator is wasteful for fpga resources so we will only use shifting(divide by 2) --> 1/128 = 1/2^7
	 assign baud_dvsr= baud_reg>>7;
	 
	 //determine the paritybit through the sampled data bits of ""x"" and ""p""
	 always @* begin //note: this is an unorthodox way of finding the parity bit BUT IT WORKS
		case({parity0_reg,parity1_reg})
		2'b01: paritybit=2; //even
		2'b10: paritybit=1; //odd
		2'b11: paritybit=0; //no parity
		default: paritybit=0;
		endcase
	 end 

	 
	 //debounce module for key0
	debounce_explicit m0
	(
	.clk(clk),
	.rst_n(rst_n),
	.sw({!key0}),
	.db_level(),
	.db_tick(key0_tick)
    );
	 
	 div #(.W(22),.N(5)) m1
	(
		.clk(clk),
		.rst_n(rst_n),
		.start(start_div),
		.dividend(3_125_000), //baud_rate=50MHz*1/(16*baud_dvsr)=3_125_000/baud_dvsr
		.divisor({10'd0,baud_dvsr}),
		.quotient(baud_rate),
		.remainder(),
		.ready(),
		.done_tick(done_div)
	);


endmodule
",autobaud_plus_autoparity.txt,FPGA_Book_Experiments\autobaud_plus_autoparity.txt
"[Keyword]: babbage_diff

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) to compute values of a 3rd-order polynomial function, known as the Babbage difference engine. The circuit calculates the polynomial values iteratively based on the input value `i`, which represents the number of iterations or the degree of the polynomial to be computed.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and operations.
- `rst_n`: Active-low reset signal to initialize the FSM and registers.
- `start`: Signal to initiate the computation process.
- `i[5:0]`: 6-bit input representing the number of iterations or the degree of the polynomial to be computed.

[Output Signal Description]:
- `ans[17:0]`: 18-bit output representing the computed value of the polynomial after `i` iterations.
- `ready`: Signal indicating that the FSM is ready to start a new computation.
- `done_tick`: Signal indicating that the computation is complete and the result is available.


[Design Detail]:
`timescale 1ns / 1ps

module babbage_diff(
	input clk,rst_n,
	input start,
	input[5:0] i, //6 bit value f ""n""	
	output[17:0] ans,
	output reg ready,done_tick
    );
	 //babbage function values(3-order polynomial)
	 localparam f0=1,
					g1=5,
					h2=10,
					c=6;
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							op=2'd1,
							done=2'd2;
	 reg[1:0] state_reg,state_nxt;
	 reg[17:0] f_reg,f_nxt;
	 reg[17:0] g_reg,g_nxt;
	 reg[17:0] h_reg,h_nxt;
	 reg[5:0] n_reg,n_nxt;
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
			state_reg<=idle;
			f_reg<=0;
			g_reg<=0;
			h_reg<=0;
			n_reg<=0;		
		 end
		 else begin
			state_reg<=state_nxt;
			f_reg<=f_nxt;
			g_reg<=g_nxt;
			h_reg<=h_nxt;
			n_reg<=n_nxt;	
		 end	 
	 end
	 //FSM next-state logics
	 always @* begin
		state_nxt=state_reg;
		f_nxt=f_reg;
		g_nxt=g_reg;
		h_nxt=h_reg;
		n_nxt=n_reg;
		ready=0;
		done_tick=0;
		case(state_reg)
			  idle: begin
							ready=1;
							if(start==1) begin
								f_nxt=f0;
								g_nxt=0;
								h_nxt=0;
								n_nxt=0;
								state_nxt=op;
							end
					  end
			    op: begin
							if(n_reg==i) state_nxt=done;
							else begin
								n_nxt=n_reg+1;
								case(n_nxt)
									1: begin
											g_nxt=g1;
											f_nxt=g_nxt+f_reg;
										 end
									2: begin
											h_nxt=h2;
											g_nxt=h_nxt+g_reg;
											f_nxt=g_nxt+f_reg;
										end
									default: begin
											h_nxt=c+h_reg;
											g_nxt=h_nxt+g_reg;
											f_nxt=g_nxt+f_reg;
									end
								endcase
							end
					  end
			  done: begin
							done_tick=1;
							state_nxt=idle;
					  end
			default: state_nxt=idle;
		endcase
	 end
	 assign ans=f_reg;


endmodule
",babbage_diff.txt,FPGA_Book_Experiments\babbage_diff.txt
"[Keyword]: ball_in_a_box

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a graphical display of a ball bouncing within a defined box on a screen. The ball's speed and position can be controlled using input keys. The circuit handles the display logic for the ball and the walls of the box, changing colors upon collision and allowing the ball to bounce off the walls.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the circuit operations.
- `rst_n`: Active-low reset signal to initialize or reset the circuit.
- `video_on`: Signal indicating whether the video display is active.
- `key[1:0]`: 2-bit input for controlling the ball; `key[1]` changes the ball's speed, and `key[0]` changes the ball's location.
- `pixel_x[11:0]`: 12-bit horizontal pixel coordinate for the display.
- `pixel_y[11:0]`: 12-bit vertical pixel coordinate for the display.

[Output Signal Description]:
- `r[4:0]`: 5-bit red color component for the display output.
- `g[5:0]`: 6-bit green color component for the display output.
- `b[4:0]`: 5-bit blue color component for the display output.


[Design Detail]:
`timescale 1ns / 1ps


module ball_in_a_box
	(
		input clk,rst_n,
		input video_on,
		input[1:0] key, //key[1] for changing  ball speed, key[0] to change location of ball
		input[11:0] pixel_x,pixel_y,
		output reg[4:0] r,
		output reg[5:0] g,
		output reg[4:0] b
    );				
				//SCREEN BOUNDARIES FOR A 256x256 BOX
	 
						//LEFT WALL
	 localparam LWALL_XL=187, //left
					LWALL_XR=192, //right
					LWALL_YT=107, //top
					LWALL_YB=373, //bottom
					
						//RIGHT WALL
					RWALL_XL=447, //left
					RWALL_XR=452, //right
					RWALL_YT=107, //top
					RWALL_YB=372, //bottom
						
						//TOP WALL
					TWALL_XL=187, //left
					TWALL_XR=452, //right
					TWALL_YT=107, //top
					TWALL_YB=112, //bottom
						
						//BOTTOM WALL
					BWALL_XL=187, //left
					BWALL_XR=452, //right
					BWALL_YT=367, //top
					BWALL_YB=372, //bottom
					
					
					
					ball_DIAM=7; //ball diameter minus one


	 reg[4:0] ball_V[3:0]; //stores current speed of ball
	 reg[1:0] ball_v_q=0,ball_v_d; //address for ball_V
	 
	 initial begin //list of available ball speeds
		ball_V[0]=5'd1;
		ball_V[1]=5'd5;
		ball_V[2]=5'd10;
		ball_V[3]=5'd20;
	 end
	
					
	 wire lwall_on,r_wall_on,twall_on,bwall_on,ball_box;
	 wire key0_tick,key1_tick;
	
	 reg[2:0] lwall_q,lwall_d,rwall_q,rwall_d,twall_q,twall_d,bwall_q,bwall_d; //stores color of walls
	 reg ball_on;
	 reg[2:0] rom_addr; //rom for circular pattern of ball
	 reg[7:0] rom_data;
	 reg[9:0] ball_x_q=280,ball_x_d; //stores left X value of the bouncing ball
	 reg[9:0] ball_y_q=200,ball_y_d; //stores upper Y value of the bouncing ball
	 reg ball_xdelta_q=0,ball_xdelta_d;
	 reg ball_ydelta_q=0,ball_ydelta_d;
	 
	 //display conditions for the four walls
	 assign lwall_on= LWALL_XL<=pixel_x && pixel_x<=LWALL_XR && LWALL_YT<=pixel_y && pixel_y<=LWALL_YB;
	 assign rwall_on= RWALL_XL<=pixel_x && pixel_x<=RWALL_XR && RWALL_YT<=pixel_y && pixel_y<=RWALL_YB;
	 assign twall_on= TWALL_XL<=pixel_x && pixel_x<TWALL_XR && TWALL_YT<=pixel_y && pixel_y<=TWALL_YB;
	 assign bwall_on= BWALL_XL<=pixel_x && pixel_x<BWALL_XR && BWALL_YT<=pixel_y && pixel_y<=BWALL_YB;

	
	 assign ball_box= ball_x_q<=pixel_x && pixel_x<=(ball_x_q+ball_DIAM) &&  ball_y_q<=pixel_y && pixel_y<=(ball_y_q+ball_DIAM);

	 //circular ball_on logic
	 always @* begin
		rom_addr=0;
		ball_on=0;
		if(ball_box) begin
			rom_addr=pixel_y-ball_y_q;
			if(rom_data[pixel_x-ball_x_q]) ball_on=1;
		end
	 end
	 
	 //ball rom pattern
	 always @* begin
		 case(rom_addr)
			3'd0: rom_data=8'b0001_1000;
			3'd1: rom_data=8'b0011_1100;
			3'd2: rom_data=8'b0111_1110;
			3'd3: rom_data=8'b1111_1111;
			3'd4: rom_data=8'b1111_1111;
			3'd5: rom_data=8'b0111_1110;
			3'd6: rom_data=8'b0011_1100;
			3'd7: rom_data=8'b0001_1000;
		 endcase
	 end
	 
	 
	 //logic for self-bouncing ball
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin 
				//initial is center of screen
			ball_x_q<=320;
			ball_y_q<=240;
			ball_xdelta_q<=0;
			ball_xdelta_q<=0;
			lwall_q<=0;
			rwall_q<=0;
			twall_q<=0;
			bwall_q<=0;
			ball_v_q<=0;
		end
		else begin
			ball_x_q<=ball_x_d;
			ball_y_q<=ball_y_d;
			ball_xdelta_q<=ball_xdelta_d;
			ball_ydelta_q<=ball_ydelta_d;
			lwall_q<=lwall_d;
			rwall_q<=rwall_d;
			twall_q<=twall_d;
			bwall_q<=bwall_d;
			ball_v_q<=ball_v_d;
		end
	 end
	 
	 always @* begin
		ball_x_d=ball_x_q;
		ball_y_d=ball_y_q;
		ball_xdelta_d=ball_xdelta_q;
		ball_ydelta_d=ball_ydelta_q;
		lwall_d=lwall_q;
		rwall_d=rwall_q;
		twall_d=twall_q;
		bwall_d=bwall_q;
		ball_v_d=ball_v_q;
		
			if(key0_tick) begin //change ball location based on current scan location
				ball_x_d=pixel_x;
				ball_y_d=pixel_y;
			end
			
	
			else if(pixel_y==500 && pixel_x==0) begin//1 tick when video is surely off
			
				lwall_d=3'b010; //default wall color is green
				rwall_d=3'b010;
				twall_d=3'b010;
				bwall_d=3'b010;
				
				//bouncing ball logic
				if(ball_x_q<=LWALL_XR) begin //bounce from left wall
					ball_xdelta_d=1; 
					lwall_d=3'b100;
				end
				else if(RWALL_XL<=ball_x_q+ball_DIAM) begin  //bounce from right wall
					ball_xdelta_d=0;
					rwall_d=3'b001;
				end
				if(ball_y_q<=TWALL_YB) begin
					ball_ydelta_d=1; //bounce from top wall
					twall_d=3'b110;
				end
				else if(BWALL_YT<=ball_y_q+ball_DIAM) begin
					ball_ydelta_d=0; //bounce from bottom wall
					bwall_d=3'b011;
				end
				
				ball_x_d=ball_xdelta_d? (ball_x_q+ball_V[ball_v_q]):(ball_x_q-ball_V[ball_v_q]);
				ball_y_d=ball_ydelta_d? (ball_y_q+ball_V[ball_v_q]):(ball_y_q-ball_V[ball_v_q]);
			end
			
			if(key1_tick) ball_v_d=ball_v_q+1; //change ball speed
	 end
	 
	 
	 //overall display logic
	always @* begin
	 	r=0;
		g=0;
		b=0;
		if(video_on) begin
			if(ball_on) b={5{1'b1}}; //ball color 
			
			else if(rwall_on) begin  //right wall color
				r={5{rwall_q[2]}};
				g={6{rwall_q[1]}};
				b={5{rwall_q[0]}};
			end
			else if(lwall_on) begin   //left wall color
				r={5{lwall_q[2]}};
				g={6{lwall_q[1]}};
				b={5{lwall_q[0]}};
			end
			else if(twall_on) begin //top wall color
				r={5{twall_q[2]}};
				g={6{twall_q[1]}};
				b={5{twall_q[0]}};
			end
			else if(bwall_on) begin //bottom wall color
				r={5{bwall_q[2]}};
				g={6{bwall_q[1]}};
				b={5{bwall_q[0]}};
			end
			else if(LWALL_XR<=pixel_x && pixel_x<=RWALL_XL && TWALL_YB<=pixel_y && pixel_y<=BWALL_YT) begin //color inside box
				//r={5{1'b1}};
				g={6{1'b1}};
				b={5{1'b1}};
			end
			else begin //color outside box
				r={5{1'b1}};
				g={6{1'b1}};
				b={5{1'b1}};
			end
		end
	 end
	 
	 debounce_explicit
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[0]),
		.db_level(),
		.db_tick(key0_tick)
    );
	 debounce_explicit
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[1]),
		.db_level(),
		.db_tick(key1_tick)
    );
					
endmodule


",ball_in_a_box.txt,FPGA_Book_Experiments\ball_in_a_box.txt
"[Keyword]: baud_generator

[Design Category]: Sequential Logic

[Design Function Description]: 
The circuit is a baud rate generator, which is used to generate a periodic tick signal (`s_tick`) at a specific frequency. This is typically used in serial communication to synchronize data transmission and reception by providing a clock signal at the desired baud rate.

[Input Signal Description]: 
- `clk`: The clock input signal that drives the sequential logic.
- `rst_n`: An active-low reset signal that initializes the counter to zero when asserted.

[Output Signal Description]: 
- `s_tick`: A periodic output signal that goes high for one clock cycle every N clock cycles, where N is a parameter that determines the frequency of the tick signal.














[Design Detail]:
`timescale 1ns / 1ps

module baud_generator#(parameter N=163,N_width=8)
	(
	input clk,rst_n,
	output reg s_tick
    );
	 reg[N_width-1:0] counter=0;
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) counter<=0;
		else begin
			s_tick=0;
			if(counter==N-1) begin
				s_tick=1;
				counter<=0;
			end
			else begin
				counter<=counter+1;
			end
			
		end
	 end
	 
endmodule
",baud_generator.txt,FPGA_Book_Experiments\baud_generator.txt
"[Keyword]: bcd2bin

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a finite state machine (FSM) that converts a 2-digit Binary Coded Decimal (BCD) input into a binary number. It processes the BCD digits through a series of state transitions to produce a binary equivalent.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the state transitions.
- `rst_n`: Active-low reset signal to initialize the FSM.
- `start`: Signal to initiate the conversion process.
- `dig1`: 4-bit input representing the tens digit of the BCD number.
- `dig0`: 4-bit input representing the units digit of the BCD number.

[Output Signal Description]:
- `bin`: 7-bit output representing the binary equivalent of the BCD input.
- `ready`: Signal indicating the FSM is ready to start a new conversion.
- `done_tick`: Signal indicating the conversion process is complete.



[Design Detail]:
`timescale 1ns / 1ps

module bcd2bin(
	input clk,rst_n,
	input start,
	input[3:0] dig1,dig0,
	output reg[6:0] bin, //2-digit number takes at most 7 bits
	output reg ready,done_tick
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							op=2'd1,
							done=2'd2;
	 reg[1:0] state_reg,state_nxt;
	 reg[6:0] bin_nxt;
	 reg[3:0] dig1_reg,dig1_nxt;
	 reg[3:0] dig0_reg,dig0_nxt;
	 reg[2:0] n_reg,n_nxt; //stores the width of the resulting binary
	 
	 //FSM register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			bin<=0;
			dig1_reg<=0;
			dig0_reg<=0;
			n_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			bin<=bin_nxt;
			dig1_reg<=dig1_nxt;
			dig0_reg<=dig0_nxt;
			n_reg<=n_nxt;
		end
	 end
	 //FSM next-state logic
	 always @* begin
		state_nxt=state_reg;
		bin_nxt=bin;
		dig1_nxt=dig1_reg;
		dig0_nxt=dig0_reg;
		n_nxt=n_reg;
		ready=0;
		done_tick=0;
		case(state_reg)
				idle: begin
							ready=1;
							if(start) begin
								bin_nxt=0;
								dig1_nxt=dig1;
								dig0_nxt=dig0;
								n_nxt=7; //binary has 7 bits of output thus 7 ""shifts"" are needed
								state_nxt=op;
							end
						end
				  op: begin //special shift-operation for converting bcd to bin.Check the book for more info
							if( {dig1_reg[0],dig0_reg[3:1]} >= 8 ) ///special shift-operation for converting bcd to bin.Check the book for more info
								dig0_nxt= {dig1_reg[0],dig0_reg[3:1]} - 3;
							else dig0_nxt= {dig1_reg[0],dig0_reg[3:1]};
							dig1_nxt=dig1_reg>>1;
							bin_nxt={dig0_reg[0],bin[6:1]};
							n_nxt=n_reg-1;
							if(n_nxt==0) state_nxt=done;
						end
				done: begin
							done_tick=1;
							state_nxt=idle;
						end
			default: state_nxt=idle;
		endcase
	 end
	 


endmodule
",bcd2bin.txt,FPGA_Book_Experiments\bcd2bin.txt
"[Keyword]: bcd_counter

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a Binary Coded Decimal (BCD) counter that counts from 00 to 49. It uses a two-digit BCD format, where each digit is represented by a 4-bit binary number. The counter increments on the rising edge of a debounced switch signal and resets when the reset signal is active low.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the counter operations.
- `rst_n`: Active-low reset signal. When low, it resets the counter to 00.
- `sw`: Active-low switch input. It is debounced and used to trigger the counting operation.

[Output Signal Description]:
- `dig1`: 4-bit output representing the tens digit of the BCD counter.
- `dig0`: 4-bit output representing the units digit of the BCD counter.
- `done_tick`: Signal that goes high for one clock cycle when the counter increments.


[Design Detail]:
`timescale 1ns / 1ps

module bcd_counter(
	input clk,rst_n,
	input sw, //active-low
	output reg[3:0] dig1,dig0,
	output reg done_tick
    );
	 localparam idle=0,done=1;
	 reg state_reg,state_nxt;
	initial begin
		dig1=0;
		dig0=0;
	end
	 reg[3:0] dig1_nxt,dig0_nxt;
	 wire r_edg,sw_hi; //sw_hi:debounce module only use active high input so reverse the ""sw"" first
	 
	 assign sw_hi=!sw;
	 //debounce circuit
	debounce_explicit deb(
	.clk(clk),
	.rst_n(rst_n),
	.sw(sw_hi),
	.db_tick(r_edg)	
    );
	 
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=0;
			dig1<=0;
			dig0<=0;
		end
		else begin
			state_reg<=state_nxt;
			dig1<=dig1_nxt;
			dig0<=dig0_nxt;
		end
		
	end
	always @* begin
		state_nxt=state_reg;
		dig1_nxt=dig1;
		dig0_nxt=dig0;
		done_tick=0;
		case(state_reg)
			idle: if(r_edg) begin
						if(dig0!=9) dig0_nxt=dig0+1;
						else begin
							dig0_nxt=0;
							if(dig1!=4) dig1_nxt=dig1+1;
							else dig1_nxt=0;
						end	
						state_nxt=done;
					end
			done: begin
						done_tick=1;
						state_nxt=idle;
					end
		default: state_nxt=idle;
		endcase
	end


endmodule
",bcd_counter.txt,FPGA_Book_Experiments\bcd_counter.txt
"[Keyword]: bin2bcd

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a binary to BCD (Binary-Coded Decimal) converter. It takes a 37-bit binary input and converts it into a series of BCD digits. The module uses a finite state machine (FSM) to manage the conversion process, which involves shifting and adjusting the BCD digits until the conversion is complete.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the FSM.
- `rst_n`: Active-low reset signal to initialize the FSM and registers.
- `start`: Signal to initiate the conversion process.
- `bin[36:0]`: 37-bit binary input representing the number to be converted to BCD.

[Output Signal Description]:
- `ready`: Signal indicating the module is ready to start a new conversion.
- `done_tick`: Signal indicating the conversion process is complete.
- `dig0` to `dig10`: 4-bit outputs representing the BCD digits of the converted binary number. Not all outputs may be used, as this is a general-purpose converter.






[Design Detail]:
`timescale 1ns / 1ps

module bin2bcd(
	input clk,rst_n,
	input start,
	input[36:0] bin,//11 digit max of {11{9}}
	output reg ready,done_tick,
	output[3:0] dig0,dig1,dig2,dig3,dig4,dig5,dig6,dig7,dig8,dig9,dig10 //not all output will be used(this module is a general-purpose bin2bcd)
    );
	 //FSM declarations
	 localparam[1:0] idle=2'd0,
							op=2'd1,
							done=2'd2;
	 localparam N=37; //width of binary
	
	 reg[1:0] state_reg,state_nxt;
	 reg[36:0] bin_reg,bin_nxt; 
	 reg[3:0] dig0_reg,dig1_reg,dig2_reg,dig3_reg,dig4_reg,dig5_reg,dig6_reg,dig7_reg,dig8_reg,dig9_reg,dig10_reg;
	 reg[3:0] dig0_nxt,dig1_nxt,dig2_nxt,dig3_nxt,dig4_nxt,dig5_nxt,dig6_nxt,dig7_nxt,dig8_nxt,dig9_nxt,dig10_nxt;
	 reg[5:0] n_reg,n_nxt; //will store value of ""N""
	 
	 //FSM reguster operations
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
			state_reg<=idle;
			bin_reg<=0;
			dig0_reg<=0;
			dig1_reg<=0;
			dig2_reg<=0;
			dig3_reg<=0; 
			dig4_reg<=0; 
			dig5_reg<=0; 
			dig6_reg<=0; 
			dig7_reg<=0; 
			dig8_reg<=0; 
			dig9_reg<=0; 
			dig10_reg<=0; 
			n_reg<=0;
		 end
		 else begin
			state_reg<=state_nxt;
			bin_reg<=bin_nxt;
			dig0_reg<=dig0_nxt;
			dig1_reg<=dig1_nxt;
			dig2_reg<=dig2_nxt;
			dig3_reg<=dig3_nxt;
			dig4_reg<=dig4_nxt;
			dig5_reg<=dig5_nxt;
			dig6_reg<=dig6_nxt;
			dig7_reg<=dig7_nxt;
			dig8_reg<=dig8_nxt;
			dig9_reg<=dig9_nxt;
			dig10_reg<=dig10_nxt;
			n_reg<=n_nxt;
		 end		 
	 end
	 //FSM next-state logics
	 always @* begin
		state_nxt=state_reg;
		bin_nxt=bin_reg;
		dig0_nxt=dig0_reg;
		dig1_nxt=dig1_reg;
		dig2_nxt=dig2_reg;
		dig3_nxt=dig3_reg;
		dig4_nxt=dig4_reg;
		dig5_nxt=dig5_reg;
		dig6_nxt=dig6_reg;
		dig7_nxt=dig7_reg;
		dig8_nxt=dig8_reg;
		dig9_nxt=dig9_reg;
		dig10_nxt=dig10_reg;
		n_nxt=n_reg;
		done_tick=0;
		ready=0;
			case(state_reg) 
				idle: begin
							ready=1;
							if(start) begin
								bin_nxt=bin;
								dig0_nxt=0;
								dig1_nxt=0;
								dig2_nxt=0;
								dig3_nxt=0;
								dig4_nxt=0;
								dig5_nxt=0;
								dig6_nxt=0;
								dig7_nxt=0;
								dig8_nxt=0;
								dig9_nxt=0;
								dig10_nxt=0;
								n_nxt=N;
								state_nxt=op;
							end
						end
				  op: begin
							dig0_nxt=(dig0_reg<=4)?dig0_reg:dig0_reg+4'd3;
							dig1_nxt=(dig1_reg<=4)?dig1_reg:dig1_reg+4'd3;
							dig2_nxt=(dig2_reg<=4)?dig2_reg:dig2_reg+4'd3;
							dig3_nxt=(dig3_reg<=4)?dig3_reg:dig3_reg+4'd3;
							dig4_nxt=(dig4_reg<=4)?dig4_reg:dig4_reg+4'd3;
							dig5_nxt=(dig5_reg<=4)?dig5_reg:dig5_reg+4'd3;
							dig6_nxt=(dig6_reg<=4)?dig6_reg:dig6_reg+4'd3;
							dig7_nxt=(dig7_reg<=4)?dig7_reg:dig7_reg+4'd3;
							dig8_nxt=(dig8_reg<=4)?dig8_reg:dig8_reg+4'd3;
							dig9_nxt=(dig9_reg<=4)?dig9_reg:dig9_reg+4'd3;
						   dig10_nxt=(dig10_reg<=4)?dig10_reg:dig10_reg+4'd3;
							
							{dig10_nxt,dig9_nxt,dig8_nxt,dig7_nxt,dig6_nxt,dig5_nxt,dig4_nxt,dig3_nxt,dig2_nxt,dig1_nxt,dig0_nxt,bin_nxt}
								={dig10_nxt,dig9_nxt,dig8_nxt,dig7_nxt,dig6_nxt,dig5_nxt,dig4_nxt,dig3_nxt,dig2_nxt,dig1_nxt,dig0_nxt,bin_nxt}<<1; //shift left by 1(just copy the left side to right side)
							n_nxt=n_reg-1;
							if(n_nxt==0) state_nxt=done;			
						end
				done: begin
							done_tick=1;
							state_nxt=idle;
						end
			default: state_nxt=idle;						
			endcase	
	 end
	 assign  dig0=dig0_reg,
				dig1=dig1_reg,
				dig2=dig2_reg,
				dig3=dig3_reg,
				dig4=dig4_reg,
				dig5=dig5_reg,
				dig6=dig6_reg,
				dig7=dig7_reg,
				dig8=dig8_reg,
				dig9=dig9_reg,
				dig10=dig10_reg;	 


endmodule
",bin2bcd.txt,FPGA_Book_Experiments\bin2bcd.txt
"[Keyword]: binary_decoder_2x4

[Design Category]: Combinational Logic

[Design Function Description]:  
The circuit is a 2-to-4 binary decoder. It takes a 2-bit binary input and decodes it into a 4-bit output, where only one of the output bits is set to '1' based on the input combination, provided the enable signal is active.

[Input Signal Description]:  
- `en`: Enable signal. The decoder is active and produces an output only when this signal is high.
- `a[1:0]`: 2-bit input signal that determines which one of the 4 output lines will be activated.

[Output Signal Description]:  
- `bcode[3:0]`: 4-bit output signal where only one bit is set to '1' based on the input `a` when the enable signal `en` is high. Each bit corresponds to one of the possible combinations of the input `a`.


[Design Detail]:
`timescale 1ns / 1ps

module binary_decoder_2x4(
	input en,
	input[1:0] a,
	output[3:0] bcode
    );
	 assign bcode[0]= en && !a[1] && !a[0],
				bcode[1]= en && !a[1] && a[0],
				bcode[2]= en && a[1] && !a[0],
				bcode[3]= en && a[1] && a[0]; 


endmodule
",binary_decoder_2x4.txt,FPGA_Book_Experiments\binary_decoder_2x4.txt
"[Keyword]: binary_decoder_3x8

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is a 3-to-8 binary decoder. It takes a 3-bit binary input and decodes it into an 8-bit output, where only one of the output bits is set to '1' based on the input value, and the rest are '0'. This is achieved by using two 2-to-4 decoders, with the most significant bit of the input used to enable one of the two decoders.

[Input Signal Description]:
a[2:0]: A 3-bit input signal that represents a binary number from 0 to 7. This input is used to determine which one of the 8 output lines will be activated.

[Output Signal Description]:
bcode[7:0]: An 8-bit output signal where only one bit is set to '1' based on the input value, and the rest are '0'. This represents the decoded output of the 3-to-8 decoder.


[Design Detail]:
`timescale 1ns / 1ps

module binary_decoder_3x8(
	input[2:0] a,
	output[7:0] bcode
    );
	 
	 binary_decoder_2x4 m0
	 (
		 .en({!a[2]}),
		 .a(a[1:0]),
		 .bcode(bcode[3:0])
    );
	 
	 binary_decoder_2x4 m1
	 (
		 .en(a[2]),
		 .a(a[1:0]),
		 .bcode(bcode[7:4])
    );


endmodule
",binary_decoder_3x8.txt,FPGA_Book_Experiments\binary_decoder_3x8.txt
"[Keyword]: binary_decoder_4x16

[Design Category]: Combinational Logic

[Design Function Description]:
The design is a 4-to-16 binary decoder. It takes a 4-bit input and decodes it into a 16-bit output, where only one of the 16 output bits is set to '1' based on the binary value of the input, and the rest are set to '0'.

[Input Signal Description]:
a[3:0]: A 4-bit input signal that represents a binary number. This input is used to determine which one of the 16 output lines will be activated.

[Output Signal Description]:
bcode[15:0]: A 16-bit output signal where only one bit is set to '1' corresponding to the binary value of the input 'a', and all other bits are '0'.


[Design Detail]:
`timescale 1ns / 1ps

module binary_decoder_4x16(
	input[3:0] a,
	output[15:0] bcode
    );
	 binary_decoder_2x4 m0
	 (
		 .en({!a[3] && !a[2]}),
		 .a(a[1:0]),
		 .bcode(bcode[3:0])
    );
	 
	 binary_decoder_2x4 m1
	 (
		 .en({!a[3] && a[2]}),
		 .a(a[1:0]),
		 .bcode(bcode[7:4])
    );
	 
	 binary_decoder_2x4 m2
	 (
		 .en({a[3] && !a[2]}),
		 .a(a[1:0]),
		 .bcode(bcode[11:8])
    ); 
	 
	 binary_decoder_2x4 m3
	 (
		 .en({a[3] && a[2]}),
		 .a(a[1:0]),
		 .bcode(bcode[15:12])
    );
	 


endmodule
",binary_decoder_4x16.txt,FPGA_Book_Experiments\binary_decoder_4x16.txt
"[Keyword]: bitmap_gen

[Design Category]: Interface Circuits

[Design Function Description]:
This design is a VGA bitmap generator that creates a visual display on a screen. It generates a 256x256 box at the center of the screen and includes a bouncing ball within this box. The ball's position is updated based on its velocity and direction, and it bounces off the walls of the box. The design also includes a mechanism to move the ball to a random position when a specific key is pressed.

[Input Signal Description]:
- `clk`: Clock signal used for synchronization.
- `rst_n`: Active-low reset signal to initialize or reset the circuit.
- `key[3:0]`: 4-bit input for key presses, where `key[3]` is used to trigger the ball's random repositioning.
- `video_on`: Signal indicating whether the video display is active.
- `pixel_x[11:0]`: 12-bit horizontal pixel coordinate for the current scan position.
- `pixel_y[11:0]`: 12-bit vertical pixel coordinate for the current scan position.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit output for the red component of the VGA signal.
- `vga_out_g[5:0]`: 6-bit output for the green component of the VGA signal.
- `vga_out_b[4:0]`: 5-bit output for the blue component of the VGA signal.


[Design Detail]:
`timescale 1ns / 1ps

module bitmap_gen(
	input clk,rst_n,
	input[3:0] key,
	input video_on,
	input[11:0] pixel_x,pixel_y,
	output reg[4:0] vga_out_r,
	output reg[5:0] vga_out_g,
	output reg[4:0] vga_out_b
    );
	 
					//screen boundary for a 256x256 box at the center of screen
	localparam  MAX_X=447,
					MIN_X=192,
					MIN_Y=112,
					MAX_Y=367,
					SIZE=256, //screen box size
					ball_V=1;//ball velocity
	
	reg[15:0] rd_addr,wr_addr;
	wire[15:0] addr; //read and write address for the 128k by 3 single port ram
	reg we;
	reg[7:0] ball_x_q=0,ball_x_d; //stores X value of the dot
	reg[7:0] ball_y_q=0,ball_y_d; //stores Y value of the dot
	reg ball_xdelta_q=0,ball_xdelta_d;
	reg ball_ydelta_q=0,ball_ydelta_d;
	wire[2:0] dout;
	wire key3_tick;
	
	 
	 //register for tracing dot
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			ball_x_q<=0;
			ball_y_q<=0;
			ball_xdelta_q<=0;
			ball_xdelta_q<=0;
		end
		else begin
			ball_x_q<=ball_x_d;
			ball_y_q<=ball_y_d;
			ball_xdelta_q<=ball_xdelta_d;
			ball_ydelta_q<=ball_ydelta_d;
		end
	 end
	 
	 //bouncing ball location logic
	 always @* begin
		ball_x_d=ball_x_q;
		ball_y_d=ball_y_q;
		ball_xdelta_d=ball_xdelta_q;
		ball_ydelta_d=ball_ydelta_q;
		wr_addr=0;
		we=0;
		
		if(key3_tick) begin //if key3 is pushed, the ball will move to the current location of scan(which would appear random to our eyes)
			ball_x_d=pixel_x;
			ball_y_d=pixel_y;
		end
		else if(pixel_y==500 && pixel_x==0) begin//1 tick when video is surely off
			//bouncing ball logic
			if(ball_x_q<=ball_V) ball_xdelta_d=1; //bounce from left wall
			else if((SIZE-ball_V-1)<=ball_x_q) ball_xdelta_d=0; //bounce from right wall
			if(ball_y_q<=ball_V) ball_ydelta_d=1; //bounce from top
			else if((SIZE-ball_V-1)<=ball_y_q) ball_ydelta_d=0; //bounce from bottom
			
			ball_x_d=ball_xdelta_d? (ball_x_q+ball_V):(ball_x_q-ball_V);
			ball_y_d=ball_ydelta_d? (ball_y_q+ball_V):(ball_y_q-ball_V);
			wr_addr={ball_x_q,ball_y_q}; //write the new trace location during refresh period i.e. when not reading
			we=1;
		end
	 end
	 
	
	//display logic
	always @* begin
		vga_out_r=0;
		vga_out_g=0;
		vga_out_b=0;
		rd_addr=0;
		if(video_on) begin
			if(MIN_X<=pixel_x && pixel_x<=MAX_X && MIN_Y<=pixel_y && pixel_y<=MAX_Y) begin //if inside the box
				rd_addr[15:8]=pixel_x-MIN_X;
				rd_addr[7:0]=pixel_y-MIN_Y;
				if(dout[0]) vga_out_r=5'b111_11;
				if(dout[1]) vga_out_g=6'b111_111;
				if(dout[2]) vga_out_b=5'b111_11;
			end
			else begin //color outside box
				vga_out_r=5'b111_11;
				vga_out_g=6'b111_111;
				vga_out_b=5'b111_11;
			end
		end
	end
	
	assign addr=we? wr_addr : rd_addr; 
	
	single_port_syn m0 //64k by 3
	(
		.clk(clk),
		.we(we),
		.addr(addr),
		.din((~key[2:0])),
		.dout(dout)
	);
	
	debounce_explicit m1
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(!key[3]),
		.db_level(),
		.db_tick(key3_tick)
    );

					
endmodule






",bitmap_gen.txt,FPGA_Book_Experiments\bitmap_gen.txt
"[Keyword]: breakout_top

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a control circuit for a breakout-style game using a finite state machine (FSM). The circuit manages the game states, including starting a new game, playing, handling ball misses, and game over conditions. It also controls the VGA output for displaying the game on a screen, including graphics and text.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the circuit operations.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `key[1:0]`: 2-bit input signal for controlling the paddle movement in the game.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit VGA red color output signal.
- `vga_out_g[5:0]`: 6-bit VGA green color output signal.
- `vga_out_b[4:0]`: 5-bit VGA blue color output signal.
- `vga_out_vs`: VGA vertical sync signal.
- `vga_out_hs`: VGA horizontal sync signal.


[Design Detail]:
`timescale 1ns / 1ps

module breakout_top(
	input clk, rst_n,
	input[1:0] key, //move the paddle
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 //FSM for the whole pong game
	 localparam[1:0] newgame=0,
							play=1,
							newball=2,
							over=3;
	wire clk_out;
	wire video_on;
	wire[11:0] pixel_x,pixel_y;
	wire graph_on;
	wire[4:0] text_on;
	wire miss,won;
	reg won_q,won_d;
	wire[2:0] rgb_graph,rgb_text;
	reg[2:0] rgb;
	reg[1:0] state_q,state_d;
	reg pause,restart;
	reg[2:0] ball_q=0,ball_d;
	reg timer_start;
	wire timer_tick,timer_up;
	
	//register operation for updating balls left and the current state of game
	always @(posedge clk_out,negedge rst_n) begin
		if(!rst_n) begin
			state_q<=0;
			ball_q<=0;
			won_q<=0;
		end
		else begin
			state_q<=state_d;
			ball_q<=ball_d;
			won_q<=won_d;
		end
	end
	
	//FSM next-state logic
	always @* begin
		state_d=state_q;
		ball_d=ball_q;
		pause=0;
		restart=0;
		timer_start=0;
		won_d=won_q;
			case(state_q)
				newgame: begin 
								restart=1; //3 balls will be restored at the start 
								ball_d=3;
								won_d=0;
								if(key!=2'b11) begin //only when any of the button is pressed will the game start
									ball_d=ball_q-1;
									state_d=play;   
								end
							end
				   play: if(miss || won) begin //game continues until the player misses the ball or the ball went past through the left border(all walls broken)
									won_d=won;
									if(miss) ball_d= (ball_q==0)? 0:ball_q-1;
									if(ball_q==0 || won) state_d=over;
									else state_d=newball;
									timer_start=1;
							end
				newball: begin  //after the player misses, 2 seconds will be alloted before the game can start again(as long as there are still balls left)
								pause=1;
								if(timer_up && key!=2'b11) state_d=play;
							end
				   over: begin
								pause=1;
								if(timer_up) state_d=newgame;
							end
				default: state_d=newgame;
			endcase
	end
	

	
	//rgb multiplexing 
	always @* begin
		rgb=0;
		if(!video_on) rgb=0;
		else begin
			if(text_on[4] || (text_on[3] && state_q==newgame) || (text_on[2]&& state_q==over)) rgb=rgb_text; //{ball_on,rule_on,gameover_on,win_on,logo_on};
			else if(graph_on) rgb=rgb_graph; 
			else if(text_on[0]) rgb=rgb_text; //logo is at the last hierarchy since this must be the most underneath text
			else rgb=3'b011; //background			
		end
	end
	
	assign vga_out_r={5{rgb[2]}};
	assign vga_out_g={6{rgb[1]}};
	assign vga_out_b={5{rgb[0]}};
	
	assign timer_tick= (pixel_x==0 && pixel_y==500);
	
	
	
	dcm_25MHz m0
   (// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );
	 vga_core m1
	(
		.clk(clk_out),
		.rst_n(rst_n), //clock must be 25MHz for 640x480 
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );
	 
	 
	 pong_animated m2 //control logic for any graphs on the game
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.video_on(video_on),
		.pause(pause),   //pause=stop state after missing a ball , restart=stop state at the beginning of new game
		.restart(restart), 
		.key(key), 
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.rgb(rgb_graph),
		.graph_on(graph_on),
		.miss(miss),  //miss=ball went past the paddle , won=when ball went past the left border
		.won(won) 
    );
	 
	 
	 pong_text m3 //control logic for any text on the game
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.video_on(video_on),
		.won(won_q),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.ball(ball_q),
		.rgb_text(rgb_text), 
		.text_on(text_on) //{score_on,rule_on,gameover_on,logo_on}
    );
	 
	 timer m4 //2 second timer which will be used for ""resting"" before restarting the game
	 (
		.clk(clk_out),
		.rst_n(rst_n),
		.timer_start(timer_start),
		.timer_tick(timer_tick),
		.timer_up(timer_up)
    );


endmodule
",breakout_top.txt,FPGA_Book_Experiments\breakout_top.txt
"[Keyword]: debounce

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a debounce circuit implemented using a finite state machine (FSM). It is used to filter out the noise or glitches from a mechanical switch or button press, ensuring that only a stable signal is passed through after a specified debounce delay.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and counter operations.
- `rst_n`: Active-low reset signal to initialize the state and counter registers.
- `signal`: Input signal from a mechanical switch or button that needs to be debounced.

[Output Signal Description]:
- `level`: Indicates the stable state of the debounced signal. It reflects the debounced version of the input `signal`.
- `ready`: Indicates when the debounce circuit is ready to accept a new input signal.
- `r_edg`: Indicates a rising edge detection on the input `signal`, used to trigger the start of the debounce process.


[Design Detail]:
`timescale 1ns / 1ps

module debounce(
	input clk,rst_n,
	input signal,
	output reg level,
	output reg ready,r_edg	
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							one=2'd1,
							waiting=2'd2,
							zero=2'd3;
	 localparam N=5_000_000; //N/50MHz=100ms debounce delay
	 reg[1:0] state_reg,state_nxt;
	 reg[22:0] counter_reg,counter_nxt; //log_2(N) -> 20bits
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=0;
			counter_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			counter_reg<=counter_nxt;
		end
	 end
	 //FSM next-state logic
	 always @* begin
		state_nxt=state_reg;
		counter_nxt=counter_reg;
		ready=0;
		r_edg=0;
		level=0;
		case(state_reg) 
			   idle: begin
							ready=1;
							if(signal) begin
								counter_nxt=0;
								r_edg=1;
								state_nxt=one;
							end
						end
		       one: begin
							level=1;
							if(counter_reg==N-1) state_nxt=waiting;
							else counter_nxt=counter_reg+1;
						end
			waiting: begin
							level=1;
							if(!signal) begin
								counter_nxt=0;
								state_nxt=zero;
							end
						end
			   zero: begin
							if(counter_reg==N-1) state_nxt=idle;
							else counter_nxt=counter_reg+1;
						end
			default: state_nxt=idle;
		endcase
	 end
	 

endmodule
",debounce.txt,FPGA_Book_Experiments\debounce.txt
"[Keyword]: debounce_explicit

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a debouncing circuit using a finite state machine (FSM) to stabilize the output signal from a mechanical switch. The circuit ensures that any noise or bouncing from the switch does not affect the output signal by requiring the switch to be stable for a certain period before changing the output state.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and timer operations.
- `rst_n`: Active-low reset signal to initialize the FSM and timer to their default states.
- `sw`: Input signal from the switch that needs debouncing.

[Output Signal Description]:
- `db_level`: Debounced level output, indicating the stable state of the switch.
- `db_tick`: A tick signal that indicates a transition from an unstable to a stable state.




























[Design Detail]:
`timescale 1ns / 1ps

module debounce_explicit(
	input clk,rst_n,
	input sw,
	output reg db_level,db_tick
    );
	 //FSM symbolic declaration
	 localparam[1:0]  idle=2'b00,
							delay0=2'b01,
							one=2'b10,
							delay1=2'b11;
	 localparam N=21; //21 bits is 42ms -> 2^N/50MHz=42ms
	 reg[1:0] state_reg,state_nxt;
	 reg[N-1:0] timer_reg,timer_nxt;
	 reg timer_zero,timer_inc,timer_tick; //control and status signal
	 
	 //FSM and timer register
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			timer_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			timer_reg<=timer_nxt;
		end
	 end
	 
	 //FSM control path next-state logic
	 always @* begin
		state_nxt=state_reg;
		timer_zero=0;
		timer_inc=0;
		db_tick=0;
		db_level=0;       
		
		case(state_reg)
			  idle: if(sw==1) begin
							timer_zero=1; //load the timer with value of zero
							state_nxt=delay0;
					  end
			delay0: if(sw==1) begin
							timer_inc=1;//increment timer by 1
							if(timer_tick) begin //if timer reaches the max(nxt edge will wrap the timer to zero again)
								state_nxt=one; 
								db_tick=1;
							end
					  end
					  else state_nxt=idle;
		      one: begin
							db_level=1;
							if(sw==0) begin
								timer_zero=1;  //load the timer with value of zero
								state_nxt=delay1;
							end
					  end
		   delay1: begin
							db_level=1;
							if(sw==0) begin
								timer_inc=1;
								if(timer_tick) //if timer reaches the max(wherein the nxt edge will wrap the timer to zero again)
									state_nxt=idle;
							end
							else state_nxt=one;
					   end
			 default: state_nxt=idle;
			endcase					
		end
		
		//Datapath(timer) logic and operation
		always @* begin
			timer_nxt=timer_reg;
			if(timer_zero) timer_nxt=0; //load zero 
			else if(timer_inc) timer_nxt=timer_reg+1; //increment by one
			timer_tick=(timer_reg=={N{1'b1}})?1:0; //notify if timer is already at max
		end


endmodule
",debounce_explicit.txt,FPGA_Book_Experiments\debounce_explicit.txt
"[Keyword]: debouncing_button

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit is designed to debounce a button input. It uses a finite state machine (FSM) to filter out the noise and glitches that occur when a button is pressed or released, ensuring that the output signal `db` only changes state when the button press is stable for a certain period.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and counter increments.
- `rst_n`: Active-low reset signal that initializes the FSM to its starting state.
- `sw_low`: Active-low input signal representing the button state. It is inverted to create an active-high signal `sw` for internal processing.

[Output Signal Description]:
- `db`: Debounced output signal that reflects the stable state of the button. It is set high when the button is confirmed to be pressed and low when the button is confirmed to be released.



[Design Detail]:
`timescale 1ns / 1ps

module debouncing_button(
	input clk,rst_n,
	input sw_low, //active low
	output reg db
    );
	 
	 localparam N=20; //free-running counter, 2^N/50MHz=2^20/50MHz=20.9ms 
	 
	 //symbolic declaration for FSM
	 localparam [2:0] zero=3'd0,
							mid0_1=3'd1,
							mid0_2=3'd2,
							one=3'd3,
							mid1_1=3'd4,
							mid1_2=3'd5;
							
	 reg[2:0] state_reg=0,state_nxt=0;
	 reg[N-1:0] counter=0; 
	 wire[N-1:0] counter_nxt;
	 wire sw,tick;
	 assign sw=!sw_low; //sw is now active high
	 
	 //Logic for FSM and free-running-counter 
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
				state_reg<=zero;
				counter<=0;
		end
		
		else begin
				state_reg<=state_nxt;
				counter<=counter_nxt;			
		 end
	 end
	 //next-state logic of FSM and free-running-counter
	 assign counter_nxt=counter+1;
	 assign tick=(counter==0);
	 always @* begin
		 state_nxt=state_reg;
		 db=0;
		 case(state_reg)
				zero: if(sw) state_nxt=mid0_1;
				mid0_1: begin
							if(!sw) state_nxt=zero;
							else if(tick) state_nxt=mid0_2;
						  end
				mid0_2: begin 
							if(!sw) state_nxt=zero;
							else if(tick) state_nxt=one;
						  end
					one: begin
							 db=1;
							 if(!sw) state_nxt=mid1_1;
						  end
				mid1_1: begin
							 db=1;
							 if(sw) state_nxt=one;
							 else if(tick) state_nxt=mid1_2;
						  end
			  mid1_2:  begin
							 db=1;
							 if(sw) state_nxt=one;
							 else if(tick) state_nxt=zero;
						  end
			  default: state_nxt=zero;
		  endcase
	 end


endmodule
",debouncing_button.txt,FPGA_Book_Experiments\debouncing_button.txt
"[Keyword]: div

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a binary division circuit using a finite state machine (FSM). It takes a dividend and a divisor as inputs and computes the quotient and remainder. The division process is iterative, using subtraction and bit manipulation to determine the quotient and remainder over several clock cycles.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `start`: Signal to initiate the division operation.
- `dividend[W-1:0]`: The dividend input for the division operation, where W is the bit-width.
- `divisor[W-1:0]`: The divisor input for the division operation, where W is the bit-width.

[Output Signal Description]:
- `quotient[W-1:0]`: The result of the division operation, representing the quotient.
- `remainder[W-1:0]`: The remainder left after the division operation.
- `ready`: Signal indicating the circuit is ready to start a new division operation.
- `done_tick`: Signal indicating the completion of the division operation.



[Design Detail]:
`timescale 1ns / 1ps

module div
	#(parameter W=32, N=6) //W is the width of both dividend and divisor, N is the size of the register that stores binary value of W: N=log_2(W)+1
	(
	input clk,rst_n,
	input start,
	input [W-1:0] dividend,divisor,
	output[W-1:0] quotient,remainder,
	output reg ready,done_tick
    );
	

	 //FSM declarations
	 localparam[1:0] idle=2'd0,
							op=2'd1,
							last=2'd2,
							done=2'd3;
	 reg[1:0] state_reg,state_nxt;
	 reg[W-1:0] dividend_reg,divisor_reg,dividend_nxt,divisor_nxt;
	 reg[W-1:0] remainder_reg,remainder_nxt;
	 reg[N-1:0] n_reg,n_nxt;
	 reg[W-1:0] temp;
	 reg q;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			dividend_reg<=0;
			divisor_reg<=0;
			remainder_reg<=0;
			n_reg<=0;
			state_reg<=0;
		end
		else begin
			dividend_reg<=dividend_nxt;
			divisor_reg<=divisor_nxt;
			remainder_reg<=remainder_nxt;
			n_reg<=n_nxt;
			state_reg<=state_nxt;
		end
	 end
	 
	//FSM next-state logics
	always @* begin
		dividend_nxt=dividend_reg;
		divisor_nxt=divisor_reg;
		remainder_nxt=remainder_reg;
		state_nxt=state_reg;
		n_nxt=n_reg;
		ready=0;
		temp=0;
		done_tick=0;
		q=0;
		case(state_reg)
			idle: begin
						ready=1;
						if(start) begin
						dividend_nxt=dividend;
						divisor_nxt=divisor;
						remainder_nxt=0;
						n_nxt=W; //decrements until all dividend is used
						state_nxt=op;
						end
					end
			  op: begin
						if(remainder_reg>=divisor_reg) begin
							temp=remainder_reg-divisor_reg;
							q=1;
						end
						else begin 
							temp=remainder_reg;
							q=0;
						end
						{remainder_nxt,dividend_nxt}={temp[W-2:0],dividend_reg,q};
						n_nxt=n_reg-1;
						if(n_nxt==0) state_nxt=last;
					end
			last: begin
						if(remainder_reg>=divisor_reg) begin
							temp=remainder_reg-divisor_reg;
							q=1;
						end
						else begin 
							temp=remainder_reg;
							q=0;
						end
						dividend_nxt={dividend_reg[W-2:0],q};
						remainder_nxt=temp;
						state_nxt=done;
					end
			done: begin
						done_tick=1;
						state_nxt=idle;
					end
		default: state_nxt=idle;
		endcase
	end
	assign quotient=dividend_reg;
	assign remainder=remainder_reg;
	

endmodule
",div.txt,FPGA_Book_Experiments\div.txt
"[Keyword]: dual_comparator

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is a dual comparator that compares two 8-bit numbers, `a` and `b`. It can perform both signed and unsigned comparisons based on the `mode` input. If `mode` is high (1), it performs a signed comparison; if `mode` is low (0), it performs an unsigned comparison. The output `agtb` indicates whether `a` is greater than `b`.

[Input Signal Description]:
- `a[7:0]`: An 8-bit input signal representing the first number to be compared.
- `b[7:0]`: An 8-bit input signal representing the second number to be compared.
- `mode`: A 1-bit input signal that determines the type of comparison. If `mode` is 1, a signed comparison is performed; if `mode` is 0, an unsigned comparison is performed.

[Output Signal Description]:
- `agtb`: A 1-bit output signal that indicates the result of the comparison. It is high (1) if `a` is greater than `b` according to the selected comparison mode, and low (0) otherwise.


[Design Detail]:
`timescale 1ns / 1ps

module dual_comparator(
	input[7:0] a,b,
	input mode,
	output signed agtb
    );
	 wire signed [7:0] a_signed,b_signed; ///storage for signed operation
	 wire[7:0] a_unsigned,b_unsigned; //storage for unsigned operation
	 
	 assign a_signed=a,
				 b_signed=b,
				 a_unsigned=a,
				 b_unsigned=b;
 
	 
	 assign agtb=mode? ((a_signed>b_signed)?1:0) : ((a_unsigned>b_unsigned)?1:0);
				


endmodule
",dual_comparator.txt,FPGA_Book_Experiments\dual_comparator.txt
"[Keyword]: dual_edge_detector_MEALY

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a dual-edge detector implemented using a Mealy state machine. It detects both rising and falling edges of an input signal `level` and generates a pulse on the output `edg` whenever an edge is detected.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions.
- `rst_n`: Active-low reset signal to initialize the state machine to a known state (`zero`).
- `level`: Input signal whose edges (both rising and falling) are to be detected.

[Output Signal Description]:
- `edg`: Output signal that generates a pulse (active-high) whenever a rising or falling edge is detected on the `level` input.


[Design Detail]:
`timescale 1ns / 1ps

module dual_edge_detector_MEALY(
	input clk,rst_n,
	input level, //active-high
	output reg edg
    );
	 //FSM declarations
	 localparam zero=1'b0,
					one=1'b1;
	reg state_reg,state_nxt;
	
	//FSM register operation
	always @(posedge clk,negedge rst_n) begin
		if(!rst_n) state_reg<=zero;
		else state_reg<=state_nxt;
	end
	//FSM next-state and output logic
	always @* begin
		state_nxt=state_reg;
		edg=0;
			case(state_reg)
			zero: if(level) begin
						edg=1;
						state_nxt=one;
					end
			one: if(!level) begin
						edg=1;
						state_nxt=zero;
					end
			default: state_nxt=zero;
			endcase	
	end

endmodule
",dual_edge_detector_MEALY.txt,FPGA_Book_Experiments\dual_edge_detector_MEALY.txt
"[Keyword]: dual_edge_detector_MOORE

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a dual-edge detector implemented using a Moore finite state machine (FSM). It detects both rising and falling edges of an input signal `level` and generates a pulse on the output `edg` whenever an edge is detected.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions of the FSM.
- `rst_n`: Active-low reset signal that initializes the FSM to its starting state (`zero`).
- `level`: Input signal whose edges (both rising and falling) are to be detected.

[Output Signal Description]:
- `edg`: Output signal that generates a pulse (active high) whenever a rising or falling edge is detected on the `level` input.


[Design Detail]:
`timescale 1ns / 1ps

module dual_edge_detector_MOORE(
	input clk,rst_n,
	input level, //active high
	output reg edg
    );
	 
	 //FSM declarations
	 localparam[1:0] zero=2'd0,
						  r_edg=2'd1,
						  one=2'd2,
						  f_edg=2'd3;
	 reg[1:0] state_reg,state_nxt;
	 
	 //FSM register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) state_reg<=zero;
		else state_reg<=state_nxt;
	 end
	 
	 //FSM next-state and output logic
	 always @* begin
		state_nxt=state_reg;
		edg=0;
		case(state_reg) 
			zero: if(level) state_nxt=r_edg;
			r_edg: begin
						edg=1;
						if(level) state_nxt=one;
						else state_nxt=zero;
					 end
			one: if(!level) state_nxt=f_edg;
			f_edg: begin
						edg=1;
						state_nxt=zero;
					 end
			default: state_nxt=zero;
		endcase
	 end


endmodule
",dual_edge_detector_MOORE.txt,FPGA_Book_Experiments\dual_edge_detector_MOORE.txt
"[Keyword]: dual_edge_detector_simpler

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a dual-edge detector circuit. It detects changes in the input signal `level` on both the rising and falling edges of the clock signal `clk`. The output `edg` indicates when a change in the `level` input has occurred.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the edge detection process.
- `rst_n`: Active-low reset signal. When asserted (low), it resets the internal state of the circuit.
- `level`: Input signal whose edges (transitions) are to be detected.

[Output Signal Description]:
- `edg`: Output signal that indicates a detected edge (transition) in the `level` input. It is high when a change in the `level` input is detected.


[Design Detail]:
`timescale 1ns / 1ps

module dual_edge_detector_simpler(
	input clk,rst_n,
	input level,
	output edg
    );
	 reg level_reg=0;
	 always @(posedge clk,negedge rst_n)
	 if(!rst_n) level_reg<=0;
	 else level_reg<=level;
	 assign edg=level^level_reg;
endmodule
",dual_edge_detector_simpler.txt,FPGA_Book_Experiments\dual_edge_detector_simpler.txt
"[Keyword]: dual_mode_disp

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a dual-mode display controller for a VGA interface. It alternates between two display modes: vertical and horizontal. The display mode can be changed using a key input. The circuit processes input signals to control the VGA output, allowing for cursor movement and character writing on the display.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `rx`: Serial input for receiving data.
- `key[3:0]`: 4-bit input for controlling the display:
  - `key[0]`: Move cursor to the right.
  - `key[1]`: Move cursor down.
  - `key[2]`: Write a new ASCII character at the current cursor position.
  - `key[3]`: Change the display mode between vertical and horizontal.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit VGA red color output.
- `vga_out_g[5:0]`: 6-bit VGA green color output.
- `vga_out_b[4:0]`: 5-bit VGA blue color output.
- `vga_out_vs`: VGA vertical sync signal.
- `vga_out_hs`: VGA horizontal sync signal.


[Design Detail]:
`timescale 1ns / 1ps

module dual_mode_disp
	(
	input clk,rst_n,
	input rx,
	input[3:0] key, //key[0] to move cursor to right,key[1] to move cursor down,key[2] to write @ current cursor,key[3] to change display mode
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 wire key3_tick;
	 reg mode_q=0;
	 wire[2:0] rgb_vertical,rgb_horizontal;
	
	 //alternates between horizontal and vertical mode
	 always @(posedge clk_out,negedge rst_n) begin 
		if(!rst_n) mode_q<=0;
		else mode_q<= key3_tick? !mode_q:mode_q;
	 end
	 
	 
	 assign rgb= mode_q? rgb_horizontal:rgb_vertical; //chooses which of the two modes will be displayed
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	mode_vertical m1 //vertical mode
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.rx(rx),
		.key(key[2:0]), //key[0] to move cursor to right,key[1] to move cursor down,key[2] to write new ASCII character to current cursor
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb_vertical)
    );
	
	mode_horizontal m2  //horizontal mode
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.rx(rx),
		.key(key[2:0]), //key[0] to move cursor to right,key[1] to move cursor down,key[2] to write new ASCII character to current cursor
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb_horizontal)
    );
	 
	 dcm_25MHz m3
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );  
	 
	debounce_explicit m4
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.sw(key[3]),
		.db_level(),
		.db_tick(key3_tick)
    );
	 
	
endmodule

",dual_mode_disp.txt,FPGA_Book_Experiments\dual_mode_disp.txt
"[Keyword]: dual_port_syn

[Design Category]: Memory Circuits

[Design Function Description]:  
This design implements a single-port synchronous RAM with a size of 128k by 3 bits. It uses block RAM to store data. The RAM allows for reading and writing operations, with data being written on the rising edge of the clock when the write enable signal is active.

[Input Signal Description]:  
- `clk`: Clock signal used to synchronize read and write operations.
- `we`: Write enable signal. When high, data is written to the RAM at the specified address.
- `addr[ADDR_WIDTH-1:0]`: Address input used to specify the location in RAM for read or write operations. The width is determined by the parameter `ADDR_WIDTH`.
- `din[DATA_WIDTH-1:0]`: Data input used to provide the data to be written into the RAM. The width is determined by the parameter `DATA_WIDTH`.

[Output Signal Description]:  
- `dout[DATA_WIDTH-1:0]`: Data output that provides the data read from the RAM at the specified address. The width is determined by the parameter `DATA_WIDTH`.



[Design Detail]:
`timescale 1ns / 1ps

module single_port_syn //128k by 3 single port sync ram(uses block ram)
#(parameter ADDR_WIDTH=16,
				DATA_WIDTH=3)
(
	input clk,
	input we,
	input[ADDR_WIDTH-1:0] addr,
	input[DATA_WIDTH-1:0] din,
	output[DATA_WIDTH-1:0] dout
);
	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
	reg[ADDR_WIDTH-1:0] addr_q;
	
	always @(posedge clk) begin
		if(we) ram[addr]=din;
		addr_q<=addr;
	end
	assign dout=ram[addr_q];
endmodule
",dual_port_syn.txt,FPGA_Book_Experiments\dual_port_syn.txt
"[Keyword]: dual_prioenc

[Design Category]: Combinational Logic

[Design Function Description]:
The design is a dual priority encoder. It scans a 12-bit input vector to identify the positions of the first and second highest priority '1' bits. The position of the first '1' bit found is stored in the `first` output, and the position of the second '1' bit is stored in the `second` output.

[Input Signal Description]:
`in[11:0]`: A 12-bit input signal where each bit can be either '0' or '1'. The circuit will prioritize the bits from the most significant to the least significant to determine the positions of the first and second '1' bits.

[Output Signal Description]:
`first[3:0]`: A 4-bit output signal representing the position (1-based index) of the first '1' bit found in the input.
`second[3:0]`: A 4-bit output signal representing the position (1-based index) of the second '1' bit found in the input.


[Design Detail]:
`timescale 1ns / 1ps

module dual_prioenc(
	input wire[11:0] in,
	output reg[3:0] first,second
    );
	 integer i;

	 always @(in) begin
	 first=4'd0;
	 second=4'd0;

	 
	 for(i=11;i>=0;i=i-1) begin  //use for-loop to locate the bit ""1""
	 if(in[i] && !first) first=i+1;
	 else if(first && in[i] && !second) second=i+1; //if ""first"" already has a value,then the next bit of 1 will be the ""second""
	 end
	 end
	
endmodule 
",dual_prioenc.txt,FPGA_Book_Experiments\dual_prioenc.txt
"[Keyword]: early_debounce

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a debouncing circuit for a switch input. It uses a finite state machine (FSM) to ensure that the switch input is stable for a certain period (approximately 20 milliseconds) before considering it as a valid input. This helps to eliminate the noise and false triggering caused by the mechanical bouncing of the switch.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the FSM and counter operations.
- `rst_n`: Active-low reset signal to initialize the FSM and counter.
- `sw_low`: Active-low switch input signal that needs debouncing.

[Output Signal Description]:
- `db`: Active-high debounced output signal that reflects the stable state of the switch input after debouncing.


[Design Detail]:
`timescale 1ns / 1ps

module early_debounce(
	input clk,rst_n,
	input sw_low,//active low input
	output reg db //active high output
    );
	 //FSM declarations
	 localparam[2:0] start=3'd0,
						  one=3'd1,
						  delay1=3'd2,
						  delay2=3'd3,
						  zero=3'd4,
						  delay3=3'd5;
	 reg[2:0] state_reg,state_nxt;
	 
	 //20-ms counter delarations
	 localparam N=21; // 2^N/50MHz=2^20/50MHz=20.97ms period
	 reg[N-1:0] counter_reg=0;
	 wire tick;
	 wire level=!sw_low;
	 //FSM and 20ms-counter register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=start;
			counter_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			counter_reg<=counter_reg+1;
		end
	 end
	assign tick=(counter_reg==0); //ticks at the end of every 20.97ms
	 
	 
	 //FSM next-state and output logic
	 always @* begin
		state_nxt=state_reg;
		db=0;
		case(state_reg)
			 start: if(level) state_nxt=one; //rising edge
				one: begin   //wait for 20ms
							db=1;
							if(tick) state_nxt=delay1;
					  end
			delay1: begin //wait for 20ms
						db=1;
						if(tick) state_nxt=delay2;
					  end
			delay2: begin
						 db=1;
						 if(!level) state_nxt=zero; //wait here until falling edge comes
					  end
			  zero: if(tick) state_nxt=delay3;
			delay3: if(tick) state_nxt=start;
			default: state_nxt=start;						
		endcase
	 end

endmodule
",early_debounce.txt,FPGA_Book_Experiments\early_debounce.txt
"[Keyword]: Enhanced_Stopwatch

[Design Category]: Sequential Logic

[Design Function Description]:
The design is an enhanced stopwatch that can count up or down based on user input. It displays time in the format M.S1S0.D, where M represents minutes, S1 and S0 represent seconds, and D represents tenths of a second. The stopwatch can be paused and resumed, and it automatically stops at 0.00.0 when counting down and at 9.59.9 when counting up.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operation of the stopwatch.
- `rst_n`: Active-low reset signal to initialize the stopwatch.
- `up`: Control signal to determine the counting direction (1 for count up, 0 for count down).
- `go`: Control signal to start or pause the stopwatch (1 to play, 0 to pause).

[Output Signal Description]:
- `in0`: 5-bit output representing the decimal digit (D) of the stopwatch.
- `in1`: 5-bit output representing the first digit of seconds (S0).
- `in2`: 5-bit output representing the second digit of seconds (S1).
- `in3`: 5-bit output representing the minutes digit (M).
- `in4`: 5-bit output, always set to 0.
- `in5`: 5-bit output, always set to 0.




[Design Detail]:
`timescale 1ns / 1ps

module Enhanced_Stopwatch(   
	input clk,rst_n,
	input up,go,clr, // up-> 1:Count up 0:Count down    go->1:play 0:pause    clr-->back to 0.00.0
	output[5:0] in0,in1,in2,in3,in4,in5
    );
	 
	 //NOTE: LED display format of stopwatch: M.S1S0.D. This will automatically stop at 0.00.0 when counting down and will stop at 9.59.9 when counting up
	 reg[22:0] mod_5M=0; //period of 0.1 sec (5M/50MHz=0.1 sec)
	 reg[3:0] D=0,S0=0,M=0; //D=Decimal  S0=1st digit of seconds   S1=2nd digit of seconds   M=Minutes
	 reg[2:0] S1=0; //S1 counts from 0 to 5 only so 3 bits is enough
	 reg[22:0] mod_5M_nxt=0;
	 reg[3:0] D_nxt=0,S0_nxt=0,M_nxt=0;
	 reg[2:0] S1_nxt=0;
	 reg mod_5M_max=0,D_max=0,S0_max=0,S1_max=0,M_max=0;
	 //registers
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
			mod_5M<=0;
			D<=0;
			S0<=0;
			S1<=0;
			M<=0;
	
		 end
		 
		 else begin
			 if(clr) begin
				mod_5M<=0;
				D<=0;
				S0<=0;
				S1<=0;
				M<=0;	
			 end
			 else if(go) begin 
				mod_5M<=mod_5M_nxt;
				D<=D_nxt;
				S0<=S0_nxt;
				S1<=S1_nxt;
				M<=M_nxt;
			 end
		 end
	 end
	 
	 //next-state logics
	 always @* begin
	 mod_5M_nxt=mod_5M;
	 D_nxt=D;
	 S0_nxt=S0;
    S1_nxt=S1;
    M_nxt=M;	
	 mod_5M_max=0;
	 D_max=0;
	 S0_max=0;
	 S1_max=0;
	 M_max=0;
 			 mod_5M_nxt=  up? mod_5M+1:mod_5M-1;  //counter with 0.1 period
			 mod_5M_max= (mod_5M_nxt==5_000_000|| mod_5M_nxt=={23{1'b1}}) ? 1:0; //Notify next line when 5_000_000(max when counting up) is reached or when 23{1'b1}(counting down from zero) is reached
			 mod_5M_nxt= (mod_5M_nxt==5_000_000) ? 0:mod_5M_nxt; //5_000_000  must never be reach(since 4_999_999 is the ceiling) so go back to zero. This happens when we count up from 4_999_999
			 mod_5M_nxt= (mod_5M_nxt=={23{1'b1}}) ? 4_999_999:mod_5M_nxt; //{23{1'b1}} must never be reach since 4_999_999 is the hihgest . This happens when we count down from zero.
			 
			 if(mod_5M_max) begin //decimal digit(counts from 0.0 to 0.9 sec
			 D_nxt=up?D+1:D-1;
			 D_max=(D_nxt==10 || D_nxt==4'b1111)?1:0;  //Notify next line when 4'd10(max when counting up) is reached or when 4'b1111(counting down from zero) is reached
			 D_nxt=(D_nxt==10)?0:D_nxt; //10  must never be reach(since 9 is the ceiling) so go back to zero. This happens when we count up from 9
			 D_nxt=(D_nxt==4'b1111)?9:D_nxt; ////4'b1111 must never be reach(since 9 or 4'b1010 is the highest) so go back to zero. This happens when we count down from zero.
			 end
			 
			 if(D_max && mod_5M_max) begin //first digit of seconds(counts from 0 to 9 sec)
			 S0_nxt=up?S0+1:S0-1;
			 S0_max=(S0_nxt==10 || S0_nxt==4'b1111)?1:0; //Notify next line when 4'd10(max when counting up) is reached or when 4'b1111(counting down from zero) is reached
			 S0_nxt=(S0_nxt==10)?0:S0_nxt; //10  must never be reach(since 9 is the ceiling) so go back to zero. This happens when we count up from 9
			 S0_nxt=(S0_nxt==4'b1111)? 9:S0_nxt; ////4'b1111 must never be reach(since 9 or 4'b1010 is the highest) so go back to zero. This happens when we count down from zero.
			 end
			 
			 if(S0_max && D_max && mod_5M_max) begin //second digit of seconds(counts from 0 to 5)
			 S1_nxt=up?S1+1:S1-1;
			 S1_max=(S1_nxt==6 || S1_nxt==3'b111)?1:0;//Notify next line when 3'd6(max when counting up) is reached or when 4'b1111(counting down from zero) is reached
			 S1_nxt=(S1_nxt==6)?0:S1_nxt; //6  must never be reach(since 5 is the ceiling) so go back to zero. This happens when we count up from 5
			 S1_nxt=(S1_nxt==3'b111)?5:S1_nxt; ////3'b111 must never be reach(since 5 or 3'b101 is the highest) so go back to zero. This happens when we count down from zero.
			 end
			 
			 if(S1_max && S0_max && D_max && mod_5M_max) begin //Minutes digit(counts from 0 to 9)
			 M_nxt=up?M+1:M-1;
			 M_max=(M_nxt==10 || M_nxt==4'b1111)?1:0; //If 10 is reached then notify next line to STOP COUNTING SINCE 9.59.9 4_999_999 is the MAX)
																  //If 0 is 4'b1111 is reached then notify next line to STOP COUNTING SINCE 0.00.0 0_000_000 is the MIN)
			 end		
		
		 if(M_max==1) begin //if M_max_nxt is asserted,then replaced all register with previous value, WITHOUT THIS THE STOPWATCH WILL STOP AT F.59.9 no at 0.00.00 when counting down
			 mod_5M_nxt=mod_5M;
			 D_nxt=D;
			 S0_nxt=S0;
			 S1_nxt=S1;
			 M_nxt=M;
		 end
	 
	 end
	 assign in0={2'b0,D},
			  in1={2'b10,S0},
			  in2={3'b000,S1},
			  in3={2'b10,M},
			  in4=0,
			  in5=0;
	





endmodule",Enhanced_Stopwatch.txt,FPGA_Book_Experiments\Enhanced_Stopwatch.txt
"[Keyword]: eq1

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is a 1-bit equality comparator. It checks if the two input bits are equal and outputs a high signal if they are.

[Input Signal Description]:
i0, i1: These are the two 1-bit input signals that the circuit compares for equality.

[Output Signal Description]:
eq: This is a 1-bit output signal that is high (1) if the inputs i0 and i1 are equal, and low (0) otherwise.


[Design Detail]:
`timescale 1ns / 1ps

module eq1(
	input wire i0,i1,
	output wire eq
    );
	// signal declaration 
	wire p0, pl; 

	// body 
	// sum of two product terms 
	assign eq = p0 || pl; 
	
	// product terms 
	assign p0 = ~i0 & ~i1; 
	assign pl = i0 & i1;

endmodule
",eq1.txt,FPGA_Book_Experiments\eq1.txt
"[Keyword]: eq2

[Design Category]: Combinational Logic

[Design Function Description]:
The design is a 2-bit equality comparator. It checks if two 2-bit input vectors, `a` and `b`, are equal. The output `aeqb` is high (1) if both input vectors are equal, otherwise it is low (0).

[Input Signal Description]:
- `a[1:0]`: A 2-bit input vector.
- `b[1:0]`: Another 2-bit input vector to be compared with `a`.

[Output Signal Description]:
- `aeqb`: A single-bit output signal that is high if the input vectors `a` and `b` are equal, otherwise it is low.


[Design Detail]:
`timescale 1ns / 1ps

module eq2(
	input wire[1:0] a, b, 
	output wire aeqb 
    );

	// internal signal declar.ation 
	wire eO, e1;

	// instantiate ~H'O I- bit comparators 
	eq1 eq_bit0_unit(.i0(a[0]), .i1(b[0]) , .eq(eO)) ; 
	eq1 eq_bitl_unit(.eq(e1), .i0(a[1]), .i1(b[1])); 
 // a and b are equal if individual bits are equal 
	assign aeqb = eO & e1; 
endmodule 

",eq2.txt,FPGA_Book_Experiments\eq2.txt
"[Keyword]: fibo

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a sequential logic circuit that calculates the Fibonacci sequence up to the 31st Fibonacci number. It uses a finite state machine (FSM) to control the calculation process, transitioning through states to compute the Fibonacci numbers based on the input index.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the circuit.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `start`: Signal to initiate the Fibonacci calculation process.
- `i[4:0]`: 5-bit input signal representing the index of the Fibonacci number to be calculated, with a maximum value of 31.

[Output Signal Description]:
- `fibo[20:0]`: 21-bit output signal representing the calculated Fibonacci number corresponding to the input index `i`.
- `done_tick`: A register output signal that indicates the completion of the Fibonacci calculation process.


[Design Detail]:
`timescale 1ns / 1ps

module fibo(
	input clk,rst_n,
	input start,
	input[4:0] i, //limit is until the 31st fibonacci
	output[20:0] fibo,
	output reg done_tick
    );
	//FSM state declarations
	 localparam[1:0] idle=2'd0,
							op=2'd1,
							done=2'd2;
	 reg[1:0] state_reg;
	 reg[20:0] i1,i0;
	 reg[4:0] n;
	 
	 //FSM register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			i1<=0;
			i0<=0;
			n<=0;
			done_tick=0;
			state_reg<=idle;
		end
		else begin
			done_tick=0;                     
			case(state_reg) 
				idle: if(start) begin
							i1<=1;
							i0<=0;
							n<=i;
							state_reg<=op;
						end
				 op: begin
						if(n==0) begin
							i1<=0;
							state_reg<=done;
						end
						else if(n==1) state_reg<=done;
						else begin
							i1<=i0+i1;
							i0<=i1;
							n<=n-1;
						end				 
					  end
			  done: begin
						done_tick=1;
						state_reg<=idle;
					  end
		  default: state_reg<=idle;		 
			endcase
		end
	 end
	 assign fibo=i1;
endmodule
",fibo.txt,FPGA_Book_Experiments\fibo.txt
"[Keyword]: fibonacci

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) to calculate the Fibonacci sequence. It computes the Fibonacci number for a given index `i` and outputs the result. The FSM transitions through states to perform the calculation and indicates when the computation is ready and completed.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the FSM operations.
- `rst_n`: Active-low reset signal to initialize the FSM and registers.
- `start`: Signal to initiate the Fibonacci calculation.
- `i[5:0]`: 6-bit input representing the index of the Fibonacci sequence to compute.

[Output Signal Description]:
- `fibo[20:0]`: 21-bit output representing the Fibonacci number at the given index `i`.
- `ready`: Signal indicating the FSM is ready to start a new calculation.
- `done_tick`: Signal indicating the completion of the Fibonacci calculation.


[Design Detail]:
`timescale 1ns / 1ps

module fibonacci(
	input clk,rst_n,
	input start,
	input[5:0] i,
	output[20:0] fibo,
	output reg ready,done_tick
    );
	 //FSM declarations
	 localparam[1:0] idle=2'd0,
							op=2'd1,
							done=2'd2;
	 reg[1:0] state_reg,state_nxt;
	 reg[20:0] i1_reg,i0_reg,i1_nxt,i0_nxt;
	 reg[5:0] n_reg,n_nxt;
	 //FSM register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			i1_reg<=0;
			i0_reg<=0;
			n_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			i1_reg<=i1_nxt;
			i0_reg<=i0_nxt;
			n_reg<=n_nxt;
		end
	 end
	 
	 //FSM next-state logics
	 always @* begin
		state_nxt=state_reg;
		i1_nxt=i1_reg;
		i0_nxt=i0_reg;
		n_nxt=n_reg;
		ready=0;
		done_tick=0;
		
		case(state_reg) 
			idle: begin
						ready=1;
						if(start) begin
							i1_nxt=1;
							i0_nxt=0;
							n_nxt=i;
							state_nxt=op;
							if(i>30) begin
							i1_nxt=999_999;
							state_nxt=done;
							end
						end
					 end
			 op: begin
						 if(n_reg==0) begin
							i1_nxt=0;
							state_nxt=done;
						 end
						 else begin
							if(n_reg==1) state_nxt=done;
							else begin
								i1_nxt=i1_reg+i0_reg;
								i0_nxt=i1_reg;
								n_nxt=n_reg-1;
							end
						 end
				  end
			 done: begin
						done_tick=1;
						state_nxt=idle;
					 end
			 default: state_nxt=idle;
		endcase
	 end
	 assign fibo=i1_reg;
			
	 
endmodule
",fibonacci.txt,FPGA_Book_Experiments\fibonacci.txt
"[Keyword]: fifo

[Design Category]: Memory Circuits

[Design Function Description]:  
This design implements a FIFO (First-In-First-Out) memory buffer. It allows data to be written into the buffer and read out in the order it was written. The FIFO has control signals to indicate when it is full or empty, preventing overflows and underflows.

[Input Signal Description]:  
- `clk`: Clock signal for synchronizing the read and write operations.
- `rst_n`: Active-low reset signal to initialize or reset the FIFO.
- `wr`: Write enable signal. When high, data is written to the FIFO.
- `rd`: Read enable signal. When high, data is read from the FIFO.
- `wr_data[B-1:0]`: Data input to be written into the FIFO.

[Output Signal Description]:  
- `rd_data[B-1:0]`: Data output from the FIFO, representing the data at the read pointer.
- `full`: A register output that indicates when the FIFO is full and cannot accept more data.
- `empty`: A register output that indicates when the FIFO is empty and there is no data to read.





















[Design Detail]:
`timescale 1ns / 1ps

module fifo
	#(parameter W=4,B=8)
	(
	input clk,rst_n,
	input wr,rd,
	input[B-1:0] wr_data,
	output[B-1:0] rd_data,
	output reg full,empty
    );
	 initial begin
		full=0;
		empty=1;
	 end
	 reg[W-1:0] rd_ptr=0,wr_ptr=0;
	 reg[B-1:0] array_reg[2**W-1:0];

	 
	 //register file operation
	 always @(posedge clk) begin
		if(wr && !full && !(wr&&rd&&empty)) array_reg[wr_ptr]=wr_data;
	 end
	 assign rd_data=array_reg[rd_ptr];
	 
	 //fifo operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			rd_ptr=0;
			wr_ptr=0;
			full=0;
			empty=1;
		end
		else begin
			case({rd,wr})
				2'b01: if(!full) begin
							wr_ptr=wr_ptr+1;
							empty=0;
							full=(wr_ptr==rd_ptr);
						 end
				2'b10: if(!empty) begin
							rd_ptr=rd_ptr+1;
							full=0;
							empty=(rd_ptr==wr_ptr);
						 end
				2'b11: if(!empty && !full) begin
								rd_ptr=rd_ptr+1;
								wr_ptr=wr_ptr+1;
						 end
			endcase
		end
	 end

endmodule
",fifo.txt,FPGA_Book_Experiments\fifo.txt
"[Keyword]: fifo_monitor

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a FIFO (First-In-First-Out) monitor module that checks the data being read from a FIFO against a predefined set of values stored in an internal array. It outputs a message indicating whether the read data matches the expected data.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations within the module.
- `rd`: Read enable signal, indicating when data is being read from the FIFO.
- `rd_data[B-1:0]`: The data being read from the FIFO, where `B` is the parameter defining the bit-width of the data.
- `full`: Signal indicating if the FIFO is full (not used in this module).
- `empty`: Signal indicating if the FIFO is empty (not used in this module).

[Output Signal Description]:
There is no explicit output signal in this module. Instead, the module uses `$display` to print messages to the console, indicating whether the read data matches the expected data stored in the internal array.




[Design Detail]:
`timescale 1ns / 1ps

module fifo_monitor #(parameter W=4,B=8)
	(
	input clk,
	input rd,
	input[B-1:0] rd_data,
	input full,empty
    );

	 reg[7:0] array_reg[1024:0];
	 integer i;
	 reg [39:0] msg;
	 
	 initial begin	
		$display(""Output Desired"");
		i=0;
		array_reg[0]=""A"";
		array_reg[1]=""B"";
		array_reg[2]=""C"";
		array_reg[3]=""D"";
		array_reg[4]=""E"";
		array_reg[5]=""F"";
		array_reg[6]=""G"";
		array_reg[7]=""H"";
		//array_reg[8];
		//array_reg[9];
		array_reg[10]=""I"";
		array_reg[11]=""J"";
		array_reg[12]=""K"";
		array_reg[13]=""L"";
		array_reg[14]=""M"";
		array_reg[15]=""N"";
		array_reg[16]=""O"";
		array_reg[17]=""P"";
		array_reg[18]=""Q"";
		array_reg[19]=""R"";
		array_reg[20]=""S"";
		array_reg[21]=""T"";
		array_reg[22]=""U"";
		array_reg[23]=""V"";
		array_reg[24]=""W"";
		array_reg[25]=""X"";
		array_reg[26]=""I"";
		array_reg[27]=""I"";
		array_reg[28]=""I"";
		array_reg[29]=""I"";
		array_reg[30]=1;
		array_reg[31]=2;
		array_reg[32]=3;
		array_reg[33]=4;
		array_reg[34]=5;
		array_reg[35]=6;
		array_reg[36]=7;
		array_reg[37]=8;
		array_reg[38]=9;
		array_reg[39]=10;
		array_reg[40]=11;
		array_reg[41]=12;
		array_reg[42]=13;
		array_reg[43]=14;
		array_reg[44]=15;
		array_reg[45]=16;
		array_reg[46]=17;
		array_reg[47]=18;
		array_reg[48]=19;
		array_reg[49]=20;
	 end
	 

	 
	 always @(posedge clk) begin
			if(rd) begin
				i<=i+1;
			end
			if(array_reg[i]==rd_data) begin
				msg="" "";
			end
			else msg=""ERROR"";
		
			$display(""%h %h %s"",rd_data,array_reg[i],msg);
			
	 end


endmodule
",fifo_monitor.txt,FPGA_Book_Experiments\fifo_monitor.txt
"[Keyword]: fp_greaterthan

[Design Category]: Combinational Logic

[Design Function Description]:  
The circuit is designed to compare two 13-bit floating-point numbers and determine if the first number is greater than the second number. The numbers are represented in a sign-magnitude format, where the most significant bit (MSB) is the sign bit.

[Input Signal Description]:  
- `first[12:0]`: A 13-bit input signal representing the first floating-point number. The MSB is the sign bit, and the remaining 12 bits represent the magnitude.
- `second[12:0]`: A 13-bit input signal representing the second floating-point number. The MSB is the sign bit, and the remaining 12 bits represent the magnitude.

[Output Signal Description]:  
- `gt`: A 1-bit output signal that is set to 1 if the first number is greater than the second number, otherwise it is set to 0.


[Design Detail]:
`timescale 1ns / 1ps

module fp_greaterthan(
	input wire[12:0] first,second,
	output reg gt
    );
	 always @* begin
	 gt=1'b0;
	 if(!first[12] && !second[12] && first[11:0]>second[11:0] ) gt=1'b1;  //if first and second are both positive
	 else if(first[12] && second[12] && first[11:0]<second[11:0]) gt=1'b1; //if first and second are both negative
	 else if(!first[12] && second[12]) gt=1'b1; //if first is positive and second is negative
	 end 


endmodule
",fp_greaterthan.txt,FPGA_Book_Experiments\fp_greaterthan.txt
"[Keyword]: fp_to_int

[Design Category]: Arithmetic Circuits

[Design Function Description]:  
The circuit converts a 13-bit floating-point number into an 8-bit integer. It also detects overflow and underflow conditions during the conversion process.

[Input Signal Description]:  
- `fp[12:0]`: A 13-bit input signal representing a floating-point number. The most significant bit (fp[12]) is the sign bit, bits [11:8] represent the exponent, and bits [7:0] represent the fraction.

[Output Signal Description]:  
- `integ[7:0]`: An 8-bit output signal representing the integer conversion of the floating-point input.
- `over`: A 1-bit output signal that indicates an overflow condition during the conversion.
- `under`: A 1-bit output signal that indicates an underflow condition during the conversion.


[Design Detail]:
`timescale 1ns / 1ps

module fp_to_int(
	input wire[12:0] fp,
	output reg[7:0] integ,
	output reg over,under
    );
	 reg[3:0] exp;
	 reg[7:0] frac;
	 always@(fp) begin
		 integ=8'b0;
		 over=1'b0;
		 under=1'b0;
		 frac=fp[7:0];
		 exp=fp[11:8];
		 
		 integ[7]=fp[12];   //sign bit of fp is same with int
		 
		 if(exp>7 && frac[7]) begin //overflow
			integ[6:0]=7'b111_1111;  
			over=1'b1;
		 end
		 else if(exp==0 && frac[7]) begin //underflow
			integ[6:0]=7'b000_0000;
			under=1'b1;
		 end
		 else if(exp<=7 && frac[7]) begin
			integ[6:0]=frac>>(8-exp);
		 end
	 end
	 
endmodule
",fp_to_int.txt,FPGA_Book_Experiments\fp_to_int.txt
"[Keyword]: full_screen_gen

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a VGA display controller that generates a full-screen display of square wave signals. It uses a finite state machine (FSM) to sample and store four square-wave inputs into RAM, which are then displayed on a screen via VGA. The design includes logic for handling video signals, pixel coordinates, and RGB output for visual representation of the square waves.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `key`: Input signal for triggering state transitions in the FSM.
- `in[3:0]`: 4-bit input representing square wave signals to be displayed.
- `pixel_x[9:0]`, `pixel_y[9:0]`: 10-bit signals representing the current pixel coordinates on the screen.
- `video_on`: Signal indicating whether the video display is active.

[Output Signal Description]:
- `rgb[2:0]`: 3-bit output signal representing the RGB color values for the VGA display, used to visualize the square wave signals on the screen.






[Design Detail]:
`timescale 1ns / 1ps

module full_screen_gen(
	input clk,rst_n,
	input key,
	input[3:0] in, //square wave input to be displayed on screen via VGA
	input[9:0] pixel_x,pixel_y, 
	input video_on,
	output reg[2:0] rgb
    );
	//FSM for storing the four square-wave signal to RAM which will then be displayed at the screen
	 localparam idle=0,
					firstpair=1,
					secondpair=2;
	 
	 reg[1:0] state_q,state_d;
	 reg we;
	 wire on1,on2,on3,on4;
	 reg on;
	 reg[6:0] x_cursor_q,x_cursor_d;
	 reg[1:0] dout;
	 wire[1:0] dout_1,dout_2,dout_3,dout_4;
	 reg[1:0] din1_q,din1_d,din2_q,din2_d,din3_q,din3_d,din4_q,din4_d;
	 reg[7:0] mod125_q=0;
	 wire mod_tick;
	 wire[7:0] font_data;
	 wire font_bit;
	 wire key_tick;
	 reg[9:0] pixel_x_q,pixel_x_q2; 	//retrieving data from syn_rom and syn_dualport_ram causes 2 clk
																							//delays so we need to delay the pixel_x and pixel_y by 2 clk delays too
																							
	 
	 //register operation to update current cursor
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_q<=0;
			din1_q<=0;
			din2_q<=0;
			din3_q<=0;
			din4_q<=0;
			pixel_x_q<=0;
			pixel_x_q2<=0;
			mod125_q<=0;
			x_cursor_q<=0;
		end
		else begin
			state_q<=state_d;
			din1_q<=din1_d;
			din2_q<=din2_d;
			din3_q<=din3_d;
			din4_q<=din4_d;
			x_cursor_q<=x_cursor_d;
			pixel_x_q<=pixel_x;
			pixel_x_q2<=pixel_x_q;
			mod125_q<=(mod125_q==124)?0:mod125_q+1; //free running counter(200kHz)
		end
	 end
		assign mod_tick = mod125_q==0; //ticks every 5us(200kHz),serves as sampling tick for the highest possible frequency of the square wave(which is 100kHz)
		
		//FSM logic for sampling the four square-wave inputs
		always @* begin
			state_d=state_q;
			din1_d=din1_q;
			din2_d=din2_q;
			din3_d=din3_q;
			din4_d=din4_q;
			x_cursor_d=x_cursor_q;
			we=0;
			dout=0;
			on=0;
			case(state_q)
				  	   idle: if(key_tick) begin
									state_d=firstpair;
									x_cursor_d=0;									
								end
				 firstpair: if(mod_tick) begin  //forming the first pair
									din1_d={1'b0,in[0]};
									din2_d={1'b0,in[1]};
									din3_d={1'b0,in[2]};
									din4_d={1'b0,in[3]};		
									state_d=secondpair;
									end
				secondpair: if(mod_tick) begin // get the second pair and send it to ram
									we=1;
									din1_d={din1_q[0],in[0]};
									din2_d={din2_q[0],in[1]};
									din3_d={din3_q[0],in[2]};
									din4_d={din4_q[0],in[3]};		
									if(x_cursor_q==79) state_d=idle;
									else x_cursor_d=x_cursor_q+1;
								end
				   default: state_d=idle;
			endcase 
			
			//chooses which ram will be used in a given row (4 rows will be used for the 4 trace of square-wave inputs)
			case(pixel_y[8:6]) 
						0: begin 
								dout=dout_1;
								on=on1;
							end
						2: begin 
								dout=dout_2;
								on=on2;
							end
						4: begin
								dout=dout_3;
								on=on3;
							end
						6: begin
								dout=dout_4;
								on=on4;
							end
			endcase
			
		end
		
		
	  
	  assign font_bit=on && font_data[~pixel_x_q2[2:0]];
		
	  
	 //rgb logic 
	 always @* begin
		rgb=0;
		if(!video_on) 	rgb=0;
		else rgb=font_bit? 3'b010:3'b000;
	 end
	 
	 
	 //module instantiations
	 
	squarewave_rom m0
	(
		.clk(clk),
		.addr({dout,pixel_y[5:0]}), //7:6 for square-wave pattern , 5:0 for column address of that pattern
		.data(font_data)
    );
	
	dual_port_syn #(.ADDR_WIDTH(10),.DATA_WIDTH(3)) m1 //storage ram for trace 1
	(
		.clk(clk),
		.we(we),
		.din({1'b1,din1_q}), //write data
		.addr_a({3'd0,x_cursor_q}), //write addr
		.addr_b({pixel_y[8:6],pixel_x[9:3]}), //read addr
		.dout_a(),
		.dout_b({on1,dout_1}) //read data	
	);
	
	dual_port_syn #(.ADDR_WIDTH(10),.DATA_WIDTH(3)) m2 //storage ram for trace 2
	(
		.clk(clk),
		.we(we),
		.din({1'b1,din2_q}), //write data
		.addr_a({3'd2,x_cursor_q}), //write addr
		.addr_b({pixel_y[8:6],pixel_x[9:3]}), //read addr
		.dout_a(),
		.dout_b({on2,dout_2}) //read data	
	);
	
	dual_port_syn #(.ADDR_WIDTH(10),.DATA_WIDTH(3)) m3 //storage ram for trace 3
	(
		.clk(clk),
		.we(we),
		.din({1'b1,din3_q}), //write data
		.addr_a({3'd4,x_cursor_q}), //write addr
		.addr_b({pixel_y[8:6],pixel_x[9:3]}), //read addr
		.dout_a(),
		.dout_b({on3,dout_3}) //read data	
	);
	
	dual_port_syn #(.ADDR_WIDTH(10),.DATA_WIDTH(3)) m4 //storage ram for trace 4
	(
		.clk(clk),
		.we(we),
		.din({1'b1,din4_q}), //write data
		.addr_a({3'd6,x_cursor_q}), //write addr
		.addr_b({pixel_y[8:6],pixel_x[9:3]}), //read addr
		.dout_a(),
		.dout_b({on4,dout_4}) //read data	
	);
	
	debounce_explicit m5
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(!key),
		.db_level(),
		.db_tick(key_tick)
    );
	 


endmodule

module dual_port_syn //dual port synchronous ram(uses block ram resources)
	#(
		parameter ADDR_WIDTH=11, 
					 DATA_WIDTH=8
	)
	(
		input clk,
		input we, //if write:write data based on addr_a , if read:read data for both addr_a and addr_b
		input[DATA_WIDTH-1:0] din,
		input[ADDR_WIDTH-1:0] addr_a,addr_b,
		output[DATA_WIDTH-1:0] dout_a,dout_b	
	);
	
	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
	reg[ADDR_WIDTH-1:0] addr_a_q,addr_b_q;
	
	always @(posedge clk) begin
		if(we) ram[addr_a]<=din;
		addr_a_q<=addr_a;
		addr_b_q<=addr_b;	
	end
	assign dout_a=ram[addr_a_q];
	assign dout_b=ram[addr_b_q];
endmodule
",full_screen_gen.txt,FPGA_Book_Experiments\full_screen_gen.txt
"[Keyword]: greater_than_2bit

[Design Category]: Combinational Logic

[Design Function Description]:  
This design implements a 2-bit comparator that determines if the first 2-bit input `a` is greater than the second 2-bit input `b`. The output `gt` is asserted (set to 1) if `a` is greater than `b`.

[Input Signal Description]:  
- `a[1:0]`: A 2-bit input signal representing the first number to be compared.
- `b[1:0]`: A 2-bit input signal representing the second number to be compared.

[Output Signal Description]:  
- `gt`: A 1-bit output signal that is asserted (1) if the input `a` is greater than the input `b`, otherwise it is deasserted (0).


[Design Detail]:
`timescale 1ns / 1ps

module greater_than_2bit(
	input  wire[1:0] a,b,
	output wire gt
    );
	 
	 //signal declarations for terms in sum-of-product 
	 wire sp1,sp2,sp3,sp4,sp5,sp6;
	 
	 //use table as reference
	 assign sp1= !a[1] & a[0] & !b[1] & !b[0];
	 assign sp2= a[1] & !a[0] & !b[1] & !b[0];
	 assign sp3= a[1] & !a[0] & !b[1] & b[0];
	 assign sp4= a[1] & a[0] & !b[1] & !b[0];
	 assign sp5= a[1] & a[0] & !b[1] & b[0];
	 assign sp6= a[1] & a[0] & b[1] & !b[0];
	 
	 assign gt = sp1 || sp2 || sp3 || sp4 || sp5 || sp6;


endmodule
",greater_than_2bit.txt,FPGA_Book_Experiments\greater_than_2bit.txt
"[Keyword]: greater_than_4bit

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is designed to compare two 4-bit binary numbers and determine if the first number (a) is greater than the second number (b). It uses a hierarchical approach by dividing the 4-bit numbers into two 2-bit segments and comparing them separately.

[Input Signal Description]:
- a[3:0]: A 4-bit input signal representing the first number to be compared.
- b[3:0]: A 4-bit input signal representing the second number to be compared.

[Output Signal Description]:
- gt: A 1-bit output signal that is true (1) if the first number (a) is greater than the second number (b), otherwise false (0).


[Design Detail]:
`timescale 1ns / 1ps

module greater_than_4bit(
	input wire[3:0] a,b,
	output wire gt
    );
	 
	 wire[1:0] a1,a0,b1,b0 ; //a1=2 MSB of ""a"" input , a0=2 LSB of ""a"" input , b1=2 MSB of ""b"" input , b0=2 LSB of ""b"" input
	 wire gt1,gt0; //gt1=true if a1>b1 , g0=true if a0>b0
	 wire aeqb;
	 assign a1=a[3:2],
				a0=a[1:0],
				b1=b[3:2],
				b0=b[1:0];
				
	 //overall logic for 4-bit greater than circuit
	 assign gt=gt1 || (aeqb&&gt0);
	 
	 greater_than_2bit m0
	 (
		.a(a1),
		.b(b1),
		.gt(gt1)
    );
	 
	 greater_than_2bit m1
	 (
		.a(a0),
		.b(b0),
		.gt(gt0)
    );
	 
	 eq2 m2
	 (
		.a(a1),
		.b(b1), 
		.aeqb(aeqb) 
    );


endmodule
",greater_than_4bit.txt,FPGA_Book_Experiments\greater_than_4bit.txt
"[Keyword]: int_to_fp

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The circuit converts an 8-bit signed integer into a 13-bit floating-point representation. The floating-point format includes a sign bit, an 8-bit fraction, and a 4-bit exponent. The integer is normalized to fit into this floating-point format.

[Input Signal Description]:
integ[7:0]: An 8-bit signed integer input signal. The most significant bit (MSB) is the sign bit, and the remaining 7 bits represent the magnitude of the integer.

[Output Signal Description]:
fp[12:0]: A 13-bit floating-point output signal. The MSB is the sign bit, the next 4 bits represent the exponent, and the last 8 bits represent the fraction part of the floating-point number.


[Design Detail]:
`timescale 1ns / 1ps

module int_to_fp(
	input wire[7:0] integ,
	output reg[12:0] fp	
    );
	 integer i; 
	 reg finish;
	 
	 always @(integ) begin
	 fp=13'b0;
	 i=0;
	 finish=1'b0;
	 fp[12]=integ[7];  //sign bit of fp is same with integ
	 for(i=6;i>=0;i=i-1)   //find loc of first bit 1 in the integ
		 if(integ[i]==1'b1 && finish==1'b0) begin
		 	fp[7:0] = {1'b0,integ[6:0]}<<(7-i); //8 bit frac value of fp must be normalized so the first bit ""1""(excluding the signed bit) of integ must moved to 8th bit
			fp[11:8] = i+1;   // 4 bit exp value e.g. integ 0000_1111(i=3) willl become fp frac of .1111_0000 when normalized so an exp must be 3+1=4
			finish=1'b1;
		 end
	 end
	 


endmodule
",int_to_fp.txt,FPGA_Book_Experiments\int_to_fp.txt
"[Keyword]: kb

[Design Category]: Interface Circuits

[Design Function Description]:  
The design is a keyboard interface circuit that processes data received from a PS/2 keyboard. It extracts the real bytes from the received packets of data, excluding break codes, and stores them in a FIFO buffer for further processing.

[Input Signal Description]:  
- `clk`: Clock signal used for synchronization.  
- `rst_n`: Active-low reset signal to initialize the system.  
- `ps2d`: PS/2 data line input from the keyboard.  
- `ps2c`: PS/2 clock line input from the keyboard.  
- `rd_fifo`: Read enable signal for the FIFO buffer to retrieve data.

[Output Signal Description]:  
- `rd_data[8:0]`: 9-bit output data read from the FIFO buffer, representing the real bytes extracted from the PS/2 data.  
- `fifo_empty`: Signal indicating whether the FIFO buffer is empty.  
- `breakcode`: Signal indicating the detection of a break code in the data stream.






[Design Detail]:
`timescale 1ns / 1ps

module kb(   //extract only the real bytes from received packets of data(no break code)
	input clk,rst_n,
	input ps2d,ps2c,
	input rd_fifo,
	output [8:0] rd_data, //{shift,data}
	output fifo_empty
    );
	 wire[10:0] dout;
	 wire rx_dont_tick;
	 wire wr;
	 wire [8:0] wr_data;
	 
 
	 ps2_rx m0
	 (
		.clk(clk),
		.rst_n(rst_n),
		.rx_en(1),
		.ps2d(ps2d),
		.ps2c(ps2c),
		.dout(dout),
		.rx_done_tick(rx_done_tick)
    );
	 
	 kb_data m1
	 (
		.clk(clk),
		.rst_n(rst_n),
		.rx_done_tick(rx_done_tick),
		.din(dout[8:1]),
		.wr(wr),
		.wr_data(wr_data)
    );
	 
	  fifo #(.W(4),.B(9)) m2
	(
		.clk(clk),
		.rst_n(rst_n),
		.wr(wr),
		.rd(rd_fifo), //
		.wr_data(wr_data),
		.rd_data(rd_data),//
		.full(),
		.empty(fifo_empty) //
    );
	 
endmodule


",kb.txt,FPGA_Book_Experiments\kb.txt
"[Keyword]: kb_control_circuit

[Design Category]: Control Circuits

[Design Function Description]:  
This design is a keyboard control circuit that interfaces with a PS/2 device. It uses a finite state machine (FSM) to manage the state transitions for sending commands to control the Num Lock, Scroll Lock, and Caps Lock LEDs on a keyboard. The circuit detects button presses and sends corresponding commands to the PS/2 interface to toggle the LEDs.

[Input Signal Description]:  
- `clk`: Clock signal for synchronizing the circuit operations.  
- `rst_n`: Active-low reset signal to initialize the circuit.  
- `key0`, `key1`, `key2`: Input signals representing button presses to control Num Lock, Scroll Lock, and Caps Lock LEDs, respectively.  
- `ps2d`, `ps2c`: Bidirectional data and clock lines for the PS/2 interface.

[Output Signal Description]:  
- `ps2d`, `ps2c`: These are bidirectional signals used to communicate with the PS/2 device. They are used to send data and clock signals to the PS/2 interface.




[Design Detail]:
`timescale 1ns / 1ps

module kb_control_circuit(
	input clk,rst_n,
	input key0,key1,key2,
	inout ps2d,ps2c	
    );
	 //FSM state-declarations
	 localparam[1:0] idle=2'd0,
							byte1=2'd1,
							byte2=2'd2,
							done=2'd3;
	 reg[1:0] state_reg,state_nxt;
	 reg[3:0] hex_reg,hex_nxt;
	 reg wr_ps2;
	 reg[7:0] din;
	 wire tx_done_tick;
	 wire key0_tick,key1_tick,key2_tick;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=0;
			hex_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			hex_reg<=hex_nxt;
		end
	 end
	 
	 //FSM next-state logics
	 always @* begin
		state_nxt=state_reg;
		wr_ps2=0;
		din=0;
		hex_nxt=hex_reg;
		case(state_reg) 
		  	   idle: begin //wait for the tick of any button
							if(key0_tick) hex_nxt=4'b0010; //on num-lock led
							else if(key1_tick) hex_nxt=4'b0001; //on scroll-lock led
							else if(key2_tick) hex_nxt=4'b0100;//on caps-lock led
							if(key0_tick||key1_tick||key2_tick) state_nxt=byte1;
						end
			  byte1: begin //send first byte 
							din=8'hed;
							wr_ps2=1;
							if(tx_done_tick) state_nxt=byte2;
						end
			  byte2: begin //send second byte(contains the data on which led to turn on)
							din={4'h0,hex_reg};
							wr_ps2=1;
							if(tx_done_tick) state_nxt=done;
						end
			   done: state_nxt=idle;
			default: state_nxt=idle;
		endcase
	 end
	 
	 
	 
	 //module instantations
	ps2_tx m0
	(
		.clk(clk),
		.rst_n(rst_n),
		.wr_ps2(wr_ps2),
		.din(din),
		.ps2d(ps2d),
		.ps2c(ps2c),
		.tx_idle(),
		.tx_done_tick(tx_done_tick)
    );
	 
	 debounce_explicit m1
	 (
		.clk(clk),
		.rst_n(rst_n),
		.sw({!key0}),
		.db_level(),
		.db_tick(key0_tick)
    );
	 debounce_explicit m2
	 (
		.clk(clk),
		.rst_n(rst_n),
		.sw({!key1}),
		.db_level(),
		.db_tick(key1_tick)
    );
	 debounce_explicit m3
	 (
		.clk(clk),
		.rst_n(rst_n),
		.sw({!key2}),
		.db_level(),
		.db_tick(key2_tick)
    );


endmodule
",kb_control_circuit.txt,FPGA_Book_Experiments\kb_control_circuit.txt
"[Keyword]: kb_data

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a finite state machine (FSM) to process keyboard data received serially. It detects make and break codes from the keyboard, handles shift key detection for capital letters, and outputs the processed data along with a write signal.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the FSM operations.
- `rst_n`: Active-low reset signal to initialize the FSM to its idle state.
- `rx_done_tick`: Signal indicating the completion of receiving a byte from the keyboard.
- `din[7:0]`: 8-bit data input representing the received byte from the keyboard.

[Output Signal Description]:
- `wr`: Register output signal indicating when valid data is ready to be written.
- `wr_data[8:0]`: 9-bit output data where the 9th bit indicates if the shift key is pressed, and the lower 8 bits represent the received keyboard data.
- `break_code`: Signal indicating that the FSM is in the break code state, which occurs when a break code (0xF0) is detected.






[Design Detail]:
`timescale 1ns / 1ps

module kb_data(
	input clk,rst_n,
	input rx_done_tick,
	input[7:0] din,
	output reg wr,
	output reg[8:0] wr_data //9th bit is asserted if shift is pressed(for capital letters)
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							scan=2'd1,
							breakcode=2'd3;
	 reg[1:0] state_reg;
	 reg shift_reg=0;
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			shift_reg<=0;
		end
		
		else begin
		wr=0;
		wr_data=0;
			case(state_reg)
				idle: if(rx_done_tick) begin //wait for the makecode
							if(din==8'hf0) state_reg<=breakcode; //break code
							else begin
								if(din==8'h12 || din==8'h59) begin//shift key 
									shift_reg<=1;
									state_reg<=scan;
								end
								else begin//non-shift key
									wr_data={shift_reg,din};
									wr=1;
									state_reg<=scan;
								end
							end							
						 end
				scan: if(rx_done_tick) begin 
							if(din==8'hf0) state_reg<=breakcode; //break code
							else begin
								if(din==8'h12 || din==8'h59) shift_reg<=1; //shift key
								else begin //non-shift key
									wr_data={shift_reg,din};
									wr=1;
								end
							end
						end
		 breakcode: if(rx_done_tick) begin
							if(din==8'h12 || din==8'h59) shift_reg<=0; //end of shift key
							state_reg<=idle;	//skip the makecode after the breakcode 8'hf0 	
						end
			default: state_reg<=idle;
			endcase
		end
	 end
	 


endmodule
",kb_data.txt,FPGA_Book_Experiments\kb_data.txt
"[Keyword]: keyboard_text_ps2

[Design Category]: Interface Circuits

[Design Function Description]:
This design interfaces a PS/2 keyboard with a VGA display. It captures ASCII characters from the PS/2 keyboard and displays them on a VGA screen. The design includes a VGA controller to generate synchronization signals and a character generator to render the characters on the screen.

[Input Signal Description]:
- `clk`: Clock signal for the system.
- `rst_n`: Active-low reset signal to initialize the system.
- `ps2c`: PS/2 clock signal from the keyboard.
- `ps2d`: PS/2 data signal from the keyboard.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit red color output for VGA.
- `vga_out_g[5:0]`: 6-bit green color output for VGA.
- `vga_out_b[4:0]`: 5-bit blue color output for VGA.
- `vga_out_vs`: Vertical sync signal for VGA.
- `vga_out_hs`: Horizontal sync signal for VGA.


[Design Detail]:
`timescale 1ns / 1ps

module keyboard_text_ps2
	(
	input clk,rst_n,
	input ps2c,ps2d, //ascii characters will come from ps2 keboard
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 
	 
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;
	 

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	full_screen_gen m1 //generates the characters to be displayed on screen, the ASCII characters will come from ps2 keyboard
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.ps2c(ps2c),
		.ps2d(ps2d),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb)
    );
	
	 dcm_25MHz m2
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );      
	
endmodule

",keyboard_text_ps2.txt,FPGA_Book_Experiments\keyboard_text_ps2.txt
"[Keyword]: led_dimmer

[Design Category]: Sequential Logic

[Design Function Description]:  
The circuit is a PWM (Pulse Width Modulation) generator for dimming an LED. It uses a 4-bit resolution to control the duty cycle of the PWM signal, which is determined by the input `w`. The duty cycle is calculated as `w/16`, allowing for 16 different brightness levels.

[Input Signal Description]:  
- `clk`: Clock signal used to synchronize the operation of the circuit.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `en`: Enable signal to activate the PWM generation.
- `w[3:0]`: 4-bit input that determines the duty cycle of the PWM signal. The value of `w` sets the proportion of the time the PWM signal is high during each cycle.

[Output Signal Description]:  
- `pwm`: The PWM output signal that controls the brightness of the LED. The duty cycle of this signal is determined by the input `w`.


[Design Detail]:
`timescale 1ns / 1ps

module led_dimmer(
	input clk,rst_n,
	input en,
	input[3:0] w, //4-bit resolution. Duty cycle=w/16
	output pwm
    );
	 
	 reg[3:0] counter_reg=0;
	 reg pwm_reg=0;
	 wire[3:0] counter_nxt;
	 wire pwm_nxt;
	 wire max_tick;
	 
	 //registers
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
			counter_reg<=0;
			pwm_reg<=0;
		 end
		 else begin
			if(en) begin
			counter_reg<=counter_nxt;
			pwm_reg<=pwm_nxt;
			end
			else begin 
			counter_reg<=0;
			pwm_reg<=0;
			end
		 end
	 end
	 
	 //next-state logic for counter
	 assign counter_nxt=(counter_reg==4'd15)?0:counter_reg+1;
	 assign max_tick=(counter_reg==4'd15)?1:0;
	 
	 //next state logic for pwm_reg
	 assign pwm_nxt=max_tick? (w?1:0) : ((counter_nxt==w)?0:pwm_reg);//if w is logic 1 then the period will start with 1, but if w is zero then obviously it will start with 0
	 
	 //output
	 assign pwm=pwm_reg;
	 
	 


endmodule
",led_dimmer.txt,FPGA_Book_Experiments\led_dimmer.txt
"[Keyword]: LED_mux

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a multiplexer and display driver for a 7-segment LED display. It cycles through six different 6-bit input values, displaying each one on a 7-segment display. The inputs are selected based on a counter, and the selected input is decoded into a 7-segment display format. The design also includes a decimal point control.

[Input Signal Description]:
- `clk`: Clock signal used to drive the counter and synchronize the display updates.
- `rst`: Reset signal, active low, used to reset the counter to zero.
- `in0` to `in5`: Six 6-bit input signals, each representing a character to be displayed. The format is `{dp, char[4:0]}`, where `dp` is the decimal point control (active high), and `char[4:0]` is the character code.

[Output Signal Description]:
- `seg_out[7:0]`: 8-bit output signal for the 7-segment display. The lower 7 bits represent the segments (a-g) of the display, and the 8th bit controls the decimal point.
- `sel_out[5:0]`: 6-bit output signal used to select which input is currently being displayed. It is active low, meaning the selected input line is driven low.























[Design Detail]:
`timescale 1ns / 1ps

module LED_mux
	#(parameter N=19) //last 3 bits will be used as output. Frequency=50MHz/(2^(N-3)). So N=19 will have 763Hz
	(
	input clk,rst,
	input[5:0] in0,in1,in2,in3,in4,in5, //format: {dp,char[4:0]} , dp is active high
	output reg[7:0] seg_out,
	output reg[5:0] sel_out
    );
	 
	 reg[N-1:0] r_reg=0;
	 reg[5:0] hex_out=0;
	 wire[N-1:0] r_nxt;
	 wire[2:0] out_counter; //last 3 bits to be used as output signal
	 
	 
	 //N-bit counter
	 always @(posedge clk,negedge rst)
	 if(!rst) r_reg<=0;
	 else r_reg<=r_nxt;
	 
	 assign r_nxt=(r_reg=={3'd5,{(N-3){1'b1}}})?19'd0:r_reg+1'b1; //last 3 bits counts from 0 to 5(6 turns) then wraps around
	 assign out_counter=r_reg[N-1:N-3];
	 
	 
	 //sel_out output logic
	 always @(out_counter) begin
		 sel_out=6'b111_111;    //active low
		 sel_out[out_counter]=1'b0;
	 end
	  
	 //hex_out output logic
	 always @* begin
		 hex_out=0;
			 casez(out_counter)
			 3'b000: hex_out=in0;
			 3'b001: hex_out=in1;
			 3'b010: hex_out=in2;
			 3'b011: hex_out=in3;
			 3'b100: hex_out=in4;
			 3'b101: hex_out=in5;
			 endcase
	 end
	 	 
	 //hex-to-seg decoder
	 always @* begin
		 seg_out=0;
			 case(hex_out[4:0])
			 5'd0: seg_out[6:0]=7'b0000_001;
			 5'd1: seg_out[6:0]=7'b1001_111;
			 5'd2: seg_out[6:0]=7'b0010_010;
			 5'd3: seg_out[6:0]=7'b0000_110;
			 5'd4: seg_out[6:0]=7'b1001_100;
			 5'd5: seg_out[6:0]=7'b0100_100;
			 5'd6: seg_out[6:0]=7'b0100_000;
			 5'd7: seg_out[6:0]=7'b0001_111;
			 5'd8: seg_out[6:0]=7'b0000_000;
			 5'd9: seg_out[6:0]=7'b0001_100;
	  /*A*/5'd10: seg_out[6:0]=7'b0001_000; 
	  /*b*/5'd11: seg_out[6:0]=7'b1100_000;
	  /*C*/5'd12: seg_out[6:0]=7'b0110_001;
	  /*d*/5'd13: seg_out[6:0]=7'b1000_010;
	  /*E*/5'd14: seg_out[6:0]=7'b0110_000;
	  /*F*/5'd15: seg_out[6:0]=7'b0111_000;
	  /*G*/5'd16: seg_out[6:0]=7'b0100_000;
	  /*H*/5'd17: seg_out[6:0]=7'b1001_000;
	  /*I*/5'd18: seg_out[6:0]=7'b1111_001;
	  /*J*/5'd19: seg_out[6:0]=7'b1000_011;
	  /*L*/5'd20: seg_out[6:0]=7'b1110_001;
	  /*O*/5'd21: seg_out[6:0]=7'b0000_001;
	  /*P*/5'd22: seg_out[6:0]=7'b0011_000; 
	  /*R*/5'd23: seg_out[6:0]=7'b0001_000;
	  /*S*/5'd24: seg_out[6:0]=7'b0100_100;
	  /*U*/5'd25: seg_out[6:0]=7'b1000_001;
	  /*y*/5'd26: seg_out[6:0]=7'b1000_100;
	  /*Z*/5'd27: seg_out[6:0]=7'b0010_010; 
	/*OFF*/5'd28: seg_out[6:0]=7'b1111_111; //decimal 29 to 31 will be alloted for future use
			 endcase
		 seg_out[7]=!hex_out[5]; //active high decimal
	 end

endmodule
",LED_mux.txt,FPGA_Book_Experiments\LED_mux.txt
"[Keyword]: logic_analyzer

[Design Category]: Interface Circuits

[Design Function Description]:  
The design is a logic analyzer that captures and displays square-wave signals on a VGA display. It generates test square-wave signals at different frequencies (10kHz, 20kHz, 40kHz, and 100kHz) and displays input signals on a VGA screen using a VGA controller.

[Input Signal Description]:  
- `clk`: Clock input signal for the module.
- `rst_n`: Active-low reset signal to initialize the system.
- `key`: Input signal used for user interaction or control.
- `in_q[3:0]`: 4-bit input signal representing square-wave signals to be displayed on the VGA screen.

[Output Signal Description]:  
- `vga_out_r[4:0]`: 5-bit VGA red color output.
- `vga_out_g[5:0]`: 6-bit VGA green color output.
- `vga_out_b[4:0]`: 5-bit VGA blue color output.
- `vga_out_vs`: VGA vertical sync signal.
- `vga_out_hs`: VGA horizontal sync signal.
- `out_q[3:0]`: 4-bit output signal generating square-wave test signals at frequencies of 10kHz, 20kHz, 40kHz, and 100kHz.


[Design Detail]:
`timescale 1ns / 1ps

module logic_analyzer
	(
	input clk,rst_n,
	input key,
	input[3:0] in_q,//4-trace square-wave inputs to be displayed on screen via VGA
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs,
	output reg[3:0] out_q //square-wave output test-signal (10kHz , 20kHz , 40kHz , 100kHz)
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 wire clk_out;
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;
	 

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	full_screen_gen m1 //displays the four input square wave signals 
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.key(key),
		.in(in_q),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb)
    );
	
	 dcm_25MHz m2
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );    
		
	
	
	
	 //logic for free-running square test-signals 
	 reg[6:0] counter_100kHz=0; //mod_125 
	 reg[8:0] counter_40kHz=0; //mod_312
	 reg[9:0] counter_20kHz=0; //mod_625
	 reg[10:0] counter_10kHz=0; //mod_1250
	 
	 initial begin
		out_q=0;
	 end
	 
	 always @(posedge clk_out) begin
		counter_100kHz<=(counter_100kHz==124)? 0:counter_100kHz+1;
		counter_40kHz<=(counter_40kHz==311)? 0:counter_40kHz+1;
		counter_20kHz<=(counter_20kHz==624)? 0:counter_20kHz+1;
		counter_10kHz<=(counter_10kHz==1249)? 0:counter_10kHz+1;	 
		out_q[0] <= (counter_100kHz==0)? !out_q[0]:out_q[0]; //reverse the signal every restart of the free running counter to form a square
		out_q[1] <= (counter_40kHz==0)? !out_q[1]:out_q[1];
		out_q[2] <= (counter_20kHz==0)? !out_q[2]:out_q[2];
		out_q[3] <= (counter_10kHz==0)? !out_q[3]:out_q[3];
	 end
	 

endmodule

",logic_analyzer.txt,FPGA_Book_Experiments\logic_analyzer.txt
"[Keyword]: main_controller

[Design Category]: Control Circuits

[Design Function Description]:
The design is a main controller for a system that calculates and displays Fibonacci numbers. It uses a finite state machine (FSM) to manage the sequence of operations: counting, converting BCD to binary, calculating Fibonacci numbers, and converting binary to BCD for display on a 6-digit seven-segment display.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `sw1`: Switch to increase the Fibonacci input value.
- `sw2`: Switch to toggle between displaying the Fibonacci input or the output.

[Output Signal Description]:
- `seg_out[7:0]`: Output to drive the segments of the seven-segment display.
- `sel_out[5:0]`: Output to select which of the six seven-segment displays is active.


[Design Detail]:
`timescale 1ns / 1ps

module main_controller(
	input clk,rst_n,
	input sw1,sw2, //sw1=increase fibo input, sw2=display either the fibo input or the output
	output[7:0] seg_out,
	output[5:0] sel_out
    );
	 localparam[1:0] idle=2'd0,
							bcd2bin=2'd1,
							fibonacci=2'd2,
							bin2bcd=2'd3;
	 reg[1:0] state_reg,state_nxt;
	 reg start_bcd2bin,start_fibo,start_bin2bcd;
	 wire done_bcd2bin,done_fibo,done_bin2bcd;
	 wire[3:0] dig0_counter,dig1_counter;
	 wire [6:0] bin;
	 wire[20:0] fibo;
	 reg[3:0] dig0,dig1,dig2,dig3,dig4,dig5;
	 wire[3:0] dig0_bin,dig1_bin,dig2_bin,dig3_bin,dig4_bin,dig5_bin;
	 wire done_counter;
	 //FSM state declarations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) state_reg<=idle;
		else state_reg<=state_nxt;
	 end
	 
	 //FSM next-state logics
	 always @* begin
		state_nxt=state_reg;
		start_bcd2bin=0;
		start_fibo=0;
		start_bin2bcd=0;
		case(state_reg)
				idle: if(done_counter) begin
							start_bcd2bin=1;
							state_nxt=bcd2bin;
						end
			bcd2bin: if(done_bcd2bin) begin
							start_fibo=1;
							state_nxt=fibonacci;
						end
		 fibonacci: if(done_fibo) begin
							start_bin2bcd=1;
							state_nxt=bin2bcd;
						end
			bin2bcd: if(done_bin2bcd) state_nxt=idle;
			default: state_nxt=idle;
		endcase
	 end
	 always @* begin
		if(sw2) begin
			dig0=dig0_counter;
			dig1=dig1_counter;
			dig2=0;
			dig3=0;
			dig4=0;
			dig5=0;
		end
		else begin
			dig0=dig0_bin;
			dig1=dig1_bin;
			dig2=dig2_bin;
			dig3=dig3_bin;
			dig4=dig4_bin;
			dig5=dig5_bin;
		end
	 end

	 //instantiation of all module used
	bcd_counter m0 //mod-50 counter
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(sw1),
		.dig1(dig1_counter),
		.dig0(dig0_counter),
		.done_tick(done_counter)
    );
	 
	bcd2bin m1 //convert 2 digit to binary(0-to-49)
	(
		.clk(clk),
		.rst_n(rst_n),
		.start(start_bcd2bin),
		.dig1(dig1_counter),
		.dig0(dig0_counter),
		.bin(bin), 
		.ready(),
		.done_tick(done_bcd2bin)
    );
	 
	fibonacci m2 //outputs fibonacci value of bin(bin>29 will get ""999_999"" as a result)
	(
	.clk(clk),
	.rst_n(rst_n),
	.start(start_fibo),
	.i(bin),
	.fibo(fibo),
	.ready(),
	.done_tick(done_fibo)
    );
	 
	 bin2bcd m3( //convertes fibo binary to bcd
	.clk(clk),
	.rst_n(rst_n),
	.start(start_bin2bcd),
	.bin(fibo),//limit is 6 digit of bcd so only 19 bits of fibo will be considered
	.ready(),
	.done_tick(done_bin2bcd),
	.dig0(dig0_bin),
	.dig1(dig1_bin),
	.dig2(dig2_bin),
	.dig3(dig3_bin),
	.dig4(dig4_bin),
	.dig5(dig5_bin)
    );
	 
	 LED_mux m4 //bcd value will used as input to 6-seven-segment display
	(
	.clk(clk),
	.rst(rst_n),
	.in0(dig0),
	.in1(dig1),
	.in2(dig2),
	.in3(dig3),
	.in4(dig4),
	.in5(dig5), //format: {dp,hex[3:0]}
	.seg_out(seg_out),
	.sel_out(sel_out)
    );

endmodule
",main_controller.txt,FPGA_Book_Experiments\main_controller.txt
"[Keyword]: master_controller

[Design Category]: Control Circuits

[Design Function Description]:
The design is a master controller that manages a sequence of operations using a finite state machine (FSM). It processes an input signal to measure its period, performs division, converts binary to BCD, and adjusts the output to display the result on a 7-segment display. The controller transitions through different states to coordinate these operations and outputs the result on a 7-segment display.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations.
- `rst_n`: Active-low reset signal to initialize the FSM and other registers.
- `signal`: Input signal whose period is to be measured.
- `sw`: Switch input used to trigger the start of the FSM sequence. It is active low.

[Output Signal Description]:
- `seg_out[7:0]`: 8-bit output for the 7-segment display to show the digits.
- `sel_out[5:0]`: 6-bit output to select which digit is currently being displayed on the 7-segment display.
- `done_tick`: A register output that indicates the completion of the entire FSM sequence.


[Design Detail]:
`timescale 1ns / 1ps

module master_controller(
	input clk,rst_n,
	input signal,sw,
	output[7:0] seg_out,
	output[5:0] sel_out,
	output reg done_tick
    );
	 //FSMstate declarations
	 localparam[2:0] idle=3'd0,
							pcounter=2'd1,
							div=3'd2,
							bin2bcd=3'd3,
							adjust=3'd4;
	 reg[2:0] state_reg,state_nxt;
	 reg start_pcounter,start_div,start_bin2bcd,start_adjust;
	 wire done_pcounter,done_div,done_bin2bcd,done_adjust;
	 wire[19:0] period;
	 wire[36:0] bin;
	 wire[3:0] dig0,dig1,dig2,dig3,dig4,dig5,dig6,dig7,dig8,dig9,dig10;
	 wire[4:0] in0,in1,in2,in3,in4,in5;
	 wire signal_hi;
	 reg sw_reg;
	 wire sw_edg;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
				state_reg<=0;
				sw_reg<=0;
		 end
		 else begin
			state_reg<=state_nxt;
			sw_reg<=sw;
		 end
	 end
	 
	 //edge detector for ""sw""
	 assign sw_edg= !sw && sw_reg; //sw is active low
	 
	 
	 //FSM next-state logics
	 always @* begin
		start_pcounter=0;
		start_div=0;
		start_bin2bcd=0;
		start_adjust=0;
		state_nxt=state_reg;
		done_tick=0;
		case(state_reg) 
			    idle: if(sw_edg) begin
							start_pcounter=1;
							state_nxt=pcounter;
						 end
			pcounter: if(done_pcounter) begin
							start_div=1;
							state_nxt=div;
						 end
				  div: if(done_div) begin
							start_bin2bcd=1;
							state_nxt=bin2bcd;
						 end
			 bin2bcd: if(done_bin2bcd) begin
							start_adjust=1;
							state_nxt=adjust;
						 end
			  adjust: if(done_adjust) begin
							state_nxt=idle;
							done_tick=1;
						 end
			 default: state_nxt=idle;
		endcase
	 end
	 assign signal_hi=!signal;
	 //module declarations
	 period_counter m0
	 (
		.clk(clk),
		.rst_n(rst_n),
		.start(start_pcounter),
		.signal(signal_hi),
		.ready(),
		.done_tick(done_pcounter),
		.period(period) //limit of 1.023 seconds of period
    );
	 
	 div #(.W(37),.N(6)) m1 //W is the width of both dividend and divisor, N is the size of the register that stores binary value of W: N=log_2(W)+1
	(
		.clk(clk),
		.rst_n(rst_n),
		.start(start_div),
		.dividend(37'd10**11),
		.divisor({17'd0,period}),
		.quotient(bin),
		.remainder(),
		.ready(),
		.done_tick(done_div)
    );
	 
	 bin2bcd m2
	 (
		.clk(clk),
		.rst_n(rst_n),
		.start(start_bin2bcd),
		.bin(bin),//11 digit max of {11{9}}
		.ready(),
		.done_tick(done_bin2bcd),
		.dig0(dig0),
		.dig1(dig1),
		.dig2(dig2),
		.dig3(dig3),
		.dig4(dig4),
		.dig5(dig5),
		.dig6(dig6),
		.dig7(dig7),
		.dig8(dig8),
		.dig9(dig9),
		.dig10(dig10)
    );
	 
	 adjust m3 //outputs the six most significant digits with corresponding decimal
	 ( 
		.clk(clk),
		.rst_n(rst_n),
		.start(start_adjust),
		.dig0(dig0),
		.dig1(dig1),
		.dig2(dig2),
		.dig3(dig3),
		.dig4(dig4),
		.dig5(dig5),
		.dig6(dig6),
		.dig7(dig7),
		.dig8(dig8),
		.dig9(dig9),
		.dig10(dig10),
		.in0(in0),
		.in1(in1),
		.in2(in2),
		.in3(in3),
		.in4(in4),
		.in5(in5), //6 most significant digits 
		.done_tick(done_adjust)
    );
	 
	LED_mux m4
	(
		.clk(clk),
		.rst(rst_n),
		.in0(in0),
		.in1(in1),
		.in2(in2),
		.in3(in3),
		.in4(in4),
		.in5(in5),
		.seg_out(seg_out),
		.sel_out(sel_out)
    );


endmodule
",master_controller.txt,FPGA_Book_Experiments\master_controller.txt
"[Keyword]: mode_horizontal

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a video text display interface with cursor control. It allows the user to move a cursor horizontally and vertically across a display grid and write ASCII characters at the cursor's position. The design includes debouncing for input keys, a UART interface for receiving ASCII data, and a font ROM for character rendering.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `rx`: UART receive line for receiving ASCII data.
- `key[2:0]`: 3-bit input for cursor control and writing operations. `key[0]` moves the cursor right, `key[1]` moves the cursor down, and `key[2]` writes a new ASCII character at the current cursor position.
- `pixel_x[9:0]`: Horizontal pixel coordinate for the current video frame.
- `pixel_y[9:0]`: Vertical pixel coordinate for the current video frame.
- `video_on`: Signal indicating whether the video display is active.

[Output Signal Description]:
- `rgb[2:0]`: 3-bit RGB output for the video display, indicating the color of the current pixel. It changes based on the cursor position and the character being displayed.


[Design Detail]:
`timescale 1ns / 1ps

module mode_horizontal(
	input clk,rst_n,
	input rx,
	input[2:0] key, //key[0] to move cursor to right,key[1] to move cursor down,key[2] to write new ASCII character to current cursor
	input[9:0] pixel_x,pixel_y,
	input video_on,
	output reg[2:0] rgb
    );
	 
	 wire key0_tick,key1_tick,key2_tick;
	 wire[6:0] rd_data,ascii_char;
	 wire[7:0] font_data;
	 wire font_bit;
	 wire underline_on,cursor_on;
	 reg[4:0] y_cursor_q,y_cursor_d; 
	 reg[6:0] x_cursor_q,x_cursor_d;
	 reg[9:0] pixel_x_q,pixel_x_q2,pixel_y_q,pixel_y_q2; //buffer to delay the pixel_x and pixel_y by two clk times,
																					//retrieving data from syn_rom and syn_dualport_ram causes 2 clk
																							//delays so we need to delay the pixel_x and pixel_y by 2 clk delays too
																							
	 
	 //register operation to update current cursor
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			y_cursor_q<=0;
			x_cursor_q<=0;
			pixel_x_q<=0;
			pixel_x_q2<=0;
			pixel_y_q<=0;
			pixel_y_q2<=0;
		end
		else begin
			y_cursor_q<=y_cursor_d;
			x_cursor_q<=x_cursor_d;
			pixel_x_q<=pixel_x;
			pixel_x_q2<=pixel_x_q;
			pixel_y_q<=pixel_y;
			pixel_y_q2<=pixel_y_q;
		end
	 end
	 //combinational logic to update cursor position via pushbuttons
	 always @* begin
		x_cursor_d=x_cursor_q;
		y_cursor_d=y_cursor_q;
		if(key0_tick) x_cursor_d= (x_cursor_q<80)? x_cursor_q+1:0; //wrap around if beyond the display range(0-to-79 characters for x-axis)
		if(key1_tick) y_cursor_d= (y_cursor_q<30)? y_cursor_q+1:0;  //wrap around if beyond the display range(0-to-29 characters for y-axis)
	 end
	  
	  
	  assign font_bit=font_data[~pixel_x_q2[2:0]];
	  assign cursor_on= (pixel_y_q2[8:4]==y_cursor_q && pixel_x_q2[9:3]==x_cursor_q); //current cursor
	  assign underline_on= cursor_on && (pixel_y_q2[3:1]==3'b111); //current scan is at the last 2 rows of the current cursor
	  
	 //rgb logic 
	 always @* begin
		rgb=0;
		if(!video_on) 	rgb=0;
		else if(underline_on) rgb=3'b011; //underline the current cursor
		else rgb=font_bit? 3'b010:3'b000;
	 end
	 
	 
	 //module instantiations
	  uart #(.DBIT(8),.SB_TICK(16),.DVSR(326),.DVSR_WIDTH(9),.FIFO_W(10)) m0 //Baud rate of 4800 for a 25MHz clock
	(
		.clk(clk),
		.rst_n(rst_n),
		.rd_uart(key2_tick),
		.wr_uart(),
		.wr_data(),
		.rx(rx),
		.tx(),
		.rd_data(rd_data),
		.rx_empty(),
		.tx_full()
    );
	 
	 font_rom m1
   (
		.clk(clk),
		.addr({ascii_char,pixel_y[3:0]}), //[10:4] for ASCII char code, [3:0] for choosing what row to read on a given character  
		.data(font_data)
   );
	
	dual_port_syn #(.ADDR_WIDTH(12),.DATA_WIDTH(8)) m2
	(
		.clk(clk),
		.we(key2_tick),
		.din(rd_data), //write data
		.addr_a({y_cursor_q,x_cursor_q}), //write addr
		.addr_b({pixel_y[8:4],pixel_x[9:3]}), //read addr
		.dout_a(),
		.dout_b(ascii_char) //read data	
	);
	
	
	debounce_explicit m3
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[0]),
		.db_level(),
		.db_tick(key0_tick)//move right
    );
	 
	 
	debounce_explicit m4
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[1]),
		.db_level(),
		.db_tick(key1_tick)//move down
    );
	 
	debounce_explicit m5
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[2]),
		.db_level(),
		.db_tick(key2_tick)//write to current cursor
    );


endmodule

",mode_horizontal.txt,FPGA_Book_Experiments\mode_horizontal.txt
"[Keyword]: mode_vertical

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a video display controller that interfaces with a UART module to receive ASCII characters and display them on a screen. It allows cursor movement and character writing on a grid-based display, with the ability to underline the current cursor position.

[Input Signal Description]:
- `clk`: Clock signal for synchronization.
- `rst_n`: Active-low reset signal to initialize the system.
- `rx`: UART receive line for receiving data.
- `key[2:0]`: 3-bit input for controlling cursor movement and writing:
  - `key[0]`: Move cursor down.
  - `key[1]`: Move cursor right.
  - `key[2]`: Write new ASCII character at the current cursor position.
- `pixel_x[9:0]`, `pixel_y[9:0]`: Current pixel coordinates for display.
- `video_on`: Signal indicating if the video display is active.

[Output Signal Description]:
- `rgb[2:0]`: 3-bit RGB output for the display, indicating the color of the current pixel. It changes based on the cursor position and whether the underline is active.


[Design Detail]:
`timescale 1ns / 1ps

module mode_vertical(
	input clk,rst_n,
	input rx,
	input[2:0] key, //key[0] to move cursor to down,key[1] to move cursor right,key[2] to write new ASCII character to current cursor
	input[9:0] pixel_x,pixel_y,
	input video_on,
	output reg[2:0] rgb
    );
	 
	 wire key0_tick,key1_tick,key2_tick;
	 wire[6:0] rd_data,ascii_char;
	 wire[7:0] font_data;
	 wire font_bit;
	 wire underline_on,cursor_on;
	 reg[5:0] y_cursor_q,y_cursor_d; 
	 reg[5:0] x_cursor_q,x_cursor_d;
	 reg[9:0] pixel_x_q,pixel_x_q2,pixel_y_q,pixel_y_q2; //buffer to delay the pixel_x and pixel_y by two clk times,
																					//retrieving data from syn_rom and syn_dualport_ram causes 2 clk
																							//delays so we need to delay the pixel_x and pixel_y by 2 clk delays too
																							
	 
	 //register operation to update current cursor
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			y_cursor_q<=0;
			x_cursor_q<=0;
			pixel_x_q<=0;
			pixel_x_q2<=0;
			pixel_y_q<=0;
			pixel_y_q2<=0;
		end
		else begin
			y_cursor_q<=y_cursor_d;
			x_cursor_q<=x_cursor_d;
			pixel_x_q<=pixel_x;
			pixel_x_q2<=pixel_x_q;
			pixel_y_q<=pixel_y;
			pixel_y_q2<=pixel_y_q;
		end
	 end
	 //combinational logic to update cursor position via pushbuttons
	 always @* begin
		x_cursor_d=x_cursor_q;
		y_cursor_d=y_cursor_q;
		if(key0_tick) x_cursor_d= (x_cursor_q<40)? x_cursor_q+1:0; //wrap around if beyond the display range(0-to-39 characters for x-axis)
		if(key1_tick) y_cursor_d= (y_cursor_q<60)? y_cursor_q-1:59;  //wrap around if beyond the display range(0-to-59 characters for y-axis)
	 end
	  
	  
	  assign font_bit=font_data[pixel_y_q2[2:0]]; //use y_axis as column/bit address since char is tilted 90degress
	  assign cursor_on= (pixel_y_q2[8:3]==y_cursor_q && pixel_x_q2[9:4]==x_cursor_q); //current cursor locrion
	  assign underline_on= cursor_on && pixel_x_q2[3:1]==3'b111; //current scan is at the last 2 rows of the current cursor
	  
	 //rgb logic 
	 always @* begin
		rgb=0;
		if(!video_on) 	rgb=0;
		else if(underline_on) rgb=3'b011; //underline the current cursor
		else rgb=font_bit? 3'b010:3'b000;
	 end
	 
	 
	 //module instantiations
	  uart #(.DBIT(8),.SB_TICK(16),.DVSR(326),.DVSR_WIDTH(9),.FIFO_W(10)) m0 //Buad rate of 4800 for a 25MHz clock
	(
		.clk(clk),
		.rst_n(rst_n),
		.rd_uart(key2_tick),
		.wr_uart(),
		.wr_data(),
		.rx(rx),
		.tx(),
		.rd_data(rd_data),
		.rx_empty(),
		.tx_full()
    );
	 
	 font_rom m1
   (
		.clk(clk),
		.addr({ascii_char,pixel_x[3:0]}), //[10:4] for ASCII char code, [3:0] for choosing what row to read on a given character  
		.data(font_data)							//use pixel_x as row addr since char is tilted 90degress
   );
	
	dual_port_syn #(.ADDR_WIDTH(12),.DATA_WIDTH(8)) m2
	(
		.clk(clk),
		.we(key2_tick),
		.din(rd_data), //write data
		.addr_a({y_cursor_q,x_cursor_q}), //write addr
		.addr_b({pixel_y[8:3],pixel_x[9:4]}), //read addr
		.dout_a(),
		.dout_b(ascii_char) //read data	
	);
	
	
	debounce_explicit m3
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[0]),
		.db_level(),
		.db_tick(key0_tick)//move right
    );
	 
	 
	debounce_explicit m4
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[1]),
		.db_level(),
		.db_tick(key1_tick)//move down
    );
	 
	debounce_explicit m5
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[2]),
		.db_level(),
		.db_tick(key2_tick)//write to current cursor
    );


endmodule

module dual_port_syn
	#(
		parameter ADDR_WIDTH=11, 
					 DATA_WIDTH=8
	)
	(
		input clk,
		input we, //if write:write data based on addr_a , if read:read data for both addr_a and addr_b
		input[DATA_WIDTH-1:0] din,
		input[ADDR_WIDTH-1:0] addr_a,addr_b,
		output[DATA_WIDTH-1:0] dout_a,dout_b	
	);
	
	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
	reg[ADDR_WIDTH-1:0] addr_a_q,addr_b_q;
	
	always @(posedge clk) begin
		if(we) ram[addr_a]<=din;
		addr_a_q<=addr_a;
		addr_b_q<=addr_b;	
	end
	assign dout_a=ram[addr_a_q];
	assign dout_b=ram[addr_b_q];
endmodule
",mode_vertical.txt,FPGA_Book_Experiments\mode_vertical.txt
"[Keyword]: monitor

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a monitoring module that tracks and displays the state of a counter. It captures and logs the state of various control signals and the counter value at each clock cycle. The module checks if the counter's result matches the expected value and logs an error message if there is a discrepancy.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `syn_clr`: Synchronous clear signal to reset the counter to zero.
- `load`: Signal to load a new value into the counter.
- `en`: Enable signal to allow counting.
- `up`: Signal to determine the counting direction (up or down).
- `d[N-1:0]`: Data input for loading a new value into the counter.
- `q[N-1:0]`: Current value of the counter.
- `max_tick`: Signal indicating the counter has reached its maximum value.
- `min_tick`: Signal indicating the counter has reached its minimum value.

[Output Signal Description]:
There are no explicit output signals in this module. Instead, the module uses `$strobe` to log the state of the system, including the control signals, counter value, and any error messages.


[Design Detail]:
`timescale 1ns / 1ps

module monitor
	#(parameter N=3)
	(
	input clk,rst_n,
	input syn_clr,load,en,up,
	input[N-1:0] d,
	input[N-1:0] q,
	input max_tick,min_tick
    );
	 reg syn_clr_reg,load_reg,en_reg,up_reg,rst_reg;
	 reg[N-1:0] d_reg,result,q_reg;
	 reg[39:0] msg;
	 initial begin
		$display(""time sync_clr/load/en/up q result msg"");
	 end
	 always @(posedge clk) begin
		syn_clr_reg<=syn_clr;
		load_reg<=load;
		en_reg<=en;
		up_reg<=up;
		d_reg<=d;
		q_reg<=q;
		rst_reg<=1;
		msg=(result===q)?"" "":""ERROR"";
		$strobe(""%0d %b%b%b%b %0d %0d %s"",$time,syn_clr,load,en,up,q,result,msg);
	 end
	 
	 always @* begin
		if(!rst_n) rst_reg=0;
		if(!rst_reg) result=0;
		else begin
			if(syn_clr_reg) result=0;
			else if(load_reg) result=d;
			else if(en_reg && up_reg) result=q_reg+1;
			else if(en_reg && !up_reg) result=q_reg-1;
			else result=q_reg;
		end
	 end
	 
endmodule
",monitor.txt,FPGA_Book_Experiments\monitor.txt
"[Keyword]: mouse

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a PS/2 mouse interface circuit. It communicates with a PS/2 mouse to receive movement data (x and y coordinates) and button status. The circuit processes the data packets from the mouse and outputs the current position and button states.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `ps2c`: PS/2 clock line, used for communication with the mouse.
- `ps2d`: PS/2 data line, used for communication with the mouse.

[Output Signal Description]:
- `x[8:0]`: 9-bit output representing the x-coordinate movement data from the mouse.
- `y[8:0]`: 9-bit output representing the y-coordinate movement data from the mouse.
- `btn[2:0]`: 3-bit output representing the status of the mouse buttons.
- `m_done_tick`: A signal indicating that a complete data packet has been received and processed.









[Design Detail]:
`timescale 1ns / 1ps

module mouse(
	input clk,rst_n,
	inout ps2c,ps2d,
	output[8:0] x,y,
	output[2:0] btn,
	output reg m_done_tick
    );
	 
	 //FSM state-declarations
	 localparam[2:0] idle=3'd0,
							response=3'd1,
							byte1=3'd2,
							byte2=3'd3,
							byte3=3'd4,
							done=3'd5;
	 reg[2:0] state_reg,state_nxt;
	 reg[8:0] x_reg,x_nxt;
	 reg[8:0] y_reg,y_nxt;
	 reg[2:0] btn_reg,btn_nxt;
	 reg wr_ps2;
	 
	 wire[7:0] rx_data;
	 wire[10:0] dout;
	 wire rx_done_tick,tx_done_tick;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			x_reg<=0;
			y_reg<=0;
			btn_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			x_reg<=x_nxt;
			y_reg<=y_nxt;
			btn_reg<=btn_nxt;
		end
	 end
	 //FSM nexr-state logics
	 always @* begin
		state_nxt=state_reg;
		x_nxt=x_reg;
		y_nxt=y_reg;
		btn_nxt=btn_reg;
		wr_ps2=0;
		m_done_tick=0;
		case(state_reg)
			   idle: begin //transmit code F4 for enable stream
							wr_ps2=1;
							if(tx_done_tick==1) state_nxt=response;
						end
			response: if(rx_done_tick==1) state_nxt=byte1;//wait for the acknowledge response FE
			  byte1: if(rx_done_tick==1) begin //first packet
							x_nxt[8]=rx_data[5]; //4
							y_nxt[8]=rx_data[6]; //5
							btn_nxt=rx_data[3:1]; //2:0
							state_nxt=byte2;
						end
			  byte2: if(rx_done_tick==1) begin //2nd packet
							x_nxt[7:0]=rx_data;
							state_nxt=byte3;
						end
			  byte3: if(rx_done_tick==1) begin //3rd packet
							y_nxt[7:0]=rx_data;
							state_nxt=done;
						end
			   done: begin
							m_done_tick=1;
							state_nxt=byte1;
						end
			default: state_nxt=idle;
		endcase
	 end
	 
	ps2_rxtx m0
	(
		.clk(clk),
		.rst_n(rst_n),
		.din({8'hf4}), //transmitted data is always F4(enable stream mode of mouse)
		.wr_ps2(wr_ps2),
		.ps2d(ps2d),
		.ps2c(ps2c),
		.dout(dout), //11bit-data received from rx
		.rx_done_tick(rx_done_tick),
		.tx_done_tick(tx_done_tick)
    );
	 assign rx_data=dout[8:1]; //real data extracted(no start,parity,and stop bits)
	 
	 assign x=x_reg;
	 assign y=y_reg;
	assign btn=btn_reg;
	 
	 
	
	


endmodule
",mouse.txt,FPGA_Book_Experiments\mouse.txt
"[Keyword]: Multi_Barrel_Shifter8x16x32x

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a multi-barrel shifter that can perform left or right shifts on input data of varying bit widths (8, 16, or 32 bits). The specific bit width is determined by the parameter N, and the amount of shift is determined by the parameter M. The direction of the shift (left or right) is controlled by the LR input signal.

[Input Signal Description]:
- num[N-1:0]: The input data to be shifted, where N can be 8, 16, or 32 bits based on the parameter setting.
- amt[M-1:0]: The amount by which the input data should be shifted. The width M is typically set to log2(N) to accommodate the maximum shift amount.
- LR: A control signal that determines the direction of the shift. A typical convention is that a value of 0 might indicate a left shift, and a value of 1 might indicate a right shift.

[Output Signal Description]:
- out[N-1:0]: The shifted output data, which is the result of shifting the input data 'num' by 'amt' positions in the direction specified by 'LR'.


[Design Detail]:
`timescale 1ns / 1ps

module Multi_Barrel_Shifter8x16x32x    //adjust param M and N for 8,16,or 32 bits
#( parameter N=32,
   parameter M=5)
	(  input wire[N-1:0] num,
		input wire[M-1:0] amt,
		input wire LR,
		output wire[N-1:0] out	
		 );
		 generate 
			if(N==8) barrel_shifter_8 m0(num,amt,LR,out);
			else if(N==16) barrel_shifter_16 m1(num,amt,LR,out);
			else if(N==32) barrel_shifter_32 m2(num,amt,LR,out);			
		 endgenerate

endmodule
",Multi_Barrel_Shifter8x16x32x.txt,FPGA_Book_Experiments\Multi_Barrel_Shifter8x16x32x.txt
"[Keyword]: parking_lot_counter

[Design Category]: Sequential Logic

[Design Function Description]:  
This design implements a finite state machine (FSM) to control a parking lot entry and exit system. It detects the sequence of signals from sensors (a and b) to determine whether a car is entering or exiting the parking lot. The FSM transitions through various states to ensure the correct sequence of events before confirming an entry or exit.

[Input Signal Description]:  
- `clk`: Clock signal used to synchronize the state transitions of the FSM.
- `rst_n`: Active-low reset signal to initialize the FSM to the start state.
- `a`: Sensor input signal indicating the presence of a car at a specific point in the entry/exit path.
- `b`: Sensor input signal indicating the presence of a car at another specific point in the entry/exit path.

[Output Signal Description]:  
- `enter`: Output signal that is asserted when a car has successfully entered the parking lot.
- `exit`: Output signal that is asserted when a car has successfully exited the parking lot.


[Design Detail]:
`timescale 1ns / 1ps

module parking_lot_counter(
	input clk,rst_n,
	input a,b,
	output reg enter,exit
    );
	 //FSM declarations
	 localparam[3:0] start=4'd0,
					enter1=4'd1,
					enter2=4'd2,
					enter3=4'd3,
					entered=4'd4,
					exit1=4'd5,
					exit2=4'd6,
					exit3=4'd7,
					exited=4'd8;
	 reg[3:0] state_reg,state_nxt;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) state_reg<=start;
		else state_reg<=state_nxt;
	 end
	 
	 //FSM next-state and output logics
	 always @* begin
		state_nxt=state_reg;
		enter=0;
		exit=0;
			case(state_reg)
		/*00*/	start: if(a && !b) state_nxt=enter1;
								else if(!a && b) state_nxt=exit1;
		/*10*/	enter1: if(!a && !b) state_nxt=start;
								else if(a && b) state_nxt=enter2;
		/*11*/	enter2: if(a && !b) state_nxt=enter1;
								else if(!a && b)  state_nxt=enter3;
		/*01*/	enter3: if(a && b) state_nxt=enter2;
								else if(!a && !b) state_nxt=entered;
		/*00*/	entered: begin 
									enter=1;
									state_nxt=start;
								end
		/*01*/	exit1: if(!a && !b) state_nxt=start;
								else if(a && b) state_nxt=exit2;
		/*11*/	exit2: if(!a && b) state_nxt=exit1;
								else if(a && !b) state_nxt=exit3;
		/*10*/	exit3: if(a && b) state_nxt=exit2;
								else if(!a && !b) state_nxt=exited;
		/*00*/	exited: begin
									exit=1;
									state_nxt=start;
							  end
					default: state_nxt=start;
			endcase
					
	 end
					


endmodule
",parking_lot_counter.txt,FPGA_Book_Experiments\parking_lot_counter.txt
"[Keyword]: period_counter

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a period counter that measures the time period of a signal in microseconds. It uses a finite state machine (FSM) to detect the rising edge of the input signal and counts the time between consecutive rising edges. The period is output in terms of microseconds, with a maximum measurable period of 1.023 seconds.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the FSM.
- `rst_n`: Active-low reset signal to initialize the FSM and registers.
- `start`: Signal to initiate the period measurement process.
- `signal`: Input signal whose period is to be measured.

[Output Signal Description]:
- `ready`: Indicates that the FSM is in the idle state and ready to start a new measurement.
- `done_tick`: Indicates that the period measurement is complete.
- `period[19:0]`: 20-bit output representing the measured period in microseconds.


[Design Detail]:
`timescale 1ns / 1ps

module period_counter(
		input clk,rst_n,
		input start,signal,
		output reg ready,done_tick,
		output [19:0] period //limit of 1.023 seconds of period
    );
	 
	 //FSM declarations
	 localparam[1:0] idle=2'd0,
							waiting=2'd1,
							op=2'd2,
							done=2'd3;
	 localparam N=50; // N/50Mhz=1us	
	 reg[1:0] state_reg,state_nxt;
	 reg[19:0] period_reg,period_nxt; // records period in terms of us
	 reg[5:0] tick_reg,tick_nxt; //ticks for every 1us (width of tick_reg is log_2(N))
	 reg signal_reg;
	 wire edg;
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			period_reg<=0;
			tick_reg<=0;
			signal_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			period_reg<=period_nxt;
			tick_reg<=tick_nxt;
			signal_reg<=signal;
		end
	 end
	 
	 //FSM next-state logic
	 always @* begin
		state_nxt=state_reg;
		period_nxt=period_reg;
		tick_nxt=tick_reg;
		ready=0;
		done_tick=0;
		case(state_reg) 
				idle: begin //rest
							ready=1;
							if(start) begin
								period_nxt=0;
								tick_nxt=0;
								state_nxt=waiting;
							end
						end
			waiting: begin //waiting for rising edge
							if(edg) //rising edge-detector
								state_nxt=op;
						end
				  op: begin //counting the number of ms then stop when rising edge is detected again
							if(edg) state_nxt=done;
							else begin
								if(tick_reg==N-1) begin
									tick_nxt=0;
									period_nxt=period_reg+1;
								end
								else tick_nxt=tick_reg+1;	
							end
						end
				done: begin
							done_tick=1;
							state_nxt=idle;
						end
			default: state_nxt=idle;
		endcase
	 end
	 
	 //rising-edge detector circuit
	 assign edg=signal && !signal_reg;
	 
	 
	 
	 //output combi-logic
	 assign period=period_reg;
	 
	 


endmodule 
",period_counter.txt,FPGA_Book_Experiments\period_counter.txt
"[Keyword]: pong_animated

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple Pong game animation. It includes a paddle (bar) that the player can move up and down to bounce a ball back towards a series of walls. The game tracks the ball's position, detects collisions with the walls and paddle, and updates the game state accordingly. The game can be paused or restarted, and it indicates when the player misses the ball or wins by breaking all the walls.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the game logic.
- `rst_n`: Active-low reset signal to initialize the game state.
- `video_on`: Signal indicating whether the video display is active.
- `pause`: Signal to pause the game when the ball is missed.
- `restart`: Signal to restart the game at the beginning of a new game.
- `key[1:0]`: 2-bit input for controlling the paddle movement (up and down).
- `pixel_x[11:0]`: Horizontal pixel coordinate for rendering.
- `pixel_y[11:0]`: Vertical pixel coordinate for rendering.

[Output Signal Description]:
- `rgb[2:0]`: 3-bit output for the RGB color value of the current pixel.
- `miss`: Signal indicating the ball went past the paddle (player missed).
- `won`: Signal indicating the player won by breaking all the walls.
- `graph_on`: Signal indicating whether any game element (walls, paddle, ball) is being drawn on the screen.





[Design Detail]:
`timescale 1ns / 1ps

module pong_animated
	(
		input clk,rst_n,
		input video_on,
		input pause,restart, //pause=stop state after missing a ball , restart=stop state at the beginning of new game
		input[1:0] key,
		input[11:0] pixel_x,pixel_y,
		output reg[2:0] rgb,
		output reg miss,won, //miss=ball went past the paddle , won=when ball went past the left border
		output graph_on
    );	
	 localparam wall_1_XL=100, //wall 1
					wall_1_XR=105,					
					wall_2_XL=110, //wall 2
					wall_2_XR=115, 
					wall_3_XL=120, //wall 3
					wall_3_XR=125, 
					wall_4_XL=130, //wall 4
					wall_4_XR=135, 
					wall_5_XL=140, //wall 5
					wall_5_XR=145, 
					
					brick_space=3,
					
					bar_XL=550, //left
					bar_XR=555, //right
					bar_LENGTH=80, //bar length
					bar_V=4, //bar velocity
					
					ball_DIAM=7, //ball diameter-1
					ball_V=7; //ball velocity

					
	 wire wall_1_on,wall_2_on,wall_3_on,wall_4_on,wall_5_on,bar_on,ball_box;
	 reg ball_on;
	 reg[2:0] rom_addr; //rom for circular pattern of ball
	 reg[7:0] rom_data;
	 reg[9:0] bar_top_q=220,bar_top_d; //stores upper Y value of bar,controlled by key[0] and key[1]
	 reg[9:0] ball_x_q=280,ball_x_d; //stores left X value of the bouncing ball
	 reg[9:0] ball_y_q=200,ball_y_d; //stores upper Y value of the bouncing ball
	 reg ball_xdelta_q=1,ball_xdelta_d;
	 reg ball_ydelta_q=1,ball_ydelta_d;
	 reg hold_q=0,hold_d; //make sure no consecutive bounces fromm wall happens or else all wall will vanish instantly
	 reg[4:0] wall_q=5'b111_11,wall_d; //5 bits which acts like the 5 walls. Shift left every time a ""wall"" is broken

	 //display conditions															//inside ""!"" statement is for brick spacing to make it look more like a brick rather than a wall
	 assign wall_1_on= wall_1_XL<=pixel_x && pixel_x<=wall_1_XR && !( (120<=pixel_y && pixel_y<=125) || (240<=pixel_y && pixel_y<=245) || (360<=pixel_y && pixel_y<=365)); 
	 assign wall_2_on= wall_2_XL<=pixel_x && pixel_x<=wall_2_XR && !( (60<=pixel_y && pixel_y<=65) || (180<=pixel_y && pixel_y<=185) || (300<=pixel_y && pixel_y<=305) || (420<=pixel_y && pixel_y<=425));
	 assign wall_3_on= wall_3_XL<=pixel_x && pixel_x<=wall_3_XR && !( (120<=pixel_y && pixel_y<=125) || (240<=pixel_y && pixel_y<=245) || (360<=pixel_y && pixel_y<=365)); 
	 assign wall_4_on= wall_4_XL<=pixel_x && pixel_x<=wall_4_XR && !( (60<=pixel_y && pixel_y<=65) || (180<=pixel_y && pixel_y<=185) || (300<=pixel_y && pixel_y<=305) || (420<=pixel_y && pixel_y<=425));
	 assign wall_5_on= wall_5_XL<=pixel_x && pixel_x<=wall_5_XR && !( (120<=pixel_y && pixel_y<=125) || (240<=pixel_y && pixel_y<=245) || (360<=pixel_y && pixel_y<=365)); 
	 assign bar_on= bar_XL<=pixel_x && pixel_x<=bar_XR && bar_top_q<=pixel_y && pixel_y<=(bar_top_q+bar_LENGTH);
	 assign ball_box= ball_x_q<=pixel_x && pixel_x<=(ball_x_q+ball_DIAM) &&  ball_y_q<=pixel_y && pixel_y<=(ball_y_q+ball_DIAM);

	 //circular ball_on logic
	 always @* begin
		rom_addr=0;
		ball_on=0;
		if(ball_box) begin
			rom_addr=pixel_y-ball_y_q;
			if(rom_data[pixel_x-ball_x_q]) ball_on=1;
		end
	 end
	 
	 //ball rom pattern
	 always @* begin
		 case(rom_addr)
			3'd0: rom_data=8'b0001_1000;
			3'd1: rom_data=8'b0011_1100;
			3'd2: rom_data=8'b0111_1110;
			3'd3: rom_data=8'b1111_1111;
			3'd4: rom_data=8'b1111_1111;
			3'd5: rom_data=8'b0111_1110;
			3'd6: rom_data=8'b0011_1100;
			3'd7: rom_data=8'b0001_1000;
		 endcase
	 end
	 
	 
	 //logic for movable bar and self-bouncing ball
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			bar_top_q<=220;
			ball_x_q<=280;
			ball_y_q<=200;
			ball_xdelta_q<=1;
			ball_xdelta_q<=1;
			wall_q<=5'b111_11;
			hold_q<=0;
		end
		else begin
			bar_top_q<=bar_top_d;
			ball_x_q<=ball_x_d;
			ball_y_q<=ball_y_d;
			ball_xdelta_q<=ball_xdelta_d;
			ball_ydelta_q<=ball_ydelta_d;
			wall_q<=wall_d;
			hold_q<=hold_d;
		end
	 end
	 always @* begin
		bar_top_d=bar_top_q;
		ball_x_d=ball_x_q;
		ball_y_d=ball_y_q;
		ball_xdelta_d=ball_xdelta_q;
		ball_ydelta_d=ball_ydelta_q;
		wall_d=wall_q;
		hold_d=hold_q;
		miss=0;
		won=0;
		//midgame-pause or newgame-restart
		if(pause || restart) begin
			ball_x_d=160;
			ball_y_d=240;
			bar_top_d=200;
			ball_xdelta_d=1;
			ball_ydelta_d=0;
			if(restart) wall_d=5'b111_11; //the 5 walls are restored
		end
		
		else if(pixel_y==500 && pixel_x==0) begin//1 tick when video is surely off
			//bar movement logic
			if(!key[0] && bar_top_q>bar_V) bar_top_d=bar_top_q-bar_V; //move bar up
			else if(!key[1] && bar_top_q<(480-bar_LENGTH)) bar_top_d=bar_top_q+bar_V; //move bar down
			
			//bouncing ball logic
			if(ball_x_q<=wall_5_XR) begin
				if(!hold_q && ball_xdelta_q==0) begin
					case(wall_q)
						5'b111_11: if(ball_x_q<=wall_5_XR)begin	
												ball_xdelta_d=1; //bounce from wall 5
												wall_d=wall_q<<1;
												hold_d=1;
									  end
						5'b111_10: if(ball_x_q<=wall_4_XR)begin
											ball_xdelta_d=1; //bounce from wall 4
											wall_d=wall_q<<1;
											hold_d=1;
									  end
						5'b111_00: if(ball_x_q<=wall_3_XR) begin
											ball_xdelta_d=1; //bounce from wall 3
											wall_d=wall_q<<1;
											hold_d=1;
									  end
						5'b110_00: if(ball_x_q<=wall_2_XR) begin
											ball_xdelta_d=1; //bounce from wall 4
											wall_d=wall_q<<1;
											hold_d=1;
									  end
						5'b100_00: if(ball_x_q<=wall_1_XR) begin
											ball_xdelta_d=1; //bounce from wall 4
											wall_d=wall_q<<1;
											hold_d=1;
									  end
					endcase

				end
			end
			else hold_d=0;
			
			if(ball_x_q>=640 && ball_xdelta_q) miss=1; //ball that went past the right border and moving rightward implies that the player misses the ball
			else if(ball_x_q>=640 && !ball_xdelta_q) won=1; //ball that went past the right border and moving leftward implies that the ball wrap around 
																					//after the player broke all th walls, thus player won
			
			if( (bar_XL<=(ball_x_q+ball_DIAM) && (ball_x_q+ball_DIAM)<=bar_XR && bar_top_q<=(ball_y_q+ball_DIAM)) && ball_y_q<=(bar_top_q+bar_LENGTH)) ball_xdelta_d=0; //bounce from bar
			if(ball_y_q<=5) ball_ydelta_d=1; //bounce from top
			else if(480<=(ball_y_q+ball_DIAM)) ball_ydelta_d=0; //bounce from bottom
			
			ball_x_d=ball_xdelta_d? (ball_x_q+ball_V):(ball_x_q-ball_V);
			ball_y_d=ball_ydelta_d? (ball_y_q+ball_V):(ball_y_q-ball_V);
			
		end
	 end
	 
	 assign graph_on=	 (wall_1_on && wall_q[4]) || (wall_2_on && wall_q[3]) || (wall_3_on && wall_q[2]) || (wall_4_on && wall_q[1]) || (wall_5_on && wall_q[0]) || bar_on || ball_on;
	 //overall display logic
	always @* begin
	 	rgb=0;
		if(video_on) begin
			if(wall_1_on && wall_q[4]) rgb=3'b100;
			else if(wall_2_on && wall_q[3]) rgb=3'b101;
			else if(wall_3_on && wall_q[2]) rgb=3'b001;
			else if(wall_4_on && wall_q[1]) rgb=3'b010;
			else if(wall_5_on && wall_q[0]) rgb=3'b111;
			else if(bar_on) rgb=3'b010;
			else if(ball_on) rgb=3'b000;
			else rgb=3'b011; //background color
		end
	 end
					
endmodule

",pong_animated.txt,FPGA_Book_Experiments\pong_animated.txt
"[Keyword]: pong_text

[Design Category]: Interface Circuits

[Design Function Description]:
This design is a text display module for a Pong game, responsible for rendering various text elements on the screen, such as the game logo, ball count, game over message, win message, and game rules. It uses pixel coordinates to determine which text to display and where, and it outputs the corresponding RGB values for the text.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing operations.
- `rst_n`: Active-low reset signal to initialize the module.
- `video_on`: Signal indicating whether the video display is active.
- `won`: Signal indicating if the player has won the game.
- `pixel_x[9:0]`: 10-bit horizontal pixel coordinate.
- `pixel_y[9:0]`: 10-bit vertical pixel coordinate.
- `ball[2:0]`: 3-bit signal representing the number of balls left.

[Output Signal Description]:
- `rgb_text[2:0]`: 3-bit RGB output for the text color to be displayed.
- `text_on[4:0]`: 5-bit signal indicating which text elements are currently active (logo, ball, game over, win, rule).



[Design Detail]:
`timescale 1ns / 1ps

module pong_text(
	input clk,rst_n,
	input video_on,
	input won,
	input[9:0] pixel_x,pixel_y,
	input[2:0] ball,
	output reg[2:0] rgb_text,
	output[4:0] text_on
    );
	 
	 reg logo_on,ball_on,gameover_on,rule_on,win_on;
	 reg[6:0] ascii_code,ascii_code_logo,ascii_code_ball,ascii_code_over,ascii_code_rule,ascii_code_win;
	 reg[3:0] row_addr,row_addr_logo,row_addr_ball,row_addr_over,row_addr_rule,row_addr_win;
	 wire[7:0] row_data;
	 reg[2:0] bit_column,bit_column_logo,bit_column_ball,bit_column_over,bit_column_rule,bit_column_win;
	 reg[5:0] bit_column_temp;
	 

	  //control logic for all text on the game
	 always @* begin
		 logo_on=0;
		 ball_on=0;
		 gameover_on=0;
		 rule_on=0;
		 win_on=0;
		 row_addr_logo=0;
		 row_addr_ball=0;
		 row_addr_over=0;
		 row_addr_rule=0;
		 row_addr_win=0;
		 bit_column_logo=0;
		 bit_column_ball=0;
		 bit_column_over=0;
		 bit_column_rule=0;
		 bit_column_win=0;
		 ascii_code_logo=0;
		 ascii_code_ball=0;
		 ascii_code_over=0;
		 ascii_code_rule=0;
		 ascii_code_win=0;
		 bit_column_temp=0;
		 
			//logo text logic (64x128 char size), ""BreakOut""
			logo_on= (pixel_x[9:0]>=64 && pixel_x[9:0]<=575 && pixel_y[8:7]==2);
			row_addr_logo=pixel_y[6:3];
			if(pixel_x[9:0]<=127) begin
				ascii_code_logo=8'h42;//B
				bit_column_temp=pixel_x[9:0]-64;
			end
			else if(pixel_x[9:0]<=191) begin
				ascii_code_logo=8'h72 ;//r
				bit_column_temp=pixel_x[9:0]-128;
			end
			else if(pixel_x[9:0]<=255) begin
				ascii_code_logo=8'h65 ;//e
				bit_column_temp=pixel_x[9:0]-192;
			end
			else if(pixel_x[9:0]<=319) begin
				ascii_code_logo=8'h61 ;//a
				bit_column_temp=pixel_x[9:0]-256;
			end
			else if(pixel_x[9:0]<=383) begin
				ascii_code_logo=8'h6b ;//k
				bit_column_temp=pixel_x[9:0]-320;
			end
			else if(pixel_x[9:0]<=447) begin
				ascii_code_logo=8'h4f ;//O
				bit_column_temp=pixel_x[9:0]-384;
			end
			else if(pixel_x[9:0]<=511) begin
				ascii_code_logo=8'h75 ;//u
				bit_column_temp=pixel_x[9:0]-448;
			end
			else if(pixel_x[9:0]<=575) begin
				ascii_code_logo=8'h74 ;//t
				bit_column_temp=pixel_x[9:0]-512;
			end
			bit_column_logo=bit_column_temp[5:3];

			
			//ball text logic(16x32 char size) , ""BALL:_""
			ball_on =(pixel_x[9:7]==2 && pixel_y[8:5]==0);
			row_addr_ball=pixel_y[4:1];
			bit_column_ball=pixel_x[3:1];
			case(pixel_x[6:4])
				3'o0: ascii_code_ball=0; //
				3'o1: ascii_code_ball=8'h42; //B
				3'o2: ascii_code_ball=8'h41; //A
				3'o3: ascii_code_ball=8'h4c; //L
				3'o4: ascii_code_ball=8'h4c; //L
				3'o5: ascii_code_ball=8'h3a; //:
				3'o6: ascii_code_ball={4'b0110,ball}; //ball left
				3'o7: ascii_code_ball=0; //
			endcase		
			
			//gameover text logic(32x64 char size) , ""GAME OVER""
			gameover_on= (pixel_y[8:6]==3 && pixel_x[9:5]>=5 && pixel_x[9:5]<=13);
			row_addr_over=pixel_y[5:2];
			bit_column_over=pixel_x[4:2];
			case(pixel_x[9:5]) 
				5'h05: ascii_code_over=8'h47;//G
				5'h06: ascii_code_over=8'h41;//A
				5'h07: ascii_code_over=8'h4d;//M
				5'h08: ascii_code_over=8'h45;//E
				5'h09: ascii_code_over=0;//
				5'h0a: ascii_code_over=8'h4f;//O
				5'h0b: ascii_code_over=8'h56;//V
				5'h0c: ascii_code_over=8'h45;//E
				5'h0d: ascii_code_over=8'h52;//R
			endcase
			
			//win text logic(32x64 char size) ,  ""YOU WIN!""
			win_on= (pixel_y[8:6]==3 && pixel_x[9:5]>=6 && pixel_x[9:5]<=13);
			row_addr_win=pixel_y[5:2];
			bit_column_win=pixel_x[4:2];
			case(pixel_x[9:5]) 
				5'h06: ascii_code_win=8'h59;//Y
				5'h07: ascii_code_win=8'h4f;//O
				5'h08: ascii_code_win=8'h55;//U
				5'h09: ascii_code_win=0;//
				5'h0a: ascii_code_win=8'h57;//W
				5'h0b: ascii_code_win=8'h49;//I
				5'h0c: ascii_code_win=8'h4e;//N
				5'h0d: ascii_code_win=8'h21;//!
			endcase
			
			//rule text logic(8x16 char size)
			rule_on= (pixel_x[9:7]==2 && pixel_y[8:6]==2);
			row_addr_rule=pixel_y[3:0];
			bit_column_rule=pixel_x[2:0];
			case({pixel_y[5:4],pixel_x[6:3]})
				6'h00: ascii_code_rule=8'h52; //R
				6'h01: ascii_code_rule=8'h75; //u
				6'h02: ascii_code_rule=8'h6c; //l
				6'h03: ascii_code_rule=8'h65; //e
				6'h04: ascii_code_rule=8'h3a; //: 
				6'h05: ascii_code_rule=0; //
				6'h06: ascii_code_rule=0; //
				6'h07: ascii_code_rule=0; //
				6'h08: ascii_code_rule=0; //
				6'h09: ascii_code_rule=0; //
				6'h0a: ascii_code_rule=0; //
				6'h0b: ascii_code_rule=0; //
				6'h0c: ascii_code_rule=0; //
				6'h0d: ascii_code_rule=0; //
				6'h0e: ascii_code_rule=0; //
				6'h0f: ascii_code_rule=0; //
				
				6'h10: ascii_code_rule=8'h42; //B
				6'h11: ascii_code_rule=8'h6f; //o
				6'h12: ascii_code_rule=8'h75; //u
				6'h13: ascii_code_rule=8'h6e; //n
				6'h14: ascii_code_rule=8'h63; //c
				6'h15: ascii_code_rule=8'h65; //e
				6'h16: ascii_code_rule=0; //
				6'h17: ascii_code_rule=8'h74; //t
				6'h18: ascii_code_rule=8'h68; //h
				6'h19: ascii_code_rule=8'h65; //e
				6'h1a: ascii_code_rule=0; //
				6'h1b: ascii_code_rule=8'h62; //b
				6'h1c: ascii_code_rule=8'h61; //a
				6'h1d: ascii_code_rule=8'h6c; //l
				6'h1e: ascii_code_rule=8'h6c; //l
				6'h1f: ascii_code_rule=0; //
				
				6'h20: ascii_code_rule=8'h62; //b
				6'h21: ascii_code_rule=8'h61; //a
				6'h22: ascii_code_rule=8'h63; //c
				6'h23: ascii_code_rule=8'h6b; //k
				6'h24: ascii_code_rule=0; //
				6'h25: ascii_code_rule=8'h74; //t
				6'h26: ascii_code_rule=8'h6f; //o
				6'h27: ascii_code_rule=0; //
				6'h28: ascii_code_rule=8'h42; //B
				6'h29: ascii_code_rule=8'h52; //R
				6'h2a: ascii_code_rule=8'h45; //E
				6'h2b: ascii_code_rule=8'h41; //A
				6'h2c: ascii_code_rule=8'h4b; //K
				6'h2d: ascii_code_rule=0; //
				6'h2e: ascii_code_rule=0; //
				6'h2f: ascii_code_rule=0; //
				
				6'h30: ascii_code_rule=8'h64; //d
				6'h31: ascii_code_rule=8'h6f; //o
				6'h32: ascii_code_rule=8'h77; //w
				6'h33: ascii_code_rule=8'h6e; //n
				6'h34: ascii_code_rule=0; //
				6'h35: ascii_code_rule=8'h74; //t
				6'h36: ascii_code_rule=8'h68; //h
				6'h37: ascii_code_rule=8'h65; //e
				6'h38: ascii_code_rule=0; //
				6'h39: ascii_code_rule=8'h77; //w
				6'h3a: ascii_code_rule=8'h61; //a
				6'h3b: ascii_code_rule=8'h6c; //l
				6'h3c: ascii_code_rule=8'h6c; //l
				6'h3d: ascii_code_rule=8'h73; //s
				6'h3e: ascii_code_rule=0; //
				6'h3f: ascii_code_rule=0; //
							
			endcase
		
	 end
	 
	 
	 
	 
	 //rgb multiplexing
	 always @* begin
		rgb_text=0;
		row_addr=0;
		bit_column=0;
		ascii_code=0;
		rgb_text=3'b011; //background
		if(!video_on) rgb_text=0;
		else if(ball_on) begin
			rgb_text=font_bit? 3'b001:rgb_text; //score text color
			row_addr=row_addr_ball;
			bit_column=bit_column_ball;
			ascii_code=ascii_code_ball;
		end
		else if(rule_on) begin
			rgb_text=font_bit? 3'b000:rgb_text; //rule text color
			row_addr=row_addr_rule;
			bit_column=bit_column_rule;
			ascii_code=ascii_code_rule;
		end
		else if(win_on && won) begin
			rgb_text=font_bit? 3'b010:rgb_text; //gameover text color
			row_addr=row_addr_win;
			bit_column=bit_column_win;
			ascii_code=ascii_code_win;
		end
		else if(gameover_on && !won) begin
			rgb_text=font_bit? 3'b010:rgb_text; //gameover text color
			row_addr=row_addr_over;
			bit_column=bit_column_over;
			ascii_code=ascii_code_over;
		end
		else if(logo_on) begin
			rgb_text=font_bit? 3'b110:rgb_text; //logo text color
			row_addr=row_addr_logo;
			bit_column=bit_column_logo;
			ascii_code=ascii_code_logo;
		end
	end

	 
	 assign font_bit=row_data[~{bit_column-3'd1}];
	 assign text_on= {ball_on,rule_on,gameover_on,win_on,logo_on};
	 
	 //module instantiations
	 font_rom m0
   (
		.clk(clk),
		.addr({ascii_code,row_addr}), //[10:4] for ASCII char code, [3:0] for choosing what row to read on a given character  
		.data(row_data)
   );


endmodule
",pong_text.txt,FPGA_Book_Experiments\pong_text.txt
"[Keyword]: pong_top

[Design Category]: Control Circuits

[Design Function Description]:
This design implements the top-level module for a Pong game, which includes the control logic for game states, scorekeeping, and VGA output for displaying the game on a screen. The module manages the game flow through a finite state machine (FSM) and handles player inputs, game scoring, and visual output.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the game logic.
- `rst_n`: Active-low reset signal to initialize or reset the game state.
- `key[3:0]`: 4-bit input for player controls, where `key[1:0]` are for player 1 and `key[3:2]` are for player 2.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit output for the red component of the VGA signal.
- `vga_out_g[5:0]`: 6-bit output for the green component of the VGA signal.
- `vga_out_b[4:0]`: 5-bit output for the blue component of the VGA signal.
- `vga_out_vs`: Vertical sync signal for VGA output.
- `vga_out_hs`: Horizontal sync signal for VGA output.


[Design Detail]:
`timescale 1ns / 1ps

module pong_top(
	input clk, rst_n,
	input[3:0] key, //key[1:0] for player 1,key[3:2] for player 2
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 //FSM for the whole pong game
	 localparam[1:0] newgame=0,
							play=1,
							newball=2,
							over=3;
	wire clk_out;
	wire video_on;
	wire[11:0] pixel_x,pixel_y;
	wire[2:0] graph_on;
	wire[5:0] text_on;
	wire miss1,miss2;
	wire[2:0] rgb_graph,rgb_text;
	reg[2:0] rgb;
	reg[1:0] state_q,state_d;
	reg stop;
	wire[2:0] winner;
	reg[2:0] score1_q=0,score1_d,score2_q=0,score2_d;
	reg[2:0] ball_q=0,ball_d;
	reg timer_start;
	wire timer_tick,timer_up;
	
	//register operation for updating scores and the balls left
	always @(posedge clk_out,negedge rst_n) begin
		if(!rst_n) begin
			state_q<=0;
			ball_q<=0;
			score1_q<=0;
			score2_q<=0;
		end
		else begin
			state_q<=state_d;
			ball_q<=ball_d;
			score1_q<=score1_d;
			score2_q<=score2_d;
		end
	end
	
	//FSM next-state logic
	always @* begin
		state_d=state_q;
		ball_d=ball_q;
		score1_d=score1_q;
		score2_d=score2_q;
		stop=1;
		timer_start=0;
			case(state_q)
				newgame: begin //all scores back to zero and 3 balls will be restored
								ball_d=3;
								score1_d=0;
								score2_d=0;
								if(key!=4'b1111) begin //only when any of the button is pressed will the game start
									ball_d=ball_q-1;
									state_d=play;   
								end
							end
				   play: begin //start of game
								stop=0;
								if(miss1 ||miss2) begin
									if(miss1) score2_d=score2_q+1; //player 2 score increases if player 1 misses
									else score1_d=score1_q+1; ////player 1 score increases if player 2 misses
									ball_d= (ball_q==0)? 0:ball_q-1;
									timer_start=1;
									if(ball_q==0) state_d=over;
									else state_d=newball;
								end
							end
				newball: begin //when any of the player misses, 2 seconds will be alloted before the game can start again
								if(timer_up && key!=4'b1111) state_d=play;
							end
				   over: begin
								if(timer_up) state_d=newgame; //displayes who is the winner
							end
				default: state_d=newgame;
			endcase
	end
	

	
	//rgb multiplexing 
	always @* begin
		rgb=0;
		if(!video_on) rgb=0;
		else begin
			if(text_on[5] || text_on[4] || (text_on[3] && state_q==newgame) || (text_on[2]&& state_q==over) || text_on[0]) rgb=rgb_text; //{score1_on,score2_on,rule_on,win_on,logo_on,ball_on};
			else if(graph_on) rgb=rgb_graph; //{bar_1_on,bar_2_on,ball_on};
			else if(text_on[1]) rgb=rgb_text; //logo is at the last hierarchy since this must be the most underneath text
			else rgb=3'b011; //background			
		end
	end
	
	assign vga_out_r={5{rgb[2]}};
	assign vga_out_g={6{rgb[1]}};
	assign vga_out_b={5{rgb[0]}};
	
	assign timer_tick= (pixel_x==0 && pixel_y==500); //60Hz timer tick, this will be used on making a 2 second tick
	assign winner=(score1_q>score2_q)? 1:2;
	
	
	
	dcm_25MHz m0
   (// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );
	 vga_core m1
	(
		.clk(clk_out),
		.rst_n(rst_n), //clock must be 25MHz for 640x480 
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );
	 
	 
	 pong_animated m2 //control logic for any graphs on the game
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.video_on(video_on),
		.stop(stop), //return to default screen with no motion
		.key(key), //key[1:0] for player 1 and key[3:2] for player 2
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.rgb(rgb_graph),
		.graph_on(graph_on),
		.miss1(miss1),
		.miss2(miss2) //miss1=player 1 misses  , miss2=player2 misses
    );
	 
	 
	 pong_text m3 //control logic for any text on the game
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.winner(winner),
		.score1(score1_q),
		.score2(score2_q),
		.ball(ball_q),
		.rgb_text(rgb_text), 
		.rgb_on(text_on) //{score_on,rule_on,gameover_on,logo_on}
    );
	 
	 timer m4 //2 second timer which will be used for ""resting"" of players before restarting the game
	 (
		.clk(clk_out),
		.rst_n(rst_n),
		.timer_start(timer_start),
		.timer_tick(timer_tick),
		.timer_up(timer_up)
    );


endmodule
",pong_top.txt,FPGA_Book_Experiments\pong_top.txt
"[Keyword]: ps2_rx

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a PS/2 receiver module that captures data from a PS/2 device, such as a keyboard or mouse. It uses a finite state machine (FSM) to manage the reception of serial data bits, including start, data, parity, and stop bits. The module outputs the received data and indicates when the reception is complete.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the module.
- `rst_n`: Active-low reset signal to initialize the module's state and registers.
- `rx_en`: Enable signal to start the reception process.
- `ps2d`: PS/2 data line input, carrying the serial data bits from the PS/2 device.
- `ps2c`: PS/2 clock line input, used to synchronize the data reception.

[Output Signal Description]:
- `dout[10:0]`: 11-bit output representing the received data, including start, data, parity, and stop bits.
- `rx_done_tick`: A signal that goes high to indicate the completion of data reception.














[Design Detail]:
`timescale 1ns / 1ps

module ps2_rx(
	input clk,rst_n,
	input rx_en,
	input ps2d,ps2c,
	output[10:0] dout,
	output reg rx_done_tick
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							scan=2'd1,
							done=2'd2;
	 reg[1:0] state_reg,state_nxt;
	 reg[10:0] data_reg,data_nxt;
	 reg[3:0] n_reg,n_nxt;
	 reg[7:0] filter_reg,filter_nxt;
	 reg ps2c_f_reg,ps2c_f_nxt;
	 reg ps2c_reg;
	 wire ps2c_edg;
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=0;
			data_reg<=0;
			n_reg<=0;
			filter_reg<=0;
			ps2c_f_reg<=0;
			ps2c_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			data_reg<=data_nxt;
			n_reg<=n_nxt;
			filter_reg<=filter_nxt;
			ps2c_f_reg<=ps2c_f_nxt;
			ps2c_reg<=ps2c_f_reg;
		end
	 end
	 
	 //FSM next-state logic
	 always @* begin
		state_nxt=state_reg;
		data_nxt=data_reg;
		n_nxt=n_reg;
		rx_done_tick=0;
		case(state_reg)
			   idle: if(ps2c_edg && rx_en) begin //wait for the falling edge of the start bit
							data_nxt={ps2d,data_reg[10:1]};
							n_nxt=0;
							state_nxt=scan;
						end						
			   scan: if(ps2c_edg) begin //wait to finish receiving all data bits(bit0-9,paritybit,then stopbit)
							data_nxt={ps2d,data_reg[10:1]};
							if(n_reg==9) state_nxt=done;
							else n_nxt=n_reg+1;
						end
			   done: begin //finish
							rx_done_tick=1;
							state_nxt=idle;
						end
			default: state_nxt=idle;	
		endcase
	 end
	 //ps2c filter logic. The ps2c_f_reg is the filtered output.
	 always @* begin 
		filter_nxt={ps2c,filter_reg[7:1]}; 
		if(filter_reg==8'b1111_1111) ps2c_f_nxt=1;  //Any glitches shorter than 8 turns will be ignored
		else if(filter_reg==8'b0000_0000) ps2c_f_nxt=0; 
		else ps2c_f_nxt=ps2c_f_reg;
	 end
	 //falling edge detection for ps2c_f_reg
	 assign ps2c_edg=(ps2c_reg && !ps2c_f_reg)?1:0;
	assign dout=data_reg;
endmodule
",ps2_rx.txt,FPGA_Book_Experiments\ps2_rx.txt
"[Keyword]: ps2_rxtx

[Design Category]: Interface Circuits

[Design Function Description]:  
The design implements a PS/2 interface for both receiving and transmitting data. It includes a PS/2 receiver (`ps2_rx`) and a PS/2 transmitter (`ps2_tx`). The module handles the communication with a PS/2 device, allowing data to be sent and received over the PS/2 protocol.

[Input Signal Description]:  
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `din[7:0]`: 8-bit data input for transmission.
- `wr_ps2`: Write enable signal for initiating data transmission.
- `ps2d`: PS/2 data line, used as both input and output.
- `ps2c`: PS/2 clock line, used as both input and output.

[Output Signal Description]:  
- `dout[10:0]`: 11-bit data output received from the PS/2 device, including start bit, 8 data bits, parity bit, and stop bit.
- `rx_done_tick`: Signal indicating the completion of a data reception.
- `tx_done_tick`: Signal indicating the completion of a data transmission.









[Design Detail]:
`timescale 1ns / 1ps

module ps2_rxtx(
	input clk,rst_n,
	input[7:0] din, //8 bit data for tx
	input wr_ps2,
	inout ps2d,ps2c,
	output[10:0] dout, //11bit-data received from rx
	output rx_done_tick,
	output tx_done_tick
    );
	 wire tx_idle;
	 
	 ps2_rx m0
	 (
		.clk(clk),
		.rst_n(rst_n),
		.rx_en(tx_idle),
		.ps2d(ps2d),
		.ps2c(ps2c),
		.dout(dout), //startbit,8databits,paritybit,stopbit
		.rx_done_tick(rx_done_tick)
    );
	 
	 ps2_tx m1
	 (
		.clk(clk),
		.rst_n(rst_n),
		.wr_ps2(wr_ps2),
		.din(din),
		.ps2d(ps2d),
		.ps2c(ps2c),
		.tx_idle(tx_idle),
		.tx_done_tick(tx_done_tick)
    );


endmodule
",ps2_rxtx.txt,FPGA_Book_Experiments\ps2_rxtx.txt
"[Keyword]: ps2_tx

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a PS/2 transmitter interface. It is responsible for sending data to a PS/2 device by managing the PS/2 clock and data lines. The module uses a finite state machine (FSM) to control the transmission process, including generating start, data, and stop bits, and ensuring proper timing and synchronization with the PS/2 protocol.

[Input Signal Description]:
- `clk`: Clock signal used for synchronizing the operations within the module.
- `rst_n`: Active-low reset signal to initialize the module's state.
- `wr_ps2`: Write enable signal that initiates the transmission of data to the PS/2 device.
- `din[7:0]`: 8-bit data input that is to be transmitted to the PS/2 device.

[Output Signal Description]:
- `tx_idle`: Indicates that the transmitter is idle and ready to accept new data for transmission.
- `tx_done_tick`: Signals the completion of a data transmission cycle.












[Design Detail]:
`timescale 1ns / 1ps

module ps2_tx(
	input clk,rst_n,
	input wr_ps2,
	input[7:0] din,
	inout ps2d,ps2c,
	output reg tx_idle,tx_done_tick
    );
	 //FSM state declarations
	 localparam[2:0] idle=3'd0,
							rts=3'd1,
							start=3'd2,
							data=3'd3,
							stop=3'd4;
	 reg[2:0] state_reg,state_nxt;
	 reg[12:0] counter_reg,counter_nxt;
	 reg[3:0] n_reg,n_nxt;
	 reg[8:0] data_reg,data_nxt;
	 reg[7:0] filter_reg;
	 wire[7:0] filter_nxt;
	 reg ps2c_reg;
	 wire ps2c_nxt;
	 reg ps2c_out,ps2d_out;
	 reg tri_c,tri_d;
	 wire fall_edg;
	
	//FSM register operations
	always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			counter_reg<=0;
			n_reg<=0;
			data_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			counter_reg<=counter_nxt;
			n_reg<=n_nxt;
			data_reg<=data_nxt;
		end
	end
	//FSM next-state logics
	always @* begin
		state_nxt=state_reg;
		counter_nxt=counter_reg;
		n_nxt=n_reg;
		data_nxt=data_reg;
		tx_idle=0;
		tx_done_tick=0;
		ps2c_out=1; //default clock out
		ps2d_out=1; //drfault data out  
		tri_c=0; //tri-state data bus is default off(high Z)
		tri_d=0; //tri-state clock bus is default off(high Z)
		case(state_reg)
			   idle: begin  //wait for wr_ps2 signal to be asserted(signal for transmitting data to ps2)
							tx_idle=1;
							if(wr_ps2==1) begin
								counter_nxt=0;
								n_nxt=0;
								data_nxt={!(^din),din}; //data={oddparity,8-bitdata}
								state_nxt=rts;
							end
						end
			    rts: begin //forces the clock line to be 0 for at least 100us(signal for request to send)
							ps2c_out=0;
							tri_c=1;
							if(counter_reg==13'h1fff) state_nxt=start; 
							else counter_nxt=counter_reg+1;
						end
			  start: begin //forces the data line to be 0(signal for start bit) and disable the rts(back to hi-Z)
							ps2d_out=0;
							tri_d=1;
							if(fall_edg==1) state_nxt=data;
						end
			   data: begin //shifts the next data bit for every falling edge of the clock line
							ps2d_out=data_reg[0];
							tri_d=1;
							if(fall_edg==1) begin
								data_nxt={1'b0,data_reg[8:1]};
								if(n_reg==8) state_nxt=stop; //finishes all data bits and 1 parity bit
								else n_nxt=n_reg+1;
							end
						end
			   stop: begin
							if(fall_edg==1) begin
								tx_done_tick=1;
								state_nxt=idle;
							end
						end
			default: state_nxt=idle;
		endcase
	end
		 
	  //filtering the ps2 clock from very short glitches, with falling edge detector
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			filter_reg<=0;
			ps2c_reg<=0;
		end
		else begin
			filter_reg<=filter_nxt;
			ps2c_reg<=ps2c_nxt;
		end
	 end
	 assign filter_nxt={ps2c,filter_reg[7:1]};
	 assign ps2c_nxt=(filter_reg==8'hff)?1:
							(filter_reg==8'h00)?0:
							 ps2c_reg;
	 assign fall_edg=(ps2c_reg && !ps2c_nxt)? 1:0;
	 
	 //tri-state logic for ps2c and ps2d
	 assign ps2c=tri_c?ps2c_out:1'bz;
	 assign ps2d=tri_d?ps2d_out:1'bz;
							  


endmodule
",ps2_tx.txt,FPGA_Book_Experiments\ps2_tx.txt
"[Keyword]: reaction_timer

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a reaction timer circuit that measures the time taken by a user to react to a signal. It uses a finite state machine (FSM) to manage different states: idle, waiting, play, and done. The circuit displays messages and reaction times on a seven-segment display and uses LEDs to indicate the active state. The timer starts when a button is pressed and stops when another button is pressed, measuring the reaction time in milliseconds.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the circuit operations.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `start_low`: Active-low signal to start the timer.
- `clr_low`: Active-low signal to clear the current state and reset to idle.
- `stop_low`: Active-low signal to stop the timer and record the reaction time.

[Output Signal Description]:
- `led[3:0]`: 4-bit output to control LEDs indicating the current state of the circuit.
- `seg_out[7:0]`: 8-bit output for the seven-segment display to show messages or reaction time.
- `sel_out[5:0]`: 6-bit output to select which digit of the seven-segment display is active.


[Design Detail]:
`timescale 1ns / 1ps

module reaction_timer(
	input clk,rst_n,
	input start_low,clr_low,stop_low, //active-low button
	output reg[3:0] led,
	output[7:0] seg_out,
	output[5:0] sel_out
    );
	 
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							waiting=2'd1,
							play=2'd2,
							done=2'd3;
	 reg[1:0] state_reg,state_nxt;
	 reg[25:0] counter_reg,counter_nxt; //ticks every 1 second
	 reg[3:0] sec_reg,sec_nxt; //delay in ""seconds""
	 reg[3:0] mod16_reg,mod16_nxt; //random number generator(free-running counter 2-to-15)
	 reg[3:0] random_reg,random_nxt; //stores value of mod_16_reg when ""start""button is pressed
	 reg[15:0] timer_reg,timer_nxt; ///ticks every 1ms
	 reg[13:0] milli_reg,milli_nxt;//delay in terms of ""milliseconds""
	 reg[7:0] dig0,dig1,dig2,dig3,dig4,dig5; //value of each seven-segments
	 wire[3:0] dig0_temp,dig1_temp,dig2_temp,dig3_temp,dig4_temp,dig5_temp;
	 reg[6:0] dig0_temp1,dig1_temp1,dig2_temp1,dig3_temp1,dig4_temp1,dig5_temp1;
	 wire start,clr,stop;
	 reg start_bin2bcd;
	 assign start=!start_low, //make the button active high 
				clr=!clr_low,
				stop=!stop_low;
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=0;
			counter_reg<=0;
			sec_reg<=0;
			mod16_reg<=0;
			random_reg<=0;
			timer_reg<=0;
			milli_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			counter_reg<=counter_nxt;
			sec_reg<=sec_nxt;
			mod16_reg<=mod16_nxt;
			random_reg<=random_nxt;
			timer_reg<=timer_nxt;
			milli_reg<=milli_nxt;
		end
	 end
	 
	 //FSM next-state logics
	 always @* begin
		state_nxt=state_reg;
		counter_nxt=counter_reg;
		sec_nxt=sec_reg;
		mod16_nxt=mod16_reg;
		random_nxt=random_reg;
		timer_nxt=timer_reg;
		milli_nxt=milli_reg;
		led=4'b0000;
		dig0=8'b1111_1111;
		dig1=8'b1111_1111;
		dig2=8'b1111_1111;
		dig3=8'b1111_1111;
		dig4=8'b1111_1111;
		dig5=8'b1111_1111;
		start_bin2bcd=0;
		if(!clr) begin
			case(state_reg)
					idle: begin //display ""_Hello"" 
								dig0=8'b1000_0001;
								dig1=8'b1111_0001;
								dig2=8'b1111_0001;
								dig3=8'b1011_0000;
								dig4=8'b1100_1000;
								dig5=8'b1111_1111;
								if(start) begin
									counter_nxt=0;
									sec_nxt=0;
									random_nxt=mod16_reg;
									state_nxt=waiting;
								end
							end
				waiting: begin
								if(!stop) begin //display OFF
									if(counter_reg!=49_999_999) counter_nxt=counter_reg+1;
									else begin
										sec_nxt=sec_reg+1;
										counter_nxt=0;
										if(sec_nxt==random_reg) begin
											timer_nxt=0;
											milli_nxt=0;
											state_nxt=play;
										end
									end
								end
								else begin
									milli_nxt=9_999;
									state_nxt=done;
									start_bin2bcd=1;
								end
							end
					play: begin
								led=4'b1111;
								if(timer_reg!=49_999) timer_nxt=timer_reg+1;
								else begin
									milli_nxt=milli_reg+1;
									timer_nxt=0;
								end
								if(stop || milli_nxt==1_000) begin
									state_nxt=done;
									start_bin2bcd=1;
								end
							end
					done: begin
								dig0={1'b1,dig0_temp1};
								dig1={1'b1,dig1_temp1};
								dig2={1'b1,dig2_temp1};
								dig3={1'b0,dig3_temp1};
								dig4={1'b1,dig4_temp1};
								dig5={1'b1,dig5_temp1};
							end
				default:	state_nxt=idle;			
			endcase
		end
		else state_nxt=idle;
		
		//free-running counter as the random number generator(counts from 2-to-15 then wraps around)
		if(mod16_reg!=15) mod16_nxt=mod16_reg+1;
		else mod16_nxt=2;
	 end
	 
	 
	 //module instantiations	 
	 bin2bcd m0
	 (
		.clk(clk),
		.rst_n(rst_n),
		.start(start_bin2bcd),
		.bin(milli_nxt),//limit is 6 digit of bcd
		.ready(),
		.done_tick(),
		.dig0(dig0_temp),
		.dig1(dig1_temp),
		.dig2(dig2_temp),
		.dig3(dig3_temp),
		.dig4(dig4_temp),
		.dig5(dig5_temp)
    );
	LED_mux m1
	(
	.clk(clk),
	.rst(rst_n),
	.in0(dig0),
	.in1(dig1),
	.in2(dig2),
	.in3(dig3),
	.in4(dig4),
	.in5(dig5), 
	.seg_out(seg_out),
	.sel_out(sel_out)
    );
	 
	 //decoder for hex-to-7 bit seven-segment value
	 always @* begin
		 dig0_temp1=0;
		 dig1_temp1=0;
		 dig2_temp1=0;
		 dig3_temp1=0;
		 dig4_temp1=0;
		 dig5_temp1=0;
			 case(dig0_temp)
			 4'h0: dig0_temp1=7'b0000_001;
			 4'h1: dig0_temp1=7'b1001_111;
			 4'h2: dig0_temp1=7'b0010_010;
			 4'h3: dig0_temp1=7'b0000_110;
			 4'h4: dig0_temp1=7'b1001_100;
			 4'h5: dig0_temp1=7'b0100_100;
			 4'h6: dig0_temp1=7'b0100_000;
			 4'h7: dig0_temp1=7'b0001_111;
			 4'h8: dig0_temp1=7'b0000_000;
			 4'h9: dig0_temp1=7'b0001_100;
			 4'ha: dig0_temp1=7'b0001_000;
			 4'hb: dig0_temp1=7'b1100_000;
			 4'hc: dig0_temp1=7'b0110_001;
			 4'hd: dig0_temp1=7'b1000_010;
			 4'he: dig0_temp1=7'b0110_000;
			 4'hf: dig0_temp1=7'b0111_000;
			 endcase
			 case(dig1_temp)
			 4'h0: dig1_temp1=7'b0000_001;
			 4'h1: dig1_temp1=7'b1001_111;
			 4'h2: dig1_temp1=7'b0010_010;
			 4'h3: dig1_temp1=7'b0000_110;
			 4'h4: dig1_temp1=7'b1001_100;
			 4'h5: dig1_temp1=7'b0100_100;
			 4'h6: dig1_temp1=7'b0100_000;
			 4'h7: dig1_temp1=7'b0001_111;
			 4'h8: dig1_temp1=7'b0000_000;
			 4'h9: dig1_temp1=7'b0001_100;
			 4'ha: dig1_temp1=7'b0001_000;
			 4'hb: dig1_temp1=7'b1100_000;
			 4'hc: dig1_temp1=7'b0110_001;
			 4'hd: dig1_temp1=7'b1000_010;
			 4'he: dig1_temp1=7'b0110_000;
			 4'hf: dig1_temp1=7'b0111_000;
			 endcase
			 case(dig2_temp)
			 4'h0: dig2_temp1=7'b0000_001;
			 4'h1: dig2_temp1=7'b1001_111;
			 4'h2: dig2_temp1=7'b0010_010;
			 4'h3: dig2_temp1=7'b0000_110;
			 4'h4: dig2_temp1=7'b1001_100;
			 4'h5: dig2_temp1=7'b0100_100;
			 4'h6: dig2_temp1=7'b0100_000;
			 4'h7: dig2_temp1=7'b0001_111;
			 4'h8: dig2_temp1=7'b0000_000;
			 4'h9: dig2_temp1=7'b0001_100;
			 4'ha: dig2_temp1=7'b0001_000;
			 4'hb: dig2_temp1=7'b1100_000;
			 4'hc: dig2_temp1=7'b0110_001;
			 4'hd: dig2_temp1=7'b1000_010;
			 4'he: dig2_temp1=7'b0110_000;
			 4'hf: dig2_temp1=7'b0111_000;
			 endcase
			 case(dig3_temp)
			 4'h0: dig3_temp1=7'b0000_001;
			 4'h1: dig3_temp1=7'b1001_111;
			 4'h2: dig3_temp1=7'b0010_010;
			 4'h3: dig3_temp1=7'b0000_110;
			 4'h4: dig3_temp1=7'b1001_100;
			 4'h5: dig3_temp1=7'b0100_100;
			 4'h6: dig3_temp1=7'b0100_000;
			 4'h7: dig3_temp1=7'b0001_111;
			 4'h8: dig3_temp1=7'b0000_000;
			 4'h9: dig3_temp1=7'b0001_100;
			 4'ha: dig3_temp1=7'b0001_000;
			 4'hb: dig3_temp1=7'b1100_000;
			 4'hc: dig3_temp1=7'b0110_001;
			 4'hd: dig3_temp1=7'b1000_010;
			 4'he: dig3_temp1=7'b0110_000;
			 4'hf: dig3_temp1=7'b0111_000;
			 endcase
			 case(dig4_temp)
			 4'h0: dig4_temp1=7'b0000_001;
			 4'h1: dig4_temp1=7'b1001_111;
			 4'h2: dig4_temp1=7'b0010_010;
			 4'h3: dig4_temp1=7'b0000_110;
			 4'h4: dig4_temp1=7'b1001_100;
			 4'h5: dig4_temp1=7'b0100_100;
			 4'h6: dig4_temp1=7'b0100_000;
			 4'h7: dig4_temp1=7'b0001_111;
			 4'h8: dig4_temp1=7'b0000_000;
			 4'h9: dig4_temp1=7'b0001_100;
			 4'ha: dig4_temp1=7'b0001_000;
			 4'hb: dig4_temp1=7'b1100_000;
			 4'hc: dig4_temp1=7'b0110_001;
			 4'hd: dig4_temp1=7'b1000_010;
			 4'he: dig4_temp1=7'b0110_000;
			 4'hf: dig4_temp1=7'b0111_000;
			 endcase
			 case(dig5_temp)
			 4'h0: dig5_temp1=7'b0000_001;
			 4'h1: dig5_temp1=7'b1001_111;
			 4'h2: dig5_temp1=7'b0010_010;
			 4'h3: dig5_temp1=7'b0000_110;
			 4'h4: dig5_temp1=7'b1001_100;
			 4'h5: dig5_temp1=7'b0100_100;
			 4'h6: dig5_temp1=7'b0100_000;
			 4'h7: dig5_temp1=7'b0001_111;
			 4'h8: dig5_temp1=7'b0000_000;
			 4'h9: dig5_temp1=7'b0001_100;
			 4'ha: dig5_temp1=7'b0001_000;
			 4'hb: dig5_temp1=7'b1100_000;
			 4'hc: dig5_temp1=7'b0110_001;
			 4'hd: dig5_temp1=7'b1000_010;
			 4'he: dig5_temp1=7'b0110_000;
			 4'hf: dig5_temp1=7'b0111_000;
			 endcase

	 end
	 
	 


endmodule
",reaction_timer.txt,FPGA_Book_Experiments\reaction_timer.txt
"[Keyword]: Rotate_16

[Design Category]: Combinational Logic

[Design Function Description]:
The design implements a 16-bit barrel shifter that can perform both left and right rotations. The direction of the shift is determined by the control signal `LR`. If `LR` is high, the circuit performs a left rotation; otherwise, it performs a right rotation. The amount of rotation is specified by a 4-bit input `amt`, allowing for rotations from 0 to 15 positions.

[Input Signal Description]:
- `num[15:0]`: A 16-bit input signal representing the number to be rotated.
- `amt[3:0]`: A 4-bit input signal specifying the number of positions to rotate the input number.
- `LR`: A control signal that determines the direction of rotation. If `LR` is high, a left rotation is performed; if low, a right rotation is performed.

[Output Signal Description]:
- `real_out[15:0]`: A 16-bit output signal that represents the result of the rotation operation on the input number `num`, based on the specified direction and amount.


[Design Detail]:
`timescale 1ns / 1ps

module barrel_shifter_16(
		input wire[15:0] num,
		input wire[3:0] amt,
		input wire LR,
		output wire[15:0] real_out);
		wire[15:0] out_1,out_2;
		Rotate_R16 m0(num,amt,out_1);
		Rotate_L16 m1(num,amt,out_2);
		assign real_out=LR?out_2:out_1;  //MUX for left or right 16-bit shifter
endmodule


module Rotate_R16(
	input wire[15:0] num, 
	input wire[3:0] amt,
	output wire[15:0] out
    );
	 wire[15:0] s0,s1,s2,s3;
	 assign s0=amt[0]?{num[0],num[15:1]}:num; //1 move
	 assign s1=amt[1]?{s0[1:0],s0[15:2]}:s0;   //2 moves
	 assign s2=amt[2]?{s1[3:0],s1[15:4]}:s1;   //4 moves
	 assign s3=amt[3]?{s2[7:0],s2[15:8]}:s2;   //8 moves
	 assign out=s3;
	 
endmodule

module Rotate_L16(
	input wire[15:0] num, 
	input wire[3:0] amt,
	output wire[15:0] out
    );
	 wire[15:0] s0,s1,s2,s3;
	 assign s0=amt[0]?{num[14:0],num[15]}:num; //1 move
	 assign s1=amt[1]?{s0[13:0],s0[15:14]}:s0;  //2 moves
	 assign s2=amt[2]?{s1[11:0],s1[15:12]}:s1;  //4 moves
	 assign s3=amt[3]?{s2[7:0],s2[15:8]}:s2;  //8 moves
	 assign out=s3;

endmodule",Rotate_16.txt,FPGA_Book_Experiments\Rotate_16.txt
"[Keyword]: Rotate_32

[Design Category]: Combinational Logic

[Design Function Description]:  
The design implements a 32-bit barrel shifter that can perform both left and right rotations. The direction of the rotation is determined by the control signal `LR`. If `LR` is high, the circuit performs a left rotation; otherwise, it performs a right rotation. The amount of rotation is specified by the 5-bit input `amt`, allowing for rotations from 0 to 31 positions.

[Input Signal Description]:  
- `num[31:0]`: A 32-bit input signal representing the number to be rotated.
- `amt[4:0]`: A 5-bit input signal specifying the number of positions to rotate the input number.
- `LR`: A control signal that determines the direction of rotation. If `LR` is high, a left rotation is performed; if low, a right rotation is performed.

[Output Signal Description]:  
- `real_out[31:0]`: A 32-bit output signal that provides the result of the rotation operation based on the input number, the amount of rotation, and the direction specified by `LR`.


[Design Detail]:
`timescale 1ns / 1ps

module barrel_shifter_32(
		input wire[31:0] num,
		input wire[4:0] amt,
		input wire LR,
		output wire[31:0] real_out);
		wire[31:0] out_1,out_2;
		Rotate_R32 m0(num,amt,out_1);
		Rotate_L32 m1(num,amt,out_2);
		assign real_out=LR?out_2:out_1;  //MUX for left or right 16-bit shifter
endmodule



module Rotate_R32(
	input wire[31:0] num, 
	input wire[4:0] amt,
	output wire[31:0] out
    );
	 wire[31:0] s0,s1,s2,s3,s4;
	 assign s0=amt[0]?{num[0],num[31:1]}:num; //1 move
	 assign s1=amt[1]?{s0[1:0],s0[31:2]}:s0;   //2 moves
	 assign s2=amt[2]?{s1[3:0],s1[31:4]}:s1;   //4 moves
	 assign s3=amt[3]?{s2[7:0],s2[31:8]}:s2;   //8 moves
	 assign s4=amt[4]?{s2[15:0],s3[31:16]}:s3; //16 bits
	 assign out=s4;

endmodule

module Rotate_L32(
	input wire[31:0] num, 
	input wire[4:0] amt,
	output wire[31:0] out
    );
	 wire[31:0] s0,s1,s2,s3,s4;
	 assign s0=amt[0]?{num[30:0],num[31]}:num; //1 move
	 assign s1=amt[1]?{s0[29:0],s0[31:30]}:s0;  //2 moves
	 assign s2=amt[2]?{s1[27:0],s1[31:28]}:s1;  //4 moves
	 assign s3=amt[3]?{s2[23:0],s2[31:24]}:s2;  //8 moves
	 assign s4=amt[4]?{s3[15:0],s3[31:16]}:s3;  //16 moves
	 assign out=s4;


endmodule
",Rotate_32.txt,FPGA_Book_Experiments\Rotate_32.txt
"[Keyword]: Rotate_8

[Design Category]: Arithmetic Circuits

[Design Function Description]:  
The design implements an 8-bit barrel shifter that can perform both left and right rotations. The direction of the shift is determined by the control signal LR. The amount of rotation is specified by a 3-bit input, allowing for shifts of 0 to 7 positions.

[Input Signal Description]:  
- `num[7:0]`: An 8-bit input signal representing the number to be rotated.
- `amt[2:0]`: A 3-bit input signal specifying the number of positions to rotate the input number.
- `LR`: A control signal that determines the direction of the rotation. If LR is high, a left rotation is performed; if low, a right rotation is performed.

[Output Signal Description]:  
- `real_out[7:0]`: An 8-bit output signal that provides the result of the rotation operation based on the input number, the amount of rotation, and the direction specified by LR.


[Design Detail]:
`timescale 1ns / 1ps

module barrel_shifter_8(  
		input wire[7:0] num,
		input wire[2:0] amt,
		input wire LR,
		output wire[7:0] real_out);
		wire[7:0] out_1,out_2;
		Rotate_R8 m0(num,amt,out_1);
		Rotate_L8 m1(num,amt,out_2);
		assign real_out=LR?out_2:out_1;   //MUX for left or right 8-bit shifter
endmodule	 

module Rotate_R8(
	input wire[7:0] num, 
	input wire[2:0] amt,
	output wire[7:0] out
    );
	 wire[7:0] s0,s1,s2;
	 assign s0=amt[0]?{num[0],num[7:1]}:num; //1 move
	 assign s1=amt[1]?{s0[1:0],s0[7:2]}:s0;  //2 moves
	 assign s2=amt[2]?{s1[3:0],s1[7:4]}:s1;  //4 moves
	 assign out=s2;
endmodule

module Rotate_L8(
	input wire[7:0] num, 
	input wire[2:0] amt,
	output wire[7:0] out
    );
	 wire[7:0] s0,s1,s2;
	 assign s0=amt[0]?{num[6:0],num[7]}:num; //1 move
	 assign s1=amt[1]?{s0[5:0],s0[7:6]}:s0;  //2 moves
	 assign s2=amt[2]?{s1[3:0],s1[7:4]}:s1;  //4 moves
	 assign out=s2;
endmodule






",Rotate_8.txt,FPGA_Book_Experiments\Rotate_8.txt
"[Keyword]: rotate_sq

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a rotating square display using six seven-segment displays. The rotation is controlled by a clock signal and can be either clockwise or counterclockwise. The rotation frequency is determined by the `base_counter` parameter, which is set to achieve a 5Hz rotation frequency. The design uses a 24-bit counter to manage timing and a 4-bit counter to track the current position in the rotation sequence.

[Input Signal Description]:
- `clk`: Clock signal used to drive the sequential logic.
- `rst_n`: Active-low reset signal to initialize the counters.
- `cw`: Control signal to determine the direction of rotation (clockwise or counterclockwise).
- `en`: Enable signal to start or stop the rotation.

[Output Signal Description]:
- `in0` to `in5`: 8-bit outputs representing the state of each of the six seven-segment displays. The most significant bit is the decimal point (active low), and the remaining 7 bits represent the seven-segment value (active low).


[Design Detail]:
`timescale 1ns / 1ps

module rotate_sq
	#(parameter base_counter=10_000_000) ////frequency of rotating square is 50MHz/base_counter=50MHz/10M=5Hz (0.2 sec per box)
	(
	 input clk,rst_n,
	 input cw,en,
	 output reg[7:0] in0,in1,in2,in3,in4,in5 //1 bit=Decimal point(active low) 7 bits=seven-segment value(active low)
    );

	 reg[23:0] mod_10M=0; 
	 reg[3:0] mod_12=0; //12 turns since the square will rotate in 6 seven-segments
	 wire[23:0] mod_10M_nxt;
	 reg[3:0] mod_12_nxt=0;
	 
	 //registers
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
			mod_10M<=0;
			mod_12<=0;
			end	
		else begin
			if(en) begin //if not enable then do nothing
				mod_10M<=mod_10M_nxt;
				mod_12<=mod_12_nxt;
				end
			end		
	end
	
	//next-state logic for mod_25M
	assign mod_10M_nxt=(mod_10M==base_counter-1)?24'd0:mod_10M+1'b1;
	assign mod_10M_max=(mod_10M==base_counter-1)?1'b1:1'b0;
	
	//next-state logic for mod_12
	always @* begin
	mod_12_nxt=mod_12;
		if(mod_10M_max) begin
			if(cw) mod_12_nxt=(mod_12==11)?4'd0: mod_12+1'b1; //clock-wise= 0-to-11 then back to zero
			else mod_12_nxt=(mod_12==0)?4'd11:mod_12-1'b1;    //counterclock-wise= 11-to-zero then back to 11
		end
	end
	
	
	//mod_12 tells which of the 6 seven-segments will turn-on and whether its the upper box or lower box 
	always @* begin
	   in0=8'hff; in1=8'hff; in2=8'hff; in3=8'hff; in4=8'hff; in5=8'hff; //default off(active low)
		case(mod_12) 
			4'd0: in5={1'b1,7'b0011100}; //Upper box
			4'd1: in4={1'b1,7'b0011100};
			4'd2: in3={1'b1,7'b0011100};
			4'd3: in2={1'b1,7'b0011100};
			4'd4: in1={1'b1,7'b0011100};
			4'd5: in0={1'b1,7'b0011100};
			
			4'd6: in0={1'b1,7'b1100010}; //Lower box
			4'd7: in1={1'b1,7'b1100010};
			4'd8: in2={1'b1,7'b1100010};
			4'd9: in3={1'b1,7'b1100010};
		  4'd10: in4={1'b1,7'b1100010};
		  4'd11: in5={1'b1,7'b1100010};
		endcase
	end
	
endmodule
",rotate_sq.txt,FPGA_Book_Experiments\rotate_sq.txt
"[Keyword]: rotating_banner

[Design Category]: Interface Circuits

[Design Function Description]:
The design implements a rotating banner display on a VGA screen. It uses a VGA controller to generate the necessary synchronization signals and a banner generator to create the visual content. The banner's size and rotation speed can be controlled via input keys.

[Input Signal Description]:
- `clk`: Clock signal for the circuit.
- `rst_n`: Active-low reset signal to initialize the system.
- `key[3:0]`: 4-bit input where `key[1:0]` controls the character size and `key[3:2]` controls the rotating speed of the banner.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit output for the red component of the VGA signal.
- `vga_out_g[5:0]`: 6-bit output for the green component of the VGA signal.
- `vga_out_b[4:0]`: 5-bit output for the blue component of the VGA signal.
- `vga_out_vs`: Vertical sync signal for the VGA display.
- `vga_out_hs`: Horizontal sync signal for the VGA display.


[Design Detail]:
`timescale 1ns / 1ps

module rotating_banner
	(
	input clk,rst_n,
	input[3:0] key, //key[1:0]=char size , key[3:2]=rotating speed
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 
	 
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;
	 

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	 rotating_banner_gen m1
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.key(key), 
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb)
    );
	
	 dcm_25MHz m2
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );      
	
endmodule

",rotating_banner.txt,FPGA_Book_Experiments\rotating_banner.txt
"[Keyword]: rotating_banner_gen

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a rotating banner generator for a video display system. It generates a scrolling text banner on a screen, where the text size and scrolling speed can be adjusted using input keys. The banner displays characters from predefined arrays and rotates them across the screen at a speed determined by the user.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing operations.
- `rst_n`: Active-low reset signal to initialize or reset the circuit.
- `key[3:0]`: 4-bit input for controlling the banner. `key[1:0]` adjusts character size, and `key[3:2]` adjusts rotating speed.
- `pixel_x[9:0]`: Horizontal pixel position for the video display.
- `pixel_y[9:0]`: Vertical pixel position for the video display.
- `video_on`: Signal indicating whether the video display is active.

[Output Signal Description]:
- `rgb[2:0]`: 3-bit output representing the RGB color value for the current pixel, determining the color of the text or background on the display.


[Design Detail]:
`timescale 1ns / 1ps

 module rotating_banner_gen(
	input clk,rst_n,
	input[3:0] key, //key[1:0]=char size , key[3:2]=rotating speed
	input[9:0] pixel_x,pixel_y,
	input video_on,
	output reg[2:0] rgb
    );
	 
	 reg[1:0] size_q=0; //stores current size ( 0=16x32 , 1=32x64 , 2=64x128 , 3=28x256 )
	 reg[1:0] speed_q=0; //stores current speed
	 reg[6:0] ascii_addr; //determines the char at given tile
	 reg[3:0] row_addr; //determines the row to be scanned on a given ascii char
	 reg[2:0] column_addr; //determines the bit pixel to be scanned on a given row
	 reg text_on; //determines if the tile has a character
	 reg[6:0] array1[0:39]; //register file for bannner with 16x32 char size,index is reverse for easier access
	 reg[6:0] array2[0:19]; //register file for bannner with 32x64 char size,index is reverse for easier access
	 reg[6:0] array3[0:15]; //register file for bannner with 64x128 and 128x256 char sizes,index is reverse for easier access
	 wire key0_tick,key1_tick,key2_tick,key3_tick;
	 wire[7:0] font_data;
	 wire font_bit;
	 wire tick_60Hz;
	 reg tick1,tick2,tick3,tick4; ///determines the speed of rotation,tick1 is the fastest
	 reg[9:0] timer1_q=0,timer2_q=0,timer3_q=0,timer4_q=0;
	 reg[5:0] counter_q=0,counter_d;
	 reg[6:0] array_addr;
	 integer i;

	 initial begin //initial values of array1,array2, and array3
		for(i=0;i<=39;i=i+1) begin //make all values zero to remove unknowns
			array1[i]=0;
			if(i<=19) array2[i]=0;
			if(i<=15)array3[i]=0;
		end
		array1[0]=7'h48; //H
		array1[1]=7'h45; //E
		array1[2]=7'h4c; //L
		array1[3]=7'h4c; //L
		array1[4]=7'h4f; //O
		array1[5]=7'h00; //
		array1[6]=7'h46; //F
		array1[7]=7'h50; //P
		array1[8]=7'h47; //G
		array1[9]=7'h41; //A
		array1[10]=7'h00; //
		array1[11]=7'h57; //W
		array1[12]=7'h4f; //O
		array1[13]=7'h52; //R
		array1[14]=7'h4c; //L
		array1[15]=7'h44; //D
		
		array2[0]=7'h48; //H
		array2[1]=7'h45; //E
		array2[2]=7'h4c; //L
		array2[3]=7'h4c; //L
		array2[4]=7'h4f; //O
		array2[5]=7'h00; //
		array2[6]=7'h46; //F
		array2[7]=7'h50; //P
		array2[8]=7'h47; //G
		array2[9]=7'h41; //A
		array2[10]=7'h00; //
		array2[11]=7'h57; //W
		array2[12]=7'h4f; //O
		array2[13]=7'h52; //R
		array2[14]=7'h4c; //L
		array2[15]=7'h44; //D
		
		array3[0]=7'h48; //H
		array3[1]=7'h45; //E
		array3[2]=7'h4c; //L
		array3[3]=7'h4c; //L
		array3[4]=7'h4f; //O
		array3[5]=7'h00; //
		array3[6]=7'h46; //F
		array3[7]=7'h50; //P
		array3[8]=7'h47; //G
		array3[9]=7'h41; //A
		array3[10]=7'h00; //
		array3[11]=7'h57; //W
		array3[12]=7'h4f; //O
		array3[13]=7'h52; //R
		array3[14]=7'h4c; //L
		array3[15]=7'h44; //D
	 end
	 
	 //register operation for changing size or speed
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			size_q<=0;
			speed_q<=0;
			counter_q<=0;
			timer1_q<=0;
			timer2_q<=0;
			timer3_q<=0;
			timer4_q<=0;
		end
		else begin
			size_q<=key0_tick? size_q+1:key1_tick? size_q-1:size_q;
			speed_q<=key2_tick? speed_q+1:key3_tick? speed_q-1:speed_q;
			counter_q<=counter_d;
			//timers for rotation speed
			if(tick_60Hz) begin
				timer1_q<=(timer1_q==3)?0:timer1_q+1; //timer_1 has duration 1x of 60Hz tick
				timer2_q<=(timer2_q==10)?0:timer2_q+1; //timer_2 has duration 2x of 60Hz tick
				timer3_q<=(timer3_q==20)?0:timer3_q+1; //timer_3 has duration 3x of 60Hz tick
				timer4_q<=(timer4_q==40)?0:timer4_q+1; //timer_4 has duration 4x of 60Hz tick
			end
				//tick logic for its ocrresponding speed
			tick1=(timer1_q==3 && tick_60Hz);
			tick2=(timer2_q==10 && tick_60Hz);
			tick3=(timer3_q==20 && tick_60Hz);
			tick4=(timer4_q==40 && tick_60Hz);			
		end
	 end	
	 
	 assign tick_60Hz= (pixel_x==0 && pixel_y==500); //60Hz tick signal from VGA controller logic(since VGA is set at 60Hz),use as base speed 
	 
	 
	 //logic for speed of rotation
	 always @* begin
		counter_d=counter_q;
		if(key0_tick || key1_tick) counter_d=0; //if char size changes, return the counter_q to default to prevent any unforseenable error 
		else begin
			case(speed_q)
				0: begin
						if(tick1)
						case(size_q)
							0: counter_d=(counter_q==39)? 0:counter_q+1;
							1: counter_d=(counter_q==19)? 0:counter_q+1;
							2: counter_d=(counter_q==15)? 0:counter_q+1;
							3: counter_d=(counter_q==15)? 0:counter_q+1;		
						endcase
					end
				1: begin
						if(tick2)
						case(size_q)
							0: counter_d=(counter_q==39)? 0:counter_q+1;
							1: counter_d=(counter_q==19)? 0:counter_q+1;
							2: counter_d=(counter_q==15)? 0:counter_q+1;
							3: counter_d=(counter_q==15)? 0:counter_q+1;		
						endcase
					end
				2: begin
						if(tick3)
						case(size_q)
							0: counter_d=(counter_q==39)? 0:counter_q+1;
							1: counter_d=(counter_q==19)? 0:counter_q+1;
							2: counter_d=(counter_q==15)? 0:counter_q+1;
							3: counter_d=(counter_q==15)? 0:counter_q+1;		
						endcase
					end
				3: begin
						if(tick4)
						case(size_q)
							0: counter_d=(counter_q==39)? 0:counter_q+1;
							1: counter_d=(counter_q==19)? 0:counter_q+1;
							2: counter_d=(counter_q==15)? 0:counter_q+1;
							3: counter_d=(counter_q==15)? 0:counter_q+1;		
						endcase
					end
			endcase
		end
	 end
	 
	
	 //logic for rotating banner size
	 always @* begin
		text_on=0;
		row_addr=0;
		column_addr=0;
		ascii_addr=0;
		array_addr=0;
		
		if(size_q==0) begin //16x32 size
			text_on= pixel_y[8:5]==7;
			row_addr= pixel_y[4:1];
			column_addr= pixel_x[3:1];
			
			array_addr=pixel_x[9:4]+counter_q; //index for array1 moves due to rotation thus changing the starting point
			if(array_addr>39) array_addr=array_addr-39-1;	//logic for rotation	
			ascii_addr=array1[array_addr]; 			
		end
		
		else if(size_q==1) begin //32x64 size
			text_on= pixel_y[8:6]==3;
			row_addr= pixel_y[5:2];
			column_addr= pixel_x[4:2];
			
			array_addr=pixel_x[9:5]+counter_q; //index for array2 moves due to rotation thus changing the starting point
			if(array_addr>19) array_addr=array_addr-19-1;	//logic for rotation	
			ascii_addr=array2[array_addr];
		end
		
		else if(size_q==2) begin //64x138
			text_on= pixel_y[8:7]==1;
			row_addr= pixel_y[6:3];
			column_addr= pixel_x[5:3];

			array_addr=pixel_x[9:6]+counter_q; //index for array3 moves due to rotation thus changing the starting point
			if(array_addr>15) array_addr=array_addr-15-1;	//logic for rotation	
			ascii_addr=array3[array_addr];			
		end
		
		else if(size_q==3) begin //128x256
			text_on= pixel_y[8]==0;
			row_addr= pixel_y[7:4];
			column_addr= pixel_x[6:4];

			array_addr=pixel_x[9:7]+counter_q; //index for array3 moves due rotation thus changing the starting point
			if(array_addr>15) array_addr=array_addr-15-1;	//logic for rotation	
			ascii_addr=array3[array_addr];
		end
	 end

	   
	 //rgb multiplexing circuit
	 always @* begin
		rgb=0;
		if(!video_on) rgb=0;
		else begin
			if(text_on) rgb=font_bit? 3'b111:0; //text color
			else rgb=0; //background color
		end
	 end
	 
	 
	 assign font_bit=font_data[~(column_addr-1)];
	 
	 
	 debounce_explicit m0
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(!key[0]),
		.db_level(),
		.db_tick(key0_tick) //increase size
    );
	 
	 debounce_explicit m1
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(!key[1]),
		.db_level(),
		.db_tick(key1_tick) //decrease size
    );
	 
	 debounce_explicit m2
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(!key[2]),
		.db_level(),
		.db_tick(key2_tick) //increase speed
    );
	 
	 debounce_explicit m3
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(!key[3]),
		.db_level(),
		.db_tick(key3_tick) //decrease speed
    );
	 
	 font_rom m4
   (
    .clk(clk),
    .addr({ascii_addr,row_addr}), //[10:4] for ASCII char code, [3:0] for choosing what row to read on a given character code  
    .data(font_data)
   );
	 
endmodule

",rotating_banner_gen.txt,FPGA_Book_Experiments\rotating_banner_gen.txt
"[Keyword]: rotating_LED

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a rotating LED display controller. It controls the display of a sequence of numbers (0-9) on a set of LED segments. The sequence can rotate left or right based on the direction input, and the rotation speed is determined by a parameterized counter.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `en`: Enable signal to allow the rotation of the display.
- `dir`: Direction signal to determine the rotation direction (left or right).

[Output Signal Description]:
- `in0` to `in5`: 5-bit outputs representing the current numbers to be displayed on the LED segments. Each output corresponds to a digit in the sequence.




[Design Detail]:
`timescale 1ns / 1ps

module rotating_LED
	#(parameter turns=15_000_000) ///Frequency will be 50MHz/turns = 50MHz/15M = 3.33Hz(0.3 sec per move)
	(
	input clk,rst_n,
	input ps2d,ps2c,
	output [4:0] in0,in1,in2,in3,in4,in5 //{decimalpoint,hexadecimal}
    );
	 localparam W=10; //number of all letters/numbers to be displayed
	 
	 reg[24:0] mod_turns=0;
	 reg[5*W-1:0] words={  ////  word=0123456789 
								{1'b0,4'h0},
								{1'b0,4'h1},
								{1'b0,4'h2},
								{1'b0,4'h3},
								{1'b0,4'h4},
								{1'b0,4'h5},
								{1'b0,4'h6},
								{1'b0,4'h7},
								{1'b0,4'h8},
								{1'b0,4'h9}			
								}; //Note: If  ""W"" is greater than the words initialized here, it will be displayed as default zero on the leftmost digit
	  wire[24:0] mod_turns_nxt;
	  reg[5*W-1:0] words_nxt;
	  wire mod_turns_max;
	  wire fifo_empty;
	  wire[8:0] rd_data;
	  reg rd_fifo;
	  reg en,en_nxt;
	  reg dir,dir_nxt;
	  //registers
	  always @(posedge clk,negedge rst_n) begin
			if(!rst_n) begin
				mod_turns<=0;
				words<={ {1'b0,4'h0},
						  {1'b0,4'h1},
						  {1'b0,4'h2},
						  {1'b0,4'h3},
						  {1'b0,4'h4},
						  {1'b0,4'h5},
						  {1'b0,4'h6},
						  {1'b0,4'h7},
						  {1'b0,4'h8},
						  {1'b0,4'h9}			
						  };
					en<=0;
					dir<=0;
			end
			else begin
				if(en) begin
					mod_turns<=mod_turns_nxt;
					words<=words_nxt;
			   end	
				en<=en_nxt;
				dir<=dir_nxt;
			end
			
	  end
	  //next-state logics
	  assign mod_turns_nxt=(mod_turns==turns)?0:mod_turns+1;
	  assign mod_turns_max=(mod_turns==turns)?1:0;
	
	  always @* begin
		  words_nxt=words;
		  en_nxt=en;
		  dir_nxt=dir;
		  rd_fifo=0;
		  if(mod_turns_max) words_nxt=(!dir)? {words[5*W-6:0],words[5*W-1:5*W-5]}  :  {words[4:0],words[5*W-1:5]} ;  //if dir is not asserted: move left , else:move right
		  if(!fifo_empty) begin
				case(rd_data)
					9'h34: en_nxt=1;//G fo go
					9'h4d: en_nxt=0; //P for pause
					9'h23: dir_nxt=!dir; //D to reverse direction
					9'h45: words_nxt={5'd0,words[5*W-1:5]};//add 0 to banner
					9'h16: words_nxt={5'd1,words[5*W-1:5]}; //add 1 to banner
					9'h1e: words_nxt={5'd2,words[5*W-1:5]}; //add 2 to banner
					9'h26: words_nxt={5'd3,words[5*W-1:5]}; //add 3 to banner
					9'h25: words_nxt={5'd4,words[5*W-1:5]}; //add 4 to banner
					9'h2e: words_nxt={5'd5,words[5*W-1:5]}; //add 5 to banner
					9'h36: words_nxt={5'd6,words[5*W-1:5]}; //add 6 to banner
					9'h3d: words_nxt={5'd7,words[5*W-1:5]}; //add 7 to banner
					9'h3e: words_nxt={5'd8,words[5*W-1:5]}; //add 8 to banner
					9'h46: words_nxt={5'd9,words[5*W-1:5]}; //add 9 to banner
				endcase
				rd_fifo=1;
		  end
	  end
	  
	  //output logic to be be used by the LED Multiplexing circuit (6 5-bit outputs that determine what number will be displayed on the sevensegments)
	  assign in5=words[5*W-1:5*W-5],
				in4=words[5*W-6:5*W-10],
				in3=words[5*W-11:5*W-15],
				in2=words[5*W-16:5*W-20],
				in1=words[5*W-21:5*W-25],
				in0=words[5*W-26:5*W-30];
				
	kb m0
	(   //extract only the real bytes from received packets of data(no break code)
		.clk(clk),
		.rst_n(rst_n),
		.ps2d(ps2d),
		.ps2c(ps2c),
		.rd_fifo(rd_fifo),
		.rd_data(rd_data), //{shift,data}
		.fifo_empty(fifo_empty)
    );
endmodule
",rotating_LED.txt,FPGA_Book_Experiments\rotating_LED.txt
"[Keyword]: sdram_controller

[Design Category]: Interface Circuits

[Design Function Description]:
The design is an SDRAM (Synchronous Dynamic Random Access Memory) controller. It manages the communication between an FPGA and an SDRAM module, handling read and write operations, initialization, and refresh cycles. The controller ensures that the SDRAM is accessed correctly according to its timing requirements and command sequences.

[Input Signal Description]:
- `clk`: Clock signal for the controller, operating at 100MHz.
- `rst_n`: Active-low reset signal to initialize the controller.
- `rw`: Read/Write control signal; '1' for read, '0' for write.
- `rw_en`: Read/Write enable signal, must be asserted before any read or write operation.
- `f_addr[23:0]`: Address bus from FPGA to SDRAM, divided into row (23:11), bank (10:9), and column (8:0) addresses.
- `f2s_data[15:0]`: Data bus from FPGA to SDRAM for write operations.

[Output Signal Description]:
- `s2f_data[15:0]`: Data bus from SDRAM to FPGA for read operations.
- `s2f_data_valid`: Signal indicating that the data read from SDRAM is valid.
- `ready`: Signal indicating that the SDRAM is ready for the next read/write operation.
- `s_clk`: Clock signal for the SDRAM, derived from the main clock with a 180-degree phase shift.
- `s_cke`: Clock enable signal for SDRAM, typically always high.
- `s_cs_n`, `s_ras_n`, `s_cas_n`, `s_we_n`: Command signals for SDRAM operations.
- `s_addr[12:0]`: Address bus for row/column addressing in SDRAM.
- `s_ba[1:0]`: Bank address bus for SDRAM.
- `LDQM`, `HDQM`: Data mask signals, always zero (disabled).
- `s_dq[15:0]`: Bidirectional data bus for SDRAM read/write operations.




[Design Detail]:
`timescale 1ns / 1ps

module sdram_controller(
	//fpga to controller
	input clk,rst_n,  //clk=100MHz
	input rw, // 1:read , 0:write
	input rw_en, //must be asserted before read/write
	input[23:0] f_addr, //23:11=row  , 10:9=bank  , 8:0 col
	input [15:0] f2s_data, //fpga-to-sdram data
	output[15:0] s2f_data, //sdram to fpga data
	output s2f_data_valid, //asserts if read-out data is now valid
	output reg ready, //""1"" if sdram is available for nxt read/write operation
	
	//controller to sdram
	output s_clk,
	output s_cke, //always high for almost all operations(except for self-refresh w/c I did not use here)
	output s_cs_n, s_ras_n, s_cas_n, s_we_n, //commands
	output[12:0] s_addr, //row/colum address bus
	output[1:0] s_ba, //bank address bus
	output LDQM , HDQM, //low-byte and high-byte mask (alwyas zero:disabled)
	inout[15:0] s_dq //sdram inout/output data	
    );	
	 
	 //s_clock(clk input to sdram) is 180 degrees lagging from main clock to solve the hold-setup time requirements of sdram
	 ODDR2#(.DDR_ALIGNMENT(""NONE""), .INIT(1'b0),.SRTYPE(""SYNC"")) oddr2_primitive
	 (
		.D0(1'b0),
		.D1(1'b1),
		.C0(clk),
		.C1(~clk),
		.CE(1'b1),
		.R(1'b0),
		.S(1'b0),
		.Q(s_clk)
	);
	//FSM states		//initialize
	 localparam[3:0]  start=0,
							precharge_init=1, 
							refresh_1=2,
							refresh_2=3,
							load_mode_reg=4,
							//normal operation
							idle=5,
							read=6,
							read_data=7,
							write=8,
							//refresh every 7.81us
							refresh=9,
		
							delay=10; //waiting state for any amount of delay needed
							
	//minimum time specs needed(in clks for 100MHz(10ns))
	localparam[2:0] t_RP=2, //15ns(precharge) 
					t_RC=7, //60ns(active to active,ref to ref)
					t_MRD=2, //2 clk,(mode register) /2/
					t_RCD=2, //15ns (active to read/write)
					t_WR=2, //2clk delay after writing before manual/auto precharge can start
					t_CL=2; //CAS latency(delay of data_out after read command)
					
	//commands {cs_n,ras_n,cas_n,we_n} REFER TO THE DATASHEET: winbond W9825G6KH
	localparam[3:0]  cmd_precharge=4'b0010,
						  cmd_NOP=4'b1111,
						  cmd_activate=4'b0011,
						  cmd_write=4'b0100,
						  cmd_read=4'b0101,
						  cmd_setmode=4'b0000,
						  cmd_refresh=4'b0001;
						  
	reg[3:0] state_q,state_d; //_q is registered output, _d is input to DFF
	reg[3:0] nxt_q,nxt_d; //state after next state
	reg[3:0] cmd_q,cmd_d; //{cs_n,ras_n,cas_n,we_n}
	reg[14:0] delay_ctr_q,delay_ctr_d; //stores delay needed(max is 200us or 20_000 turns for 100MHz)
	reg[9:0] refresh_ctr_q=0,refresh_ctr_d; 
	reg refresh_flag_q,refresh_flag_d;

	
	//buffer for output for a glitch-free signal
	reg[12:0] s_addr_q,s_addr_d;
	reg[1:0] s_ba_q,s_ba_d;
	reg[15:0] s_dq_q,s_dq_d;
	reg tri_q,tri_d;
	
	//buffer for input
	reg[23:0] f_addr_q,f_addr_d;
	reg rw_q,rw_d;
	reg[15:0] f2s_data_q,f2s_data_d;
	reg[15:0] s2f_data_q,s2f_data_d;
	reg s2f_data_valid_q,s2f_data_valid_d;


	
	
	//register operation
	always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_q<=start;
			nxt_q<=start;
			cmd_q<=cmd_NOP;
			delay_ctr_q<=0;
			refresh_ctr_q<=0;
			s_addr_q<=0;
			tri_q<=0;
			
			s_ba_q<=0;
			s_dq_q<=0;
			f_addr_q<=0;
			rw_q<=0;
			f2s_data_q<=0;
			s2f_data_q<=0;
			s2f_data_valid_q<=0;
			rw_q<=0;
			refresh_flag_q<=0;
		end
		else begin
			state_q<=state_d;
			nxt_q<=nxt_d;
			cmd_q<=cmd_d;
			delay_ctr_q<=delay_ctr_d;
			refresh_ctr_q<=refresh_ctr_d;
			s_addr_q<=s_addr_d;
			tri_q<=tri_d;
			refresh_flag_q<=refresh_flag_d;
			
			s_ba_q<=s_ba_d;
			s_dq_q<=s_dq_d;
			f_addr_q<=f_addr_d;
			rw_q<=rw_d;
			f2s_data_q<=f2s_data_d;
			s2f_data_q<=s2f_data_d;
			s2f_data_valid_q<=s2f_data_valid_d;
		end
	end
	

	//next-state logics
	always @* begin
		state_d=state_q;
		nxt_d=nxt_q;
		cmd_d=cmd_NOP; //always default to No Operation 
		delay_ctr_d=delay_ctr_q;
		ready=0; 
		s_addr_d=s_addr_q;
		s_ba_d=s_ba_q;
		s_dq_d=s_dq_q;
		f_addr_d=f_addr_q;
		rw_d=rw_q;
		f2s_data_d=f2s_data_q;
		s2f_data_d=s2f_data_q;
		tri_d=0;  
		s2f_data_valid_d=1'b0;
		
		
		//refresh every 7.8us or else data will be lost. 
		refresh_flag_d=refresh_flag_q;
		refresh_ctr_d=refresh_ctr_q+1'b1;
		if(refresh_ctr_q==770) begin //770 turns or 10 clks before the max(780=7.8us)
			refresh_ctr_d=0;
			refresh_flag_d=1;
		end
		
		
		
		case(state_q)
					////////////////BEGIN:INITIALIZE////////////////
			delay: begin //wait here for a delay specified by delay_ctr_q(parameter in time specs)
						delay_ctr_d=delay_ctr_q-1'b1;
						if(delay_ctr_d==0) state_d=nxt_q;							
					 end
			start: begin //initiliaze after power-up
						state_d=delay;
						nxt_d=precharge_init;
						delay_ctr_d=15'd20_000; //wait for 200us
						s_addr_d=0;
						s_ba_d=0;
					 end
precharge_init: begin //precharge ALL banks (A10 must be high)
						state_d=delay;
						nxt_d=refresh_1;
						delay_ctr_d=t_RP-1;
						cmd_d=cmd_precharge;
						s_addr_d[10]=1'b1;
					 end
		refresh_1: begin
						state_d=delay;
						nxt_d=refresh_2;
						delay_ctr_d=t_RC-1;
						cmd_d=cmd_refresh;
					  end
		refresh_2: begin
						state_d=delay;
						nxt_d=load_mode_reg;
						delay_ctr_d=t_RC-1;
						cmd_d=cmd_refresh;
					  end
  load_mode_reg: begin
						state_d=delay;
						nxt_d=idle;
						delay_ctr_d=t_MRD-1;
						cmd_d=cmd_setmode;
						s_addr_d=13'b 000_0_00_010_0_000; //{reserved,writemode,reserved,CL,AddressingMode,BurstLength}
						s_ba_d=2'b00; //reserved
					  end
					 ////////////////END:INITIALIZE////////////////
					
					////////////////BEGIN:NORMAL OPERATION////////////////
		     idle: begin 
						ready=1;
							if(refresh_flag_q==1) begin  //if refresh is needed
								ready=0;
								state_d=delay;
								nxt_d=refresh;
								delay_ctr_d=t_RP-1;
								cmd_d=cmd_precharge; //precharge all banks first before auto-refresh
								s_addr_d[10]=1'b1;
								refresh_flag_d=0;
							end
							else begin
								if(rw_en) begin //permission granted for r/w operation 
									f2s_data_d=f2s_data;
									f_addr_d=f_addr; 
									state_d=delay;
									cmd_d=cmd_activate;
									delay_ctr_d=t_RCD-1;
									{s_addr_d,s_ba_d}=f_addr[23:9];
									nxt_d=rw?read:write;
								end
							end
					  end 
	     refresh:	begin
						 state_d=delay;
						 nxt_d=idle;
						 delay_ctr_d=t_RC-1;
						 cmd_d=cmd_refresh;
						 f_addr_d=0;
						end					 
			read: begin //0101
						state_d=delay;
						delay_ctr_d=t_CL; //not subtracted by one since the sdram is ""late"" by half a cycle so register it one clk after the expected clock latency delay
						cmd_d=cmd_read;
						s_addr_d=f_addr_q[8:0];//what column to activate
						s_ba_d=f_addr_q[10:9]; //what bank to activate
						s_addr_d[10]=1'b1; //auto-precharge
						nxt_d=read_data;
					end
	 read_data: begin //read data after CAS latency of 2 or 3 clk
						s2f_data_d=s_dq;
						s2f_data_valid_d=1'b1;
						state_d=delay;
						delay_ctr_d=t_RP-1;
						nxt_d=idle;
					end		
		 write: begin
						s_addr_d=f_addr_q[8:0];//what column to activate
						s_ba_d=f_addr_q[10:9];
						s_addr_d[10]=1'b1; //auto-precharge
						tri_d=1'b1; //tristate buffer on since we output/write signals
						cmd_d=cmd_write;
						state_d=delay;
						delay_ctr_d=t_RP+t_WR-1;
						nxt_d=idle;
				  end			
				  ////////////////END:NORMAL OPERATION////////////////
				  
		default: state_d=start;
		endcase
		
		
			
	
	end
	
	//assign the outputs to corresponding buffers
	assign s_cs_n=cmd_q[3],
			 s_ras_n=cmd_q[2],
			 s_cas_n=cmd_q[1],
			 s_we_n=cmd_q[0];
	assign s_cke=1'b1; 
	assign LDQM=1'b0, 
			 HDQM=1'b0;
	assign s_addr=s_addr_q;
	assign s_ba=s_ba_q;
   assign s_dq=tri_q? f2s_data_q:16'hzzzz; //tri-state output,tri=1 for write , tri=0 for read(hi-Z)
	assign s2f_data=s2f_data_q;
	assign s2f_data_valid=s2f_data_valid_q;
					
	
endmodule
",sdram_controller.txt,FPGA_Book_Experiments\sdram_controller.txt
"[Keyword]: squarewave_disp

[Design Category]: Interface Circuits

[Design Function Description]:
This design is a VGA display controller that generates square-wave patterns on a screen. It includes functionality to move a cursor and change the waveform pattern using input keys. The design outputs RGB signals and synchronization signals for a VGA display.

[Input Signal Description]:
- `clk`: Clock input signal for the system.
- `rst_n`: Active-low reset signal to initialize the system.
- `key[2:0]`: 3-bit input signal for user interaction. `key[0]` moves the cursor to the right, `key[1]` moves the cursor down, and `key[2]` changes the waveform pattern.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit red color output for the VGA display.
- `vga_out_g[5:0]`: 6-bit green color output for the VGA display.
- `vga_out_b[4:0]`: 5-bit blue color output for the VGA display.
- `vga_out_vs`: Vertical synchronization signal for the VGA display.
- `vga_out_hs`: Horizontal synchronization signal for the VGA display.


[Design Detail]:
`timescale 1ns / 1ps

module squarewave_disp
	(
	input clk,rst_n,
	input[2:0] key, //key[0] to move cursor to right,key[1] to move cursor down, key[2] to change waveform pattern
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 
	 
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;
	 

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	full_screen_gen m1 //generates square-wave patterns with variable cursor location
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.key(key),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb)
    );
	
	 dcm_25MHz m2
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );      
	
endmodule

",squarewave_disp.txt,FPGA_Book_Experiments\squarewave_disp.txt
"[Keyword]: squarewave_rom

[Design Category]: Memory Circuits

[Design Function Description]:
This design implements a Read-Only Memory (ROM) that outputs an 8-bit data value based on an 8-bit address input. The address is divided into two parts: the upper 2 bits select one of four square-wave patterns, and the lower 6 bits select a specific column within that pattern. The ROM stores predefined square-wave patterns that can be used for waveform generation or other applications.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the address latching.
- `addr[7:0]`: 8-bit address input where the upper 2 bits (addr[7:6]) select the square-wave pattern, and the lower 6 bits (addr[5:0]) select the column address within that pattern.

[Output Signal Description]:
- `data[7:0]`: 8-bit output data that corresponds to the value stored in the ROM at the specified address. The output is determined by the latched address value.



[Design Detail]:
`timescale 1ns / 1ps

module squarewave_rom(
	input clk,
	input[7:0] addr, //7:6 for square-wave pattern , 5:0 for column address of that pattern
	output reg[7:0] data
    );
	 reg[7:0] addr_q;
	 always @(posedge clk) addr_q<=addr;
	 
	 always @* begin
		 case(addr_q)
		
				//0->0				
				{2'b00 , 6'd	0	}: data= 8'b	00000000	;
				{2'b00 , 6'd	1	}: data= 8'b	00000000	;
				{2'b00 , 6'd	2	}: data= 8'b	00000000	;
				{2'b00 , 6'd	3	}: data= 8'b	00000000	;
				{2'b00 , 6'd	4	}: data= 8'b	00000000	;
				{2'b00 , 6'd	5	}: data= 8'b	00000000	;
				{2'b00 , 6'd	6	}: data= 8'b	00000000	;
				{2'b00 , 6'd	7	}: data= 8'b	00000000	;
				{2'b00 , 6'd	8	}: data= 8'b	00000000	;
				{2'b00 , 6'd	9	}: data= 8'b	00000000	;
				{2'b00 , 6'd	10	}: data= 8'b	00000000	;
				{2'b00 , 6'd	11	}: data= 8'b	00000000	;
				{2'b00 , 6'd	12	}: data= 8'b	00000000	;
				{2'b00 , 6'd	13	}: data= 8'b	00000000	;
				{2'b00 , 6'd	14	}: data= 8'b	00000000	;
				{2'b00 , 6'd	15	}: data= 8'b	00000000	;
				{2'b00 , 6'd	16	}: data= 8'b	00000000	;
				{2'b00 , 6'd	17	}: data= 8'b	00000000	;
				{2'b00 , 6'd	18	}: data= 8'b	00000000	;
				{2'b00 , 6'd	19	}: data= 8'b	00000000	;
				{2'b00 , 6'd	20	}: data= 8'b	00000000	;
				{2'b00 , 6'd	21	}: data= 8'b	00000000	;
				{2'b00 , 6'd	22	}: data= 8'b	00000000	;
				{2'b00 , 6'd	23	}: data= 8'b	00000000	;
				{2'b00 , 6'd	24	}: data= 8'b	00000000	;
				{2'b00 , 6'd	25	}: data= 8'b	00000000	;
				{2'b00 , 6'd	26	}: data= 8'b	00000000	;
				{2'b00 , 6'd	27	}: data= 8'b	00000000	;
				{2'b00 , 6'd	28	}: data= 8'b	00000000	;
				{2'b00 , 6'd	29	}: data= 8'b	00000000	;
				{2'b00 , 6'd	30	}: data= 8'b	00000000	;
				{2'b00 , 6'd	31	}: data= 8'b	00000000	;
				{2'b00 , 6'd	32	}: data= 8'b	00000000	;
				{2'b00 , 6'd	33	}: data= 8'b	00000000	;
				{2'b00 , 6'd	34	}: data= 8'b	00000000	;
				{2'b00 , 6'd	35	}: data= 8'b	00000000	;
				{2'b00 , 6'd	36	}: data= 8'b	00000000	;
				{2'b00 , 6'd	37	}: data= 8'b	00000000	;
				{2'b00 , 6'd	38	}: data= 8'b	00000000	;
				{2'b00 , 6'd	39	}: data= 8'b	00000000	;
				{2'b00 , 6'd	40	}: data= 8'b	00000000	;
				{2'b00 , 6'd	41	}: data= 8'b	00000000	;
				{2'b00 , 6'd	42	}: data= 8'b	00000000	;
				{2'b00 , 6'd	43	}: data= 8'b	00000000	;
				{2'b00 , 6'd	44	}: data= 8'b	00000000	;
				{2'b00 , 6'd	45	}: data= 8'b	00000000	;
				{2'b00 , 6'd	46	}: data= 8'b	00000000	;
				{2'b00 , 6'd	47	}: data= 8'b	00000000	;
				{2'b00 , 6'd	48	}: data= 8'b	00000000	;
				{2'b00 , 6'd	49	}: data= 8'b	00000000	;
				{2'b00 , 6'd	50	}: data= 8'b	00000000	;
				{2'b00 , 6'd	51	}: data= 8'b	00000000	;
				{2'b00 , 6'd	52	}: data= 8'b	00000000	;
				{2'b00 , 6'd	53	}: data= 8'b	00000000	;
				{2'b00 , 6'd	54	}: data= 8'b	00000000	;
				{2'b00 , 6'd	55	}: data= 8'b	00000000	;
				{2'b00 , 6'd	56	}: data= 8'b	00000000	;
				{2'b00 , 6'd	57	}: data= 8'b	00000000	;
				{2'b00 , 6'd	58	}: data= 8'b	00000000	;
				{2'b00 , 6'd	59	}: data= 8'b	00000000	;
				{2'b00 , 6'd	60	}: data= 8'b	00000000	;
				{2'b00 , 6'd	61	}: data= 8'b	00000000	;
				{2'b00 , 6'd	62	}: data= 8'b	00000000	;
				{2'b00 , 6'd	63	}: data= 8'b	11111111	;
								
				//0->1				
				{2'b01, 6'd	0	}: data= 8'b	00001111	;
				{2'b01, 6'd	1	}: data= 8'b	00001000	;
				{2'b01, 6'd	2	}: data= 8'b	00001000	;
				{2'b01, 6'd	3	}: data= 8'b	00001000	;
				{2'b01, 6'd	4	}: data= 8'b	00001000	;
				{2'b01, 6'd	5	}: data= 8'b	00001000	;
				{2'b01, 6'd	6	}: data= 8'b	00001000	;
				{2'b01, 6'd	7	}: data= 8'b	00001000	;
				{2'b01, 6'd	8	}: data= 8'b	00001000	;
				{2'b01, 6'd	9	}: data= 8'b	00001000	;
				{2'b01, 6'd	10	}: data= 8'b	00001000	;
				{2'b01, 6'd	11	}: data= 8'b	00001000	;
				{2'b01, 6'd	12	}: data= 8'b	00001000	;
				{2'b01, 6'd	13	}: data= 8'b	00001000	;
				{2'b01, 6'd	14	}: data= 8'b	00001000	;
				{2'b01, 6'd	15	}: data= 8'b	00001000	;
				{2'b01, 6'd	16	}: data= 8'b	00001000	;
				{2'b01, 6'd	17	}: data= 8'b	00001000	;
				{2'b01, 6'd	18	}: data= 8'b	00001000	;
				{2'b01, 6'd	19	}: data= 8'b	00001000	;
				{2'b01, 6'd	20	}: data= 8'b	00001000	;
				{2'b01, 6'd	21	}: data= 8'b	00001000	;
				{2'b01, 6'd	22	}: data= 8'b	00001000	;
				{2'b01, 6'd	23	}: data= 8'b	00001000	;
				{2'b01, 6'd	24	}: data= 8'b	00001000	;
				{2'b01, 6'd	25	}: data= 8'b	00001000	;
				{2'b01, 6'd	26	}: data= 8'b	00001000	;
				{2'b01, 6'd	27	}: data= 8'b	00001000	;
				{2'b01, 6'd	28	}: data= 8'b	00001000	;
				{2'b01, 6'd	29	}: data= 8'b	00001000	;
				{2'b01, 6'd	30	}: data= 8'b	00001000	;
				{2'b01, 6'd	31	}: data= 8'b	00001000	;
				{2'b01, 6'd	32	}: data= 8'b	00001000	;
				{2'b01, 6'd	33	}: data= 8'b	00001000	;
				{2'b01, 6'd	34	}: data= 8'b	00001000	;
				{2'b01, 6'd	35	}: data= 8'b	00001000	;
				{2'b01, 6'd	36	}: data= 8'b	00001000	;
				{2'b01, 6'd	37	}: data= 8'b	00001000	;
				{2'b01, 6'd	38	}: data= 8'b	00001000	;
				{2'b01, 6'd	39	}: data= 8'b	00001000	;
				{2'b01, 6'd	40	}: data= 8'b	00001000	;
				{2'b01, 6'd	41	}: data= 8'b	00001000	;
				{2'b01, 6'd	42	}: data= 8'b	00001000	;
				{2'b01, 6'd	43	}: data= 8'b	00001000	;
				{2'b01, 6'd	44	}: data= 8'b	00001000	;
				{2'b01, 6'd	45	}: data= 8'b	00001000	;
				{2'b01, 6'd	46	}: data= 8'b	00001000	;
				{2'b01, 6'd	47	}: data= 8'b	00001000	;
				{2'b01, 6'd	48	}: data= 8'b	00001000	;
				{2'b01, 6'd	49	}: data= 8'b	00001000	;
				{2'b01, 6'd	50	}: data= 8'b	00001000	;
				{2'b01, 6'd	51	}: data= 8'b	00001000	;
				{2'b01, 6'd	52	}: data= 8'b	00001000	;
				{2'b01, 6'd	53	}: data= 8'b	00001000	;
				{2'b01, 6'd	54	}: data= 8'b	00001000	;
				{2'b01, 6'd	55	}: data= 8'b	00001000	;
				{2'b01, 6'd	56	}: data= 8'b	00001000	;
				{2'b01, 6'd	57	}: data= 8'b	00001000	;
				{2'b01, 6'd	58	}: data= 8'b	00001000	;
				{2'b01, 6'd	59	}: data= 8'b	00001000	;
				{2'b01, 6'd	60	}: data= 8'b	00001000	;
				{2'b01, 6'd	61	}: data= 8'b	00001000	;
				{2'b01, 6'd	62	}: data= 8'b	00001000	;
				{2'b01, 6'd	63	}: data= 8'b	11111000	;
								
								
				//1->1				
				{2'b11 , 6'd	0	}: data= 8'b	11111111	;
				{2'b11 , 6'd	1	}: data= 8'b	00000000	;
				{2'b11 , 6'd	2	}: data= 8'b	00000000	;
				{2'b11 , 6'd	3	}: data= 8'b	00000000	;
				{2'b11 , 6'd	4	}: data= 8'b	00000000	;
				{2'b11 , 6'd	5	}: data= 8'b	00000000	;
				{2'b11 , 6'd	6	}: data= 8'b	00000000	;
				{2'b11 , 6'd	7	}: data= 8'b	00000000	;
				{2'b11 , 6'd	8	}: data= 8'b	00000000	;
				{2'b11 , 6'd	9	}: data= 8'b	00000000	;
				{2'b11 , 6'd	10	}: data= 8'b	00000000	;
				{2'b11 , 6'd	11	}: data= 8'b	00000000	;
				{2'b11 , 6'd	12	}: data= 8'b	00000000	;
				{2'b11 , 6'd	13	}: data= 8'b	00000000	;
				{2'b11 , 6'd	14	}: data= 8'b	00000000	;
				{2'b11 , 6'd	15	}: data= 8'b	00000000	;
				{2'b11 , 6'd	16	}: data= 8'b	00000000	;
				{2'b11 , 6'd	17	}: data= 8'b	00000000	;
				{2'b11 , 6'd	18	}: data= 8'b	00000000	;
				{2'b11 , 6'd	19	}: data= 8'b	00000000	;
				{2'b11 , 6'd	20	}: data= 8'b	00000000	;
				{2'b11 , 6'd	21	}: data= 8'b	00000000	;
				{2'b11 , 6'd	22	}: data= 8'b	00000000	;
				{2'b11 , 6'd	23	}: data= 8'b	00000000	;
				{2'b11 , 6'd	24	}: data= 8'b	00000000	;
				{2'b11 , 6'd	25	}: data= 8'b	00000000	;
				{2'b11 , 6'd	26	}: data= 8'b	00000000	;
				{2'b11 , 6'd	27	}: data= 8'b	00000000	;
				{2'b11 , 6'd	28	}: data= 8'b	00000000	;
				{2'b11 , 6'd	29	}: data= 8'b	00000000	;
				{2'b11 , 6'd	30	}: data= 8'b	00000000	;
				{2'b11 , 6'd	31	}: data= 8'b	00000000	;
				{2'b11 , 6'd	32	}: data= 8'b	00000000	;
				{2'b11 , 6'd	33	}: data= 8'b	00000000	;
				{2'b11 , 6'd	34	}: data= 8'b	00000000	;
				{2'b11 , 6'd	35	}: data= 8'b	00000000	;
				{2'b11 , 6'd	36	}: data= 8'b	00000000	;
				{2'b11 , 6'd	37	}: data= 8'b	00000000	;
				{2'b11 , 6'd	38	}: data= 8'b	00000000	;
				{2'b11 , 6'd	39	}: data= 8'b	00000000	;
				{2'b11 , 6'd	40	}: data= 8'b	00000000	;
				{2'b11 , 6'd	41	}: data= 8'b	00000000	;
				{2'b11 , 6'd	42	}: data= 8'b	00000000	;
				{2'b11 , 6'd	43	}: data= 8'b	00000000	;
				{2'b11 , 6'd	44	}: data= 8'b	00000000	;
				{2'b11 , 6'd	45	}: data= 8'b	00000000	;
				{2'b11 , 6'd	46	}: data= 8'b	00000000	;
				{2'b11 , 6'd	47	}: data= 8'b	00000000	;
				{2'b11 , 6'd	48	}: data= 8'b	00000000	;
				{2'b11 , 6'd	49	}: data= 8'b	00000000	;
				{2'b11 , 6'd	50	}: data= 8'b	00000000	;
				{2'b11 , 6'd	51	}: data= 8'b	00000000	;
				{2'b11 , 6'd	52	}: data= 8'b	00000000	;
				{2'b11 , 6'd	53	}: data= 8'b	00000000	;
				{2'b11 , 6'd	54	}: data= 8'b	00000000	;
				{2'b11 , 6'd	55	}: data= 8'b	00000000	;
				{2'b11 , 6'd	56	}: data= 8'b	00000000	;
				{2'b11 , 6'd	57	}: data= 8'b	00000000	;
				{2'b11 , 6'd	58	}: data= 8'b	00000000	;
				{2'b11 , 6'd	59	}: data= 8'b	00000000	;
				{2'b11 , 6'd	60	}: data= 8'b	00000000	;
				{2'b11 , 6'd	61	}: data= 8'b	00000000	;
				{2'b11 , 6'd	62	}: data= 8'b	00000000	;
				{2'b11 , 6'd	63	}: data= 8'b	00000000	;
								
								
				//1->0				
				{2'b10 , 6'd	0	}: data= 8'b	11110000	;
				{2'b10 , 6'd	1	}: data= 8'b	00010000	;
				{2'b10 , 6'd	2	}: data= 8'b	00010000	;
				{2'b10 , 6'd	3	}: data= 8'b	00010000	;
				{2'b10 , 6'd	4	}: data= 8'b	00010000	;
				{2'b10 , 6'd	5	}: data= 8'b	00010000	;
				{2'b10 , 6'd	6	}: data= 8'b	00010000	;
				{2'b10 , 6'd	7	}: data= 8'b	00010000	;
				{2'b10 , 6'd	8	}: data= 8'b	00010000	;
				{2'b10 , 6'd	9	}: data= 8'b	00010000	;
				{2'b10 , 6'd	10	}: data= 8'b	00010000	;
				{2'b10 , 6'd	11	}: data= 8'b	00010000	;
				{2'b10 , 6'd	12	}: data= 8'b	00010000	;
				{2'b10 , 6'd	13	}: data= 8'b	00010000	;
				{2'b10 , 6'd	14	}: data= 8'b	00010000	;
				{2'b10 , 6'd	15	}: data= 8'b	00010000	;
				{2'b10 , 6'd	16	}: data= 8'b	00010000	;
				{2'b10 , 6'd	17	}: data= 8'b	00010000	;
				{2'b10 , 6'd	18	}: data= 8'b	00010000	;
				{2'b10 , 6'd	19	}: data= 8'b	00010000	;
				{2'b10 , 6'd	20	}: data= 8'b	00010000	;
				{2'b10 , 6'd	21	}: data= 8'b	00010000	;
				{2'b10 , 6'd	22	}: data= 8'b	00010000	;
				{2'b10 , 6'd	23	}: data= 8'b	00010000	;
				{2'b10 , 6'd	24	}: data= 8'b	00010000	;
				{2'b10 , 6'd	25	}: data= 8'b	00010000	;
				{2'b10 , 6'd	26	}: data= 8'b	00010000	;
				{2'b10 , 6'd	27	}: data= 8'b	00010000	;
				{2'b10 , 6'd	28	}: data= 8'b	00010000	;
				{2'b10 , 6'd	29	}: data= 8'b	00010000	;
				{2'b10 , 6'd	30	}: data= 8'b	00010000	;
				{2'b10 , 6'd	31	}: data= 8'b	00010000	;
				{2'b10 , 6'd	32	}: data= 8'b	00010000	;
				{2'b10 , 6'd	33	}: data= 8'b	00010000	;
				{2'b10 , 6'd	34	}: data= 8'b	00010000	;
				{2'b10 , 6'd	35	}: data= 8'b	00010000	;
				{2'b10 , 6'd	36	}: data= 8'b	00010000	;
				{2'b10 , 6'd	37	}: data= 8'b	00010000	;
				{2'b10 , 6'd	38	}: data= 8'b	00010000	;
				{2'b10 , 6'd	39	}: data= 8'b	00010000	;
				{2'b10 , 6'd	40	}: data= 8'b	00010000	;
				{2'b10 , 6'd	41	}: data= 8'b	00010000	;
				{2'b10 , 6'd	42	}: data= 8'b	00010000	;
				{2'b10 , 6'd	43	}: data= 8'b	00010000	;
				{2'b10 , 6'd	44	}: data= 8'b	00010000	;
				{2'b10 , 6'd	45	}: data= 8'b	00010000	;
				{2'b10 , 6'd	46	}: data= 8'b	00010000	;
				{2'b10 , 6'd	47	}: data= 8'b	00010000	;
				{2'b10 , 6'd	48	}: data= 8'b	00010000	;
				{2'b10 , 6'd	49	}: data= 8'b	00010000	;
				{2'b10 , 6'd	50	}: data= 8'b	00010000	;
				{2'b10 , 6'd	51	}: data= 8'b	00010000	;
				{2'b10 , 6'd	52	}: data= 8'b	00010000	;
				{2'b10 , 6'd	53	}: data= 8'b	00010000	;
				{2'b10 , 6'd	54	}: data= 8'b	00010000	;
				{2'b10 , 6'd	55	}: data= 8'b	00010000	;
				{2'b10 , 6'd	56	}: data= 8'b	00010000	;
				{2'b10 , 6'd	57	}: data= 8'b	00010000	;
				{2'b10 , 6'd	58	}: data= 8'b	00010000	;
				{2'b10 , 6'd	59	}: data= 8'b	00010000	;
				{2'b10 , 6'd	60	}: data= 8'b	00010000	;
				{2'b10 , 6'd	61	}: data= 8'b	00010000	;
				{2'b10 , 6'd	62	}: data= 8'b	00010000	;
				{2'b10 , 6'd	63	}: data= 8'b	00011111	;

		 
		 
		 endcase
	end


endmodule
",squarewave_rom.txt,FPGA_Book_Experiments\squarewave_rom.txt
"[Keyword]: sqwave_gen

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a square wave generator that produces a square wave output with configurable ON and OFF periods. The ON period is determined by the input `m`, and the OFF period is determined by the input `n`. Both periods are measured in units of 100ns, and the design operates with a clock frequency of 50MHz.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operation of the circuit.
- `rst_n`: Active-low reset signal that initializes the circuit to a known state.
- `m[3:0]`: 4-bit input that specifies the duration of the ON period in units of 100ns.
- `n[3:0]`: 4-bit input that specifies the duration of the OFF period in units of 100ns.

[Output Signal Description]:
- `out`: The output signal that represents the generated square wave. It toggles between high and low states based on the configured ON and OFF periods.


[Design Detail]:
`timescale 1ns / 1ps

module sqwave_gen(
	input clk,rst_n,
	input[3:0] m,n,
	output out
    );
	 
	 reg[6:0] m_reg=0,n_reg=0; //counter for ON period of m*(100ns) and OFF period of n*(100ns)
	 reg sq_reg=0; //square wave output
	 reg[6:0] m_nxt=0,n_nxt=0;
	 reg sq_nxt=0;
	 reg m_max=0,n_max=0;
	 
	 //registers
	 always @(posedge clk,negedge rst_n) begin
		 if(!rst_n) begin
			m_reg<=0;
			n_reg<=0;
			sq_reg<=0;
		end
		
		else begin
			m_reg<=m_nxt;
			n_reg<=n_nxt;
			sq_reg<=sq_nxt;
		end
	end
	
	//next-state logic
	always @* begin
	m_nxt=m_reg;
	n_nxt=n_reg;
	m_max=0;
	n_max=0;
	sq_nxt=0;
		
		if( m==4'd0 || n==4'd0) begin  //if m or n is zero then out must remain in one position
			m_nxt=0;
			n_nxt=0;
			casez({|m,|n}) //reduction operator
			2'b00: sq_nxt=0;
			2'b01: sq_nxt=0;
			2'b10: sq_nxt=1;
			default: sq_nxt=0;
			endcase
		end
		
		//OFF logic with duration of n*100ns
		else if(sq_reg==0) begin
			m_nxt=0;
			n_nxt=(n_reg==5*n-1)?0:n_reg+1;  //50MHz*100ns*n=5*n
			n_max=(n_reg==5*n-1)?1:0;        //50MHz*100ns*n=5*n
			sq_nxt=n_max?1:0;
			end
		//ON logic with duration of m*100ns
		else if(sq_reg==1) begin
			n_nxt=0;
			m_nxt=(m_reg==5*m-1)?0:m_reg+1;
			m_max=(m_reg==5*m-1)?1:0;
			sq_nxt=m_max?0:1;
		end
	end
	
	assign out=sq_reg;
		
endmodule
",sqwave_gen.txt,FPGA_Book_Experiments\sqwave_gen.txt
"[Keyword]: Stack

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a stack data structure with parameterizable width and depth. The stack supports push and pop operations, allowing data to be written to and read from the stack. It maintains status flags to indicate whether the stack is empty or full.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing operations.
- `rst`: Reset signal to initialize the stack to its default state.
- `wr_data[B-1:0]`: Data input for writing to the stack.
- `push`: Control signal to push data onto the stack.
- `pop`: Control signal to pop data from the stack.

[Output Signal Description]:
- `empty`: Status flag indicating if the stack is empty.
- `full`: Status flag indicating if the stack is full.
- `rd_data[B-1:0]`: Data output for reading from the stack.
- `stack_ptr[W-1:0]`: Current position of the stack pointer.


[Design Detail]:
`timescale 1ns / 1ps

module Stack
	#(parameter W=4,B=8)
	(
	input clk,rst,
	input [B-1:0] wr_data,
	input push,pop, //write,read
	output reg empty,full,
	output[B-1:0] rd_data,
	output[W-1:0] stack_ptr
    );
	 
	 initial begin
	 empty=1;
	 full=0;
	 end
	 
	 reg[B-1:0] array_reg[2**W-1:0];
	 reg[W-1:0] stack_pointer=0;
	 reg empty_nxt,full_nxt;
	 reg[W-1:0] stack_pointer_nxt=0;
	 
	 //register-file operation
	 always @(posedge clk) begin
	 if(!full && push) //synchronous write
		array_reg[stack_pointer]<=wr_data;
	 end
	 assign rd_data=array_reg[stack_pointer];  //asynchronous read
	 
	 //register operations
	 always @(posedge clk,posedge rst) begin
		if(rst) begin 
			stack_pointer<=0;
			empty<=1;
			full<=0;
		end
		else begin
			stack_pointer<=stack_pointer_nxt;
			empty<=empty_nxt;
			full<=full_nxt;
		end
	 end
	 
	 //next-state logics
	 always @* begin
	 stack_pointer_nxt=stack_pointer;
	 full_nxt=full;
	 empty_nxt=empty;
		 case({push,pop})
			//2'b00: do nothing
			2'b01: if(!empty) begin //read
						stack_pointer_nxt=stack_pointer-1;
						full_nxt=0;
						empty_nxt=(stack_pointer_nxt==0)?1:0;
					 end
			2'b10: if(!full) begin//write
						stack_pointer_nxt=stack_pointer+1;
						empty_nxt=0;
						full_nxt=(stack_pointer_nxt==0)?1:0;
					 end
			//2'b11: after writing,read it immediately, THUS STACK_POINTER WILL NOT MOVE		 
			
		 endcase
	 end
	 assign stack_ptr=stack_pointer;

	 


endmodule
",Stack.txt,FPGA_Book_Experiments\Stack.txt
"[Keyword]: timer

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 2-second countdown timer. The timer starts counting down from a preset value when triggered and signals when the countdown reaches zero.

[Input Signal Description]:
- clk: Clock signal used to synchronize the timer operations.
- rst_n: Active-low reset signal to initialize or reset the timer.
- timer_start: Signal to start the timer countdown from the preset value.
- timer_tick: Signal that ticks at 60Hz, used to decrement the timer value.

[Output Signal Description]:
- timer_up: Output signal that indicates the timer has reached zero.



[Design Detail]:
`timescale 1ns / 1ps

module timer( //2 second timer
	input clk,rst_n,
	input timer_start,timer_tick,
	output timer_up
    );
	 
	 reg[6:0] timer_q=0,timer_d;
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) timer_q<=0;
		else timer_q<=timer_d;
	 end
	 
	 always @* begin
		timer_d=timer_q;
		if(timer_start) begin
			timer_d=7'b111_1111;
		end
		else if(timer_tick) begin //timer tick is 60Hz, thus 2 seconds will be after 120 ticks(or 7'b111_1111)
			timer_d=(timer_q==0)? 0:timer_q-1;
		end
	 end
	 assign timer_up= (timer_q==0);


endmodule
",timer.txt,FPGA_Book_Experiments\timer.txt
"[Keyword]: top_bitmap_gen

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a VGA signal generator that produces video output signals for a display. It includes a clock management module to generate a 25MHz clock signal, a VGA core to handle synchronization and video timing, and a bitmap generator to produce the RGB video signals based on the current pixel position and input keys.

[Input Signal Description]:
- `clk`: The main clock input signal for the system.
- `rst_n`: An active-low reset signal to initialize the system.
- `key[3:0]`: A 4-bit input signal used to control or modify the bitmap generation, potentially affecting the video output.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit output signal for the red component of the VGA video signal.
- `vga_out_g[5:0]`: 6-bit output signal for the green component of the VGA video signal.
- `vga_out_b[4:0]`: 5-bit output signal for the blue component of the VGA video signal.
- `vga_out_vs`: Vertical synchronization signal for the VGA output.
- `vga_out_hs`: Horizontal synchronization signal for the VGA output.


[Design Detail]:
`timescale 1ns / 1ps

module top_bitmap_gen
	(
		input clk, rst_n,
		input[3:0] key,
		output[4:0] vga_out_r,
		output[5:0] vga_out_g,
		output[4:0] vga_out_b,
		output vga_out_vs,vga_out_hs
    );
	 
	wire clk_out;
	wire video_on;
	wire[11:0] pixel_x,pixel_y;
	dcm_25MHz m0
   (// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );
	 vga_core m1
	(
		.clk(clk_out),
		.rst_n(rst_n), //clock must be 25MHz for 640x480 
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );
	 
	 bitmap_gen m2 
	 (
		.clk(clk_out),
		.rst_n(rst_n),
		.key(key),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.vga_out_r(vga_out_r),
		.vga_out_g(vga_out_g),
		.vga_out_b(vga_out_b)
    );	
	 
	 
	 
endmodule 






",top_bitmap_gen.txt,FPGA_Book_Experiments\top_bitmap_gen.txt
"[Keyword]: top_module

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a UART (Universal Asynchronous Receiver-Transmitter) interface with additional features such as autobaud and autoparity detection. It includes a finite state machine (FSM) to manage different states of operation, such as idle, baud rate detection, data bits, stop bits, and parity checking. The design also handles error detection for frame, parity, and overrun errors, and displays relevant information on a seven-segment display.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `btn0`: Button input used as an ""enter"" key to transition between states.
- `btn1`: Button input to activate the autobaud-parity detector.
- `rx`: Serial data input for receiving data.
- `rd_uart`: Read enable signal for reading data from the UART.
- `wr_uart`: Write enable signal for writing data to the UART.
- `wr_data[7:0]`: 8-bit data input for writing to the UART.

[Output Signal Description]:
- `rd_data[7:0]`: 8-bit data output for reading from the UART.
- `tx`: Serial data output for transmitting data.
- `rx_empty`: Indicates if the receive buffer is empty.
- `tx_empty`: Indicates if the transmit buffer is empty.
- `seg_out[7:0]`: Output for driving a seven-segment display.
- `sel_out[5:0]`: Select lines for multiplexing the seven-segment display.











[Design Detail]:
`timescale 1ns / 1ps

module top_module(
	input clk,rst_n,
	input btn0,btn1, //btn0=enter key , btn1=activate the autobaud-parity detector then wait for the """" and ""p"" input
	input rx, 
	input rd_uart,wr_uart,
	input[7:0] wr_data,
	output[7:0] rd_data,
	output tx,
	output rx_empty,tx_empty,
	output[7:0] seg_out,
	output[5:0] sel_out
    );
	 
	 //FSM state declarations and all wires-reg
	 localparam[2:0] idle=3'd0,
							baud=3'd1,
							databits=3'd2,
							stopbits=3'd3,
							parity=3'd4,
							start=3'd5;
	 wire key0;	
	 wire s_tick;
	 wire rx_done_tick;
	 wire[7:0] dout,tx_read_data;
	 wire parity_error,frame_error;
	 wire rx_full;
	 wire[7:0] tx_rd_data;
	 wire autobaud_done,bin2bcd_done;
	 wire[3:0] dig0,dig1,dig2,dig3,dig4,dig5;
	 wire[1:0] paritybit; //0=no parity , 1=odd parity , 2=even parity
	 wire[11:0] baud_dvsr;
	 wire[17:0] baud_rate;
	 reg[4:0] in0,in1,in2,in3,in4,in5;	
	 
	 reg[2:0] state_reg,state_nxt;
	 reg overrun_reg,overrun_nxt;
 	 reg[1:0] error_reg;
	 reg[29:0] parity_disp[2:0];
	 reg[29:0] error_disp[3:0];
	


	 //values for the seven segments
	 initial begin
		parity_disp[0]={{5'd29},{5'd29},{5'd21},{5'd22},{5'd21},{5'd14}}; //NONE
		parity_disp[1]={{5'd29},{5'd29},{5'd29},{5'd22},{5'd13},{5'd13}}; //Odd
		parity_disp[2]={{5'd29},{5'd29},{5'd14},{5'd26},{5'd14},{5'd21}}; //EVEN
		
		error_disp[0]={{5'd30},{5'd30},{5'd30},{5'd30},{5'd30},{5'd30}}; //-----
		error_disp[1]={{5'd15},{5'd24},{5'd10},{5'd30},{5'd14},{5'd24}}; //FRA-ER    frame error
		error_disp[2]={{5'd23},{5'd10},{5'd24},{5'd30},{5'd14},{5'd24}}; //PAR-ER    parity error
		error_disp[3]={{5'd22},{5'd26},{5'd24},{5'd30},{5'd14},{5'd24}}; //OVR-ER    overrun error
	 end
	 
	 //FSM register operations
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			overrun_reg<=0;
		end
		
		else begin
			state_reg<=state_nxt;
			overrun_reg<=overrun_nxt;
		end
	 end
	 
	 //FSM  next-state logics
	 always @*begin
		state_nxt=state_reg;
		error_reg=0;
		{in5,in4,in3,in2,in1,in0}={{5'd29},{5'd29},{5'd29},{5'd29},{5'd29},{5'd29}};
		case(state_reg) 
				 idle: if(bin2bcd_done==1) state_nxt=baud; 	
			  	 baud: begin //display the detected baud rate
							{in5,in4,in3,in2,in1,in0}={{1'b0,dig5},{1'b0,dig4},{1'b0,dig3},{1'b0,dig2},{1'b0,dig1},{1'b0,dig0}};
							if(key0==1) state_nxt=databits;
						 end
			databits: begin //display number of databits(which is fixed to 8)
							{in5,in4,in3,in2,in1,in0}={{5'd29},{5'd29},{5'd29},{5'd29},{5'd29},{5'd8}};
							if(key0==1) state_nxt=stopbits;
						 end
			stopbits: begin //display number of stopbits(which is fixed to 1)
							{in5,in4,in3,in2,in1,in0}={{5'd29},{5'd29},{5'd29},{5'd29},{5'd29},{5'd1}};
							if(key0==1) state_nxt=parity;
						 end
			  parity: begin //cdisplay the detected type of parity
							{in5,in4,in3,in2,in1,in0}=parity_disp[paritybit];
							if(key0==1) state_nxt=start;
						 end
			   start: begin //detects error , stays here until reset 		
							if(frame_error) error_reg=1;
							else if(parity_error) error_reg=2;
							else if(overrun_reg) error_reg=3;
							{in5,in4,in3,in2,in1,in0}=error_disp[error_reg];
						 end
			 default: state_nxt=idle;
		endcase
	 end
	 
	 //overrun_error logic
	 always @* begin
		overrun_nxt=overrun_reg; 
		if(rx_full && rx_done_tick) overrun_nxt=1;
		else if((!rx_full && rx_done_tick) || rd_uart) overrun_nxt=0;
	 end
	 
	 
	 //module instantiations
	autobaud_plus_autoparity m00(
		.clk(clk),
		.rst_n(rst_n),
		.key0(btn1),
		.rx(rx),
		.s_tick(s_tick),
		.baud_dvsr(baud_dvsr),
		.baud_rate(baud_rate),
		.done_tick(autobaud_done),
		.paritybit(paritybit)
    );
	 
	debounce_explicit m0
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw({!btn0}),
		.db_level(),
		.db_tick(key0)
    );

	 baud_generator m1
	(
		.clk(clk),
		.rst_n(rst_n),
		.baud_dvsr(baud_dvsr), //2605 for 12000baud , 1303 for 2400baud , 652 for 4800baud , 326 for 9600baud , 162 for 19200 , 27 for 115200
		.s_tick(s_tick)
    );
	 
	uart_rx m2 //receiver
	(
		.clk(clk),
		.rst_n(rst_n),
		.rx(rx),
		.s_tick(s_tick),
		.databits(8), //either 8 or 7 databits
		.stopbits(16), //either 16 or 32 ticks for 1 and 2 stopbits,respectively
		.paritybit(paritybit), //0-no parity, 1=odd parity , 2=even parity
		.rx_done_tick(rx_done_tick),
		.dout(dout),
		.parity_error(parity_error), //high if there is error
		.frame_error(frame_error) //high if there is error
    );
	 
	fifo #(.W(4),.B(8)) m3 //8x2^2 fifo
	(
		.clk(clk),
		.rst_n(rst_n),
		.wr(rx_done_tick),
		.rd(rd_uart),
		.wr_data(dout),
		.rd_data(rd_data),
		.full(rx_full),
		.empty(rx_empty)
    );
	 
	 uart_tx m4
	(
		.clk(clk),
		.rst_n(rst_n),
		.s_tick(s_tick),
		.tx_start(tx_empty),
		.din(tx_rd_data),
		.databits(8), //either 8 or 7 databits
		.stopbits(16), //either 16 or 32 ticks for 1 and 2 stopbits,respectively
		.paritybit(paritybit), //0-no parity, 1=odd parity , 2=even parity
		.tx_done_tick(tx_done_tick),
		.tx(tx)
    );
	 
	 fifo #(.W(4),.B(8)) m5 //8x2^2 fifo
	(
		.clk(clk),
		.rst_n(rst_n),
		.wr(wr_uart),
		.rd(tx_done_tick),
		.wr_data(wr_data),
		.rd_data(tx_rd_data),
		.full(),
		.empty(tx_empty)
    );
	 
	 LED_mux m6
	(
		.clk(clk),
		.rst(rst_n),
		.in0({1'b0,in0}),
		.in1({1'b0,in1}),
		.in2({1'b0,in2}),
		.in3({1'b0,in3}),
		.in4({1'b0,in4}),
		.in5({1'b0,in5}), //format: {dp,char[4:0]} , dp is active high
		.seg_out(seg_out),
		.sel_out(sel_out)
    );
	 
	bin2bcd m7
	(
		.clk(clk),
		.rst_n(rst_n),
		.start(autobaud_done),
		.bin(baud_rate),
		.ready(),
		.done_tick(bin2bcd_done),
		.dig0(dig0),
		.dig1(dig1),
		.dig2(dig2),
		.dig3(dig3),
		.dig4(dig4),
		.dig5(dig5),
		.dig6(),
		.dig7(),
		.dig8(),
		.dig9(),
		.dig10()
    );

endmodule
",top_module.txt,FPGA_Book_Experiments\top_module.txt
"[Keyword]: top_pong_animated

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a VGA interface for an animated Pong game. It includes a clock management module to generate a 25MHz clock signal, a VGA core for generating synchronization signals and pixel coordinates, and a Pong game module that outputs RGB signals for display. The game features a classic Pong setup with breakable bricks instead of a solid wall.

[Input Signal Description]:
- `clk`: Clock input signal for the system.
- `rst_n`: Active-low reset signal to initialize the system.
- `key[1:0]`: 2-bit input for controlling the paddle movement; `key[1]` moves the paddle down, and `key[0]` moves it up.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit red component of the VGA output.
- `vga_out_g[5:0]`: 6-bit green component of the VGA output.
- `vga_out_b[4:0]`: 5-bit blue component of the VGA output.
- `vga_out_vs`: Vertical synchronization signal for VGA.
- `vga_out_hs`: Horizontal synchronization signal for VGA.


[Design Detail]:
`timescale 1ns / 1ps
module top_pong_animated
	(
		input clk, rst_n,
		input[1:0] key, //key[1] to move down,key[0] to move up
		output[4:0] vga_out_r,
		output[5:0] vga_out_g,
		output[4:0] vga_out_b,
		output vga_out_vs,vga_out_hs
    );
	 
	wire clk_out;
	wire video_on;
	wire[11:0] pixel_x,pixel_y;
	dcm_25MHz m0
   (// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );
	 
	 vga_core m1  //clock must be 25MHz for 640x480 
	(
		.clk(clk_out),
		.rst_n(rst_n), 
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );
	 
	 pong_animated m2 //classic pong game but with breakable ""bricks"" rather than wall
	 (
		.clk(clk_out),
		.rst_n(rst_n),
		.key(key),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.r(vga_out_r),
		.g(vga_out_g),
		.b(vga_out_b)
    );	
	 
	 
	 
endmodule 
",top_pong_animated.txt,FPGA_Book_Experiments\top_pong_animated.txt
"[Keyword]: two_balls_in_a_box

[Design Category]: Control Circuits

[Design Function Description]:
This design simulates a graphical display of two bouncing balls within a defined box on a screen. The balls can change speed and location based on input keys. The design includes logic for detecting collisions with the walls and between the balls, and it updates the ball positions and wall colors accordingly. The output is a video signal with RGB values representing the balls, walls, and background.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the circuit operations.
- `rst_n`: Active-low reset signal to initialize or reset the circuit.
- `video_on`: Signal indicating whether the video display is active.
- `key[1:0]`: 2-bit input for controlling the ball speed (`key[0]`) and changing the ball location (`key[1]`).
- `pixel_x`: 12-bit horizontal pixel coordinate for the display.
- `pixel_y`: 12-bit vertical pixel coordinate for the display.

[Output Signal Description]:
- `r[4:0]`: 5-bit red color component of the output video signal.
- `g[5:0]`: 6-bit green color component of the output video signal.
- `b[4:0]`: 5-bit blue color component of the output video signal.


[Design Detail]:
`timescale 1ns / 1ps

module two_balls_in_a_box
	(
		input clk,rst_n,
		input video_on,
		input[1:0] key, //key[0] for changing  ball speed, key[2] to change location of ball
		input[11:0] pixel_x,pixel_y,
		output reg[4:0] r,
		output reg[5:0] g,
		output reg[4:0] b
    );			
				//SCREEN BOUNDARIES FOR A 100x100 BOX
				
						//LEFT WALL
	 localparam LWALL_XL=260, //left
					LWALL_XR=270, //right
					LWALL_YT=180, //top
					LWALL_YB=300, //bottom
					
						//RIGHT WALL
					RWALL_XL=370, //left
					RWALL_XR=380, //right
					RWALL_YT=180, //top
					RWALL_YB=300, //bottom
						
						//TOP WALL
					TWALL_XL=260, //left
					TWALL_XR=380, //right
					TWALL_YT=180, //top
					TWALL_YB=190, //bottom
						
						//BOTTOM WALL
					BWALL_XL=260, //left
					BWALL_XR=380, //right
					BWALL_YT=290, //top
					BWALL_YB=300, //bottom
					
					
					
					ball_DIAM=15; //ball diameter minus one


	 reg[4:0] ball_V[3:0]; //stores current speed of ball
	 reg[1:0] ball_v_q=0,ball_v_d; //address for ball_V
	 
	 initial begin //list of available ball speeds
		ball_V[0]=5'd1;
		ball_V[1]=5'd5;
		ball_V[2]=5'd10;
		ball_V[3]=5'd20;
	 end
	
					
	 wire lwall_on,r_wall_on,twall_on,bwall_on,ball_1_box,ball_2_box;
	 wire key0_tick,key1_tick;
	
	 reg[2:0] lwall_q,lwall_d,rwall_q,rwall_d,twall_q,twall_d,bwall_q,bwall_d; //stores color of walls
	 reg ball_1_on,ball_2_on;
	 reg holder_q=0,holder_d; //place holder to prevent consecutive bounce which will cause the balls to lock up on each other
	 reg[3:0] rom_addr; //rom for circular pattern of ball
	 reg[15:0] rom_data;
	 reg[9:0] ball_1x_q=280,ball_1x_d,ball_2x_q=100,ball_2x_d; //stores left X value of the TWO bouncing ball
	 reg[9:0] ball_1y_q=200,ball_1y_d,ball_2y_q=100,ball_2y_d; //stores upper Y value of the TWO bouncing ball
	 reg ball_1xdelta_q=0,ball_1xdelta_d,ball_2xdelta_q=0,ball_2xdelta_d; //stores  x-direction(right or left) movement of the TWO bouncing balls
	 reg ball_1ydelta_q=0,ball_1ydelta_d,ball_2ydelta_q=0,ball_2ydelta_d; //stores  y-direction(up or down) movement of the TWO bouncing balls
	 
	 //display conditions for the four walls
	 assign lwall_on= LWALL_XL<=pixel_x && pixel_x<=LWALL_XR && LWALL_YT<=pixel_y && pixel_y<=LWALL_YB;
	 assign rwall_on= RWALL_XL<=pixel_x && pixel_x<=RWALL_XR && RWALL_YT<=pixel_y && pixel_y<=RWALL_YB;
	 assign twall_on= TWALL_XL<=pixel_x && pixel_x<TWALL_XR && TWALL_YT<=pixel_y && pixel_y<=TWALL_YB;
	 assign bwall_on= BWALL_XL<=pixel_x && pixel_x<BWALL_XR && BWALL_YT<=pixel_y && pixel_y<=BWALL_YB;

	
	 assign ball_1_box= ball_1x_q<=pixel_x && pixel_x<=(ball_1x_q+ball_DIAM) &&  ball_1y_q<=pixel_y && pixel_y<=(ball_1y_q+ball_DIAM);
	 assign ball_2_box= ball_2x_q<=pixel_x && pixel_x<=(ball_2x_q+ball_DIAM) &&  ball_2y_q<=pixel_y && pixel_y<=(ball_2y_q+ball_DIAM);

	 
	 //circular ball_on logic
	 always @* begin
		rom_addr=0;
		ball_1_on=0;
		ball_2_on=0;
		if(ball_1_box) begin
			rom_addr=pixel_y-ball_1y_q;
			if(rom_data[pixel_x-ball_1x_q]) ball_1_on=1;
		end
		if(ball_2_box) begin
			rom_addr=pixel_y-ball_2y_q;
			if(rom_data[pixel_x-ball_2x_q]) ball_2_on=1;
		end
	 end
	 
	 //ball rom pattern
	 always @* begin
		 case(rom_addr)
			0: rom_data=16'b0000_0001_1000_0000;
			1: rom_data=16'b0000_0011_1100_0000;
			2: rom_data=16'b0000_0111_1110_0000;
			3: rom_data=16'b0000_1111_1111_0000;
			4: rom_data=16'b0001_1111_1111_1000;
			5: rom_data=16'b0011_1111_1111_1100;
			6: rom_data=16'b0111_1111_1111_1110;
			7: rom_data=16'b1111_1111_1111_1111;
			8: rom_data=16'b1111_1111_1111_1111;
			9: rom_data=16'b0111_1111_1111_1110;
			10: rom_data=16'b0011_1111_1111_1100;
			11: rom_data=16'b0001_1111_1111_1000;
			12: rom_data=16'b0000_1111_1111_0000;
			13: rom_data=16'b0000_0111_1110_0000;
			14: rom_data=16'b0000_0011_1100_0000;
			15: rom_data=16'b0000_0001_1000_0000;
		 endcase
	 end
	 
	 //register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin 
				//initial is center of screen
			ball_1x_q<=300;
			ball_1y_q<=300;
			ball_1xdelta_q<=0;
			ball_1xdelta_q<=0;
			
			ball_2x_q<=250;
			ball_2y_q<=250;
			ball_2xdelta_q<=0;
			ball_2xdelta_q<=0;
			
			lwall_q<=0;
			rwall_q<=0;
			twall_q<=0;
			bwall_q<=0;
			ball_v_q<=0;
			holder_q<=0;
		end
		else begin
			ball_1x_q<=ball_1x_d;
			ball_1y_q<=ball_1y_d;
			ball_1xdelta_q<=ball_1xdelta_d;
			ball_1ydelta_q<=ball_1ydelta_d;
			
			ball_2x_q<=ball_2x_d;
			ball_2y_q<=ball_2y_d;
			ball_2xdelta_q<=ball_2xdelta_d;
			ball_2ydelta_q<=ball_2ydelta_d;
			
			lwall_q<=lwall_d;
			rwall_q<=rwall_d;
			twall_q<=twall_d;
			bwall_q<=bwall_d;
			ball_v_q<=ball_v_d;
			holder_q<=holder_d;
		end
	 end
	 
	 
	 //logic for self-bouncing ball
	 always @* begin
		ball_1x_d=ball_1x_q;
		ball_1y_d=ball_1y_q;
		ball_1xdelta_d=ball_1xdelta_q;
		ball_1ydelta_d=ball_1ydelta_q;
		
		ball_2x_d=ball_2x_q;
		ball_2y_d=ball_2y_q;
		ball_2xdelta_d=ball_2xdelta_q;
		ball_2ydelta_d=ball_2ydelta_q;
		
		lwall_d=lwall_q;
		rwall_d=rwall_q;
		twall_d=twall_q;
		bwall_d=bwall_q;
		ball_v_d=ball_v_q;
		holder_d=holder_q;
		
			if(key0_tick) begin //change ball location based on current scan location
				ball_1x_d=pixel_x;
				ball_1y_d=pixel_y;
				ball_2x_d=pixel_y;
				ball_2y_d=pixel_x;
			end
			
	
			else if(pixel_y==500 && pixel_x==0) begin//1 tick when video is surely off
			
				lwall_d=3'b010; //default wall color is green
				rwall_d=3'b010;
				twall_d=3'b010;
				bwall_d=3'b010;
				
				//bouncing ball #1 logic
				if(ball_1x_q<=LWALL_XR) begin //bounce from left wall
					ball_1xdelta_d=1; 
					lwall_d=3'b100;
				end
				else if(RWALL_XL<=ball_1x_q+ball_DIAM) begin  //bounce from right wall
					ball_1xdelta_d=0;
					rwall_d=3'b001;
				end
				if(ball_1y_q<=TWALL_YB) begin //bounce from top wall
					ball_1ydelta_d=1; 
					twall_d=3'b110;
				end
				else if(BWALL_YT<=ball_1y_q+ball_DIAM) begin //bounce from bottom wall
					ball_1ydelta_d=0; 
					bwall_d=3'b011;
				end
				
				
				//bouncing ball #2 logic
				if(ball_2x_q<=LWALL_XR) begin //bounce from left wall
					ball_2xdelta_d=1; 
					lwall_d=3'b100;
				end
				else if(RWALL_XL<=ball_2x_q+ball_DIAM) begin  //bounce from right wall
					ball_2xdelta_d=0;
					rwall_d=3'b001;
				end
				if(ball_2y_q<=TWALL_YB) begin
					ball_2ydelta_d=1; //bounce from top wall
					twall_d=3'b110;
				end
				else if(BWALL_YT<=ball_2y_q+ball_DIAM) begin
					ball_2ydelta_d=0; //bounce from bottom wall
					bwall_d=3'b011;
				end
				
				//colliding balls
				if( (ball_2y_q<=ball_1y_q+ball_DIAM) && (ball_1y_q<=ball_2y_q+ball_DIAM) && (ball_2x_q<=ball_1x_q+ball_DIAM) && (ball_1x_q<=ball_2x_q+ball_DIAM) ) begin //balls collide
					if(!holder_q) begin //no consecutive bounce to avoid the balls from locking up each other
					
						//logic for colliding balls that follows(slightly) the laws of physics
						case({{ball_1xdelta_q,ball_1ydelta_q},{ball_2xdelta_q,ball_2ydelta_q}})
							  4'b1100 , 4'b0011: begin
															if(ball_1x_q>=ball_2x_q) begin
																ball_1xdelta_d=1;
																ball_1ydelta_d=0;
																ball_2xdelta_d=0;
																ball_2ydelta_d=1;
															end
															else begin
																ball_1xdelta_d=0;
																ball_1ydelta_d=1;
																ball_2xdelta_d=1;
																ball_2ydelta_d=0;
															end
														end
							  4'b0110 , 4'b1001: begin
															if(ball_1y_q>=ball_2y_q) begin
																ball_1xdelta_d=1;
																ball_1ydelta_d=1;
																ball_2xdelta_d=0;
																ball_2ydelta_d=0;
															end
															else begin
																ball_1xdelta_d=0;
																ball_1ydelta_d=0;
																ball_2xdelta_d=1;
																ball_2ydelta_d=1;
															end
														end
											4'b1101: begin
															ball_1xdelta_d=0;
															ball_1ydelta_d=1;
															ball_2xdelta_d=1;
															ball_2ydelta_d=1;
														 end
											4'b0111: begin
															ball_1xdelta_d=1;
															ball_1ydelta_d=1;
															ball_2xdelta_d=0;
															ball_2ydelta_d=1;
														 end
											4'b1000: begin
															ball_1xdelta_d=0;
															ball_1ydelta_d=0;
															ball_2xdelta_d=1;
															ball_2ydelta_d=0;
														end
											4'b0010: begin
															ball_1xdelta_d=1;
															ball_1ydelta_d=0;
															ball_2xdelta_d=0;
															ball_2ydelta_d=0;
														end
							endcase
							holder_d=1;
						end
				end
				else holder_d=0;
				
				
				
				
				ball_1x_d=ball_1xdelta_d? (ball_1x_q+ball_V[ball_v_q]):(ball_1x_q-ball_V[ball_v_q]);
				ball_1y_d=ball_1ydelta_d? (ball_1y_q+ball_V[ball_v_q]):(ball_1y_q-ball_V[ball_v_q]);
				
				ball_2x_d=ball_2xdelta_d? (ball_2x_q+ball_V[ball_v_q]):(ball_2x_q-ball_V[ball_v_q]);
				ball_2y_d=ball_2ydelta_d? (ball_2y_q+ball_V[ball_v_q]):(ball_2y_q-ball_V[ball_v_q]);
			end
			
			if(key1_tick) ball_v_d=ball_v_q+1; //change ball speed
	 end
	 
	 
	 //overall display logic
	always @* begin
	 	r=0;
		g=0;
		b=0;
		if(video_on) begin
		
			if(ball_1_on) b={5{1'b1}}; //ball 1 color 
			else if(ball_2_on) r={5{1'b1}}; //ball 2 color
			
			else if(rwall_on) begin  //right wall color
				r={5{rwall_q[2]}};
				g={6{rwall_q[1]}};
				b={5{rwall_q[0]}};
			end
			else if(lwall_on) begin   //left wall color
				r={5{lwall_q[2]}};
				g={6{lwall_q[1]}};
				b={5{lwall_q[0]}};
			end
			else if(twall_on) begin //top wall color
				r={5{twall_q[2]}};
				g={6{twall_q[1]}};
				b={5{twall_q[0]}};
			end
			else if(bwall_on) begin //bottom wall color
				r={5{bwall_q[2]}};
				g={6{bwall_q[1]}};
				b={5{bwall_q[0]}};
			end
			else if(LWALL_XR<=pixel_x && pixel_x<=RWALL_XL && TWALL_YB<=pixel_y && pixel_y<=BWALL_YT) begin //color inside box
				g={6{1'b1}};
				b={5{1'b1}};
			end
			else begin //color outside box
				r={5{1'b1}};
				g={6{1'b1}};
				b={5{1'b1}};
			end
		end
	 end
	 
	 debounce_explicit m0
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[0]),
		.db_level(),
		.db_tick(key0_tick)
    );
	 debounce_explicit m1
	(
		.clk(clk),
		.rst_n(rst_n),
		.sw(key[1]),
		.db_level(),
		.db_tick(key1_tick)
    );
					
endmodule


",two_balls_in_a_box.txt,FPGA_Book_Experiments\two_balls_in_a_box.txt
"[Keyword]: uart

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a Universal Asynchronous Receiver-Transmitter (UART) interface. The UART module facilitates serial communication by converting parallel data from the system into serial data for transmission and vice versa for reception. It includes baud rate generation, data transmission, and reception with FIFO buffers for handling data flow.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `rd_uart`: Read enable signal for reading data from the receive FIFO.
- `wr_uart`: Write enable signal for writing data to the transmit FIFO.
- `wr_data[7:0]`: 8-bit data input for transmission.
- `rx`: Serial data input for receiving data.

[Output Signal Description]:
- `tx`: Serial data output for transmitting data.
- `rd_data[7:0]`: 8-bit data output from the receive FIFO.
- `rx_empty`: Signal indicating if the receive FIFO is empty.
- `tx_full`: Signal indicating if the transmit FIFO is full.












[Design Detail]:
`timescale 1ns / 1ps

   module uart
	#(parameter DBIT=8,SB_TICK=16,DVSR=326,DVSR_WIDTH=9,FIFO_W=2)
	(
	input clk,rst_n,
	input rd_uart,wr_uart,
	input[7:0] wr_data,
	input rx,
	output tx,
	output[7:0] rd_data,
	output rx_empty,tx_full
    );

	 
	 wire s_tick,rx_done_tick,empty;
	 wire[7:0] dout,rd_data_tx;
	 
	 
	baud_generator #(.N(DVSR),.N_width(DVSR_WIDTH)) m0
	(
	.clk(clk),
	.rst_n(rst_n),
	.s_tick(s_tick)
    );
	 
	 uart_rx #(.DBIT(DBIT),.SB_TICK(SB_TICK)) m1 //DBIT=data bits , SB_TICK=ticks for stop bit (16 for 1 bit ,32 for 2 bits)
	(
		.clk(clk),
		.rst_n(rst_n),
		.rx(rx),
		.s_tick(s_tick),
		.rx_done_tick(rx_done_tick),
		.dout(dout)
    );
	 fifo #(.W(FIFO_W),.B(DBIT)) m2
	(
		.clk(clk),
		.rst_n(rst_n),
		.wr(rx_done_tick),
		.rd(rd_uart),
		.wr_data(dout),
		.rd_data(rd_data),
		.full(),
		.empty(rx_empty)
    );
	uart_tx #(.DBIT(DBIT),.SB_TICK(SB_TICK)) m3
	(
		.clk(clk),
		.rst_n(rst_n),
		.s_tick(s_tick), 
		.tx_start(empty),
		.din(rd_data_tx),
		.tx_done_tick(tx_done_tick),
		.tx(tx)
    );
	 fifo #(.W(FIFO_W),.B(DBIT)) m4
	(
		.clk(clk),
		.rst_n(rst_n),
		.wr(wr_uart),
		.rd(tx_done_tick),
		.wr_data(wr_data),
		.rd_data(rd_data_tx),
		.full(tx_full),
		.empty(empty)
    );

endmodule
",uart.txt,FPGA_Book_Experiments\uart.txt
"[Keyword]: uart_rx

[Design Category]: Interface Circuits

[Design Function Description]:
This design implements a UART (Universal Asynchronous Receiver-Transmitter) receiver module. It is responsible for receiving serial data, processing it according to the specified data bits, stop bits, and parity settings, and then outputting the received data in parallel form. The module also checks for parity and frame errors during the reception process.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the operations of the module.
- `rst_n`: Active-low reset signal to initialize the module's state.
- `rx`: Serial data input line where the data is received.
- `s_tick`: Sampling tick signal used to determine the timing for sampling the incoming data.
- `databits[3:0]`: Specifies the number of data bits (either 7 or 8) to be received.
- `stopbits[5:0]`: Specifies the number of ticks for stop bits (either 16 or 32 ticks for 1 or 2 stop bits, respectively).
- `paritybit[1:0]`: Specifies the parity setting (0 for no parity, 1 for odd parity, 2 for even parity).

[Output Signal Description]:
- `rx_done_tick`: A signal that goes high when a complete data frame has been successfully received.
- `dout[7:0]`: The parallel output of the received data.
- `parity_error`: A signal that goes high if there is a parity error in the received data.
- `frame_error`: A signal that goes high if there is a frame error, indicating an issue with the stop bit.














[Design Detail]:
`timescale 1ns / 1ps

module uart_rx #(parameter DBIT=8,SB_TICK=16) //DBIT=data bits , SB_TICK=ticks for stop bit (16 for 1 bit ,32 for 2 bits)
	(
		input clk,rst_n,
		input rx,
		input s_tick,
		output reg rx_done_tick,
		output[7:0] dout
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'b00,
							start=2'b01,
							data=2'b10,
							stop=2'b11;
	 reg[1:0] state_reg,state_nxt;
	 reg[3:0] s_reg,s_nxt; //check if number of ticks is 7(middle of start bit), or 15(middle of a data bit)
	 reg[2:0] n_reg,n_nxt; //checks how many data bits is already passed(value is 7 for last bit)
	 reg[7:0] b_reg,b_nxt; //stores 8-bit binary value of received data bits
	 //FSM register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			s_reg<=0;
			n_reg<=0;
			b_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			s_reg<=s_nxt;
			n_reg<=n_nxt;
			b_reg<=b_nxt;		
		end
	 end
	 //FSM next-state logic
	 always @* begin
		state_nxt=state_reg;
		s_nxt=s_reg;
		n_nxt=n_reg;
		b_nxt=b_reg;
		rx_done_tick=0;
		case(state_reg)
			 idle: if(rx==0) begin //wait for start bit(rx of zero)
						s_nxt=0;
						state_nxt=start;
					 end						
			start: if(s_tick==1) begin //wait for middle of start bit
						if(s_reg==7) begin
							s_nxt=0;
							n_nxt=0;
							state_nxt=data;
						end
						else s_nxt=s_reg+1;
					 end
		    data: if(s_tick==1) begin //wait to pass all middle points of every data bits
						if(s_reg==15) begin
							b_nxt={rx,b_reg[7:1]};
							s_nxt=0;
							if(n_reg==DBIT-1) state_nxt=stop;
							else n_nxt=n_reg+1;
						end
						else s_nxt=s_reg+1;
					 end
			 stop: if(s_tick==1) begin  //wait to pass the required stop bits
						if(s_reg==SB_TICK-1) begin
							rx_done_tick=1;
							state_nxt=idle;
						end
  						else s_nxt=s_reg+1;
					 end	
		 default: state_nxt=idle;
		endcase
	 end
	 assign dout=b_reg;
endmodule
",uart_rx.txt,FPGA_Book_Experiments\uart_rx.txt
"[Keyword]: uart_terminal

[Design Category]: Interface Circuits

[Design Function Description]:  
This design implements a UART terminal that receives ASCII characters via a UART interface and displays them on a VGA monitor. The design includes a VGA controller to generate the necessary signals for displaying the characters on a screen with a resolution of 640x480 pixels.

[Input Signal Description]:  
- `clk`: The main clock input for the system.
- `rst_n`: Active-low reset signal to initialize the system.
- `rx`: Serial input for receiving ASCII characters from a PC via UART.

[Output Signal Description]:  
- `vga_out_r[4:0]`: 5-bit output for the red component of the VGA signal.
- `vga_out_g[5:0]`: 6-bit output for the green component of the VGA signal.
- `vga_out_b[4:0]`: 5-bit output for the blue component of the VGA signal.
- `vga_out_vs`: Vertical sync signal for the VGA output.
- `vga_out_hs`: Horizontal sync signal for the VGA output.


[Design Detail]:
`timescale 1ns / 1ps

module uart_teminal
	(
	input clk,rst_n,
	input rx, //ascii characters will come from pc serial port via UART
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 
	 
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;
	 

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	full_screen_gen m1 //generates the characters to be displayed on screen, the ASCII characters will come from pc serial port via UART
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.rx(rx),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb)
    );
	
	 dcm_25MHz m2
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );      
	
endmodule

",uart_terminal.txt,FPGA_Book_Experiments\uart_terminal.txt
"[Keyword]: uart_tx

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a UART (Universal Asynchronous Receiver-Transmitter) transmitter module. It serially transmits data over a communication line, handling start bits, data bits, optional parity bits, and stop bits according to the UART protocol.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operation of the module.
- `rst_n`: Active-low reset signal to initialize the module.
- `s_tick`: Signal indicating when to sample the data bit.
- `tx_start`: Signal to start the transmission process.
- `din[7:0]`: 8-bit data input to be transmitted.
- `databits[3:0]`: Specifies the number of data bits (either 7 or 8) to be transmitted.
- `stopbits[5:0]`: Specifies the number of ticks for stop bits (16 for 1 stop bit, 32 for 2 stop bits).
- `paritybit[1:0]`: Specifies the parity configuration (0 for no parity, 1 for odd parity, 2 for even parity).

[Output Signal Description]:
- `tx_done_tick`: Signal indicating the completion of the transmission.
- `tx`: Serial data output line for transmitting the data.














[Design Detail]:
`timescale 1ns / 1ps

module uart_tx #(parameter DBIT=8, SB_TICK=16)
	(
		input clk,rst_n,
		input s_tick, tx_start,
		input[7:0] din,
		output reg tx_done_tick,
		output tx
    );
	 //FSM state declarations
	 localparam[1:0] idle=2'd0,
							start=2'd1,
							data=2'd2,
							stop=2'd3;
	 reg[1:0] state_reg,state_nxt;
	 reg[3:0] s_reg,s_nxt; //count to 16 for every data bit
	 reg[2:0] n_reg,n_nxt; //count the number of data bits already transmitted
	 reg[7:0] din_reg,din_nxt; //stores the word to be transmitted
	 reg tx_reg,tx_nxt;
	 //FSM register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			state_reg<=idle;
			s_reg<=0;
			n_reg<=0;
			din_reg<=0;
			tx_reg<=0;
		end
		else begin
			state_reg<=state_nxt;
			s_reg<=s_nxt;
			n_reg<=n_nxt;
			din_reg<=din_nxt;
			tx_reg<=tx_nxt;
		end
	 end
	 //FSM next-state logic
	 always @* begin
		 state_nxt=state_reg;
		 s_nxt=s_reg;
		 n_nxt=n_reg;
		 din_nxt=din_reg;
		 tx_nxt=tx_reg;
		 tx_done_tick=0;
		 case(state_reg)
				idle: begin //wait for the buffer to have at least one word stored
							tx_nxt=1;
							if(tx_start==0) begin //tx_start is  connected to the inverted empty port of fifo buffer
								din_nxt=din;
								s_nxt=0;
								state_nxt=start;
							end
						end
			  start: begin   //wait to finish the start bit
							tx_nxt=0;
							if(s_tick==1) begin
								if(s_reg==15) begin
									s_nxt=0;
									n_nxt=0;
									state_nxt=data;
								end
								else s_nxt=s_reg+1;
							end
						end
				data: begin  //wait for all data bits to be transmitted serially
							tx_nxt=din_reg[0];
							if(s_tick==1) begin
								if(s_reg==15) begin
									din_nxt=din_reg>>1;
									s_nxt=0;
									if(n_reg==DBIT-1) state_nxt=stop;
									else n_nxt=n_reg+1;
								end
								else s_nxt=s_reg+1;
							end
						end
				stop: begin  //wait to finish the stop bit
							tx_nxt=1;
							if(s_tick==1) begin
								if(s_reg==SB_TICK-1) begin
									tx_done_tick=1;
									state_nxt=idle;
								end
								else s_nxt=s_reg+1;
							end
						end
			default: state_nxt=idle;
		 endcase
	 end
	 assign tx=tx_reg;
	 
	 
 


endmodule
",uart_tx.txt,FPGA_Book_Experiments\uart_tx.txt
"[Keyword]: underlined_cursor

[Design Category]: Interface Circuits

[Design Function Description]:  
This design is a VGA controller that interfaces with a PC serial terminal to display ASCII characters on a screen. It includes cursor control functionality, allowing the cursor to move right, move down, or write a new ASCII character at the current cursor position. The design outputs VGA signals to drive a display.

[Input Signal Description]:  
- `clk`: Clock signal for synchronizing the operations.
- `rst_n`: Active-low reset signal to initialize the system.
- `rx`: Serial input for receiving ASCII characters from a PC serial terminal.
- `key[2:0]`: 3-bit input for cursor control; `key[0]` moves the cursor right, `key[1]` moves the cursor down, and `key[2]` writes a new ASCII character at the current cursor position.

[Output Signal Description]:  
- `vga_out_r[4:0]`: 5-bit VGA red color output.
- `vga_out_g[5:0]`: 6-bit VGA green color output.
- `vga_out_b[4:0]`: 5-bit VGA blue color output.
- `vga_out_vs`: Vertical sync signal for VGA.
- `vga_out_hs`: Horizontal sync signal for VGA.


[Design Detail]:
`timescale 1ns / 1ps

module underlined_cursor
	(
	input clk,rst_n,
	input rx, //ASCII characters to be displayed on screen will come from pc serial terminal
	input[2:0] key, //key[0] to move cursor to right,key[1] to move cursor down,key[2] to write new ASCII character to current cursor
	output[4:0] vga_out_r,
	output[5:0] vga_out_g,
	output[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 
	 wire[11:0] pixel_x,pixel_y;
	 wire video_on;
	 wire[2:0] rgb;
	 
	 
	 assign vga_out_r=rgb[2]? 5'b111_11:0 ;
	 assign vga_out_g=rgb[1]? 6'b111_111:0 ;
	 assign vga_out_b=rgb[0]? 5'b111_11:0 ;
	 

	 vga_core m0
	(
		.clk(clk_out),  //clock must be 25MHz for 640x480 
		.rst_n(rst_n),
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 
	full_screen_gen m1
	(
		.clk(clk_out),
		.rst_n(rst_n),
		.rx(rx),
		.key(key), //key[0] to move cursor to right,key[1] to move cursor down,key[2] to write new ASCII character to current cursor
		.pixel_x(pixel_x),
		.pixel_y(pixel_y),
		.video_on(video_on),
		.rgb(rgb)
    );
	
	 dcm_25MHz m2
		(// Clock in ports
		 .clk(clk),      // IN
		 // Clock out ports
		 .clk_out(clk_out),     // OUT
		 // Status and control signals
		 .RESET(RESET),// IN
		 .LOCKED(LOCKED)
	 );      
	
endmodule

",underlined_cursor.txt,FPGA_Book_Experiments\underlined_cursor.txt
"[Keyword]: universal_binary_counter

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a universal binary counter that can count up or down based on the control signals. It supports synchronous clear, load, enable, and direction control (up or down). The counter can be parameterized to have a different bit-width (N), allowing it to count to different maximum values.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the counter operations.
- `rst_n`: Active-low reset signal to initialize the counter to zero.
- `syn_clr`: Synchronous clear signal to reset the counter to zero during normal operation.
- `load`: Signal to load a specific value into the counter.
- `en`: Enable signal to allow counting when high.
- `up`: Direction control signal; when high, the counter counts up, and when low, it counts down.
- `d[N-1:0]`: Data input for loading a specific value into the counter.

[Output Signal Description]:
- `q[N-1:0]`: Current count value of the counter.
- `max_tick`: Output signal that goes high when the counter reaches its maximum value.
- `min_tick`: Output signal that goes high when the counter reaches zero.


[Design Detail]:
`timescale 1ns / 1ps

module universal_binary_counter
	#(parameter N=3)
	(
		input clk,rst_n,
		input syn_clr,load,en,up,
		input[N-1:0] d,
		output reg[N-1:0] q,
		output max_tick,min_tick	
    );//register plus next-state logics
	 initial q=0;
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) q<=0;
		else if(syn_clr) q<=0;
		else if(load) q<=d;
		else if(en && up) q<=q+1;
		else if(en && ~up) q<=q-1;
	 end
	assign max_tick=(q=={N{1'b1}})?1:0;
	assign min_tick=(q==0)?1:0;

endmodule
",universal_binary_counter.txt,FPGA_Book_Experiments\universal_binary_counter.txt
"[Keyword]: vga_core

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a VGA controller core that generates synchronization signals and pixel coordinates for a 640x480 VGA display. It manages the horizontal and vertical scanning process, producing the necessary timing signals (hsync and vsync) and indicating when the video signal should be active (video_on).

[Input Signal Description]:
- clk: Clock signal, must be 25MHz for proper VGA timing.
- rst_n: Active-low reset signal, used to initialize the counters and synchronization signals.

[Output Signal Description]:
- hsync: Horizontal synchronization signal, used to indicate the end of a horizontal line.
- vsync: Vertical synchronization signal, used to indicate the end of a vertical frame.
- video_on: Signal indicating when the video output should be active (i.e., when the pixel data should be displayed).
- pixel_x: 12-bit signal representing the current horizontal pixel position.
- pixel_y: 12-bit signal representing the current vertical pixel position.


















[Design Detail]:
`timescale 1ns / 1ps

module vga_core(
	input clk,rst_n, //clock must be 25MHz for 640x480 
	output hsync,vsync,
	output reg video_on,
	output[11:0] pixel_x,pixel_y
    );		//650x480 parameters
	 localparam HD=640, //Horizontal Display
					HR=16, //Right Border
					HRet=96, //Horizontal Retrace
					HL=48, //Left Border
					
					VD=480, //Vertical Display
					VB=10, //Bottom Border
					VRet=2, //Vertical Retrace
					VT=33; //Top Border
	reg[11:0] vctr_q=0,vctr_d; //counter for vertical scan
	reg[11:0] hctr_q=0,hctr_d; //counter for vertical scan
	reg hsync_q=0,hsync_d;
	reg vsync_q=0,vsync_d;
	//vctr and hctr register operation
	always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			vctr_q<=0;
			hctr_q<=0;
			vsync_q<=0;
			hsync_q<=0;
		end
		else begin
			vctr_q<=vctr_d;
			hctr_q<=hctr_d;
			vsync_q<=vsync_d;
			hsync_q<=hsync_d;
		end
	end
	
	always @* begin
		vctr_d=vctr_q;
		hctr_d=hctr_q;
		video_on=0;
		hsync_d=1; 
		vsync_d=1; 
		
		if(hctr_q==HD+HR+HRet+HL-1) hctr_d=0; //horizontal counter
		else hctr_d=hctr_q+1'b1;
		
		if(vctr_q==VD+VB+VRet+VT-1) vctr_d=0; //vertical counter
		else if(hctr_q==HD+HR+HRet+HL-1) vctr_d=vctr_q+1'b1;
		
		if(hctr_q<HD && vctr_q<VD) video_on=1; //video_on 
		
		if( (hctr_d>=HD+HR) && (hctr_d<=HD+HR+HRet-1) ) hsync_d=0; //horizontal sync 
		if( (vctr_d>=VD+VB) && (vctr_d<=VD+VB+VRet-1) ) vsync_d=0; //vertical sync
				
	end
		assign vsync=vsync_q;
		assign hsync=hsync_q;
		assign pixel_x=hctr_q;
		assign pixel_y=vctr_q;

endmodule
",vga_core.txt,FPGA_Book_Experiments\vga_core.txt
"[Keyword]: vga_core_640x480

[Design Category]: Interface Circuits

[Design Function Description]:
This design is a VGA controller for a 640x480 display resolution. It generates the necessary horizontal and vertical synchronization signals (hsync and vsync) and determines the current pixel position (pixel_x and pixel_y) on the screen. The design also provides a video_on signal to indicate when the pixel data should be displayed.

[Input Signal Description]:
- clk: The clock signal, which must be 25MHz for a 640x480 VGA display.
- rst_n: An active-low reset signal to initialize the counters and synchronization signals.

[Output Signal Description]:
- hsync: The horizontal synchronization signal for the VGA display.
- vsync: The vertical synchronization signal for the VGA display.
- video_on: A signal indicating when the pixel data should be displayed on the screen.
- pixel_x: The current horizontal pixel position on the screen.
- pixel_y: The current vertical pixel position on the screen.


[Design Detail]:
`timescale 1ns / 1ps

module vga_core_640x480(
	input clk,rst_n, //clock must be 25MHz for 640x480 
	output hsync,vsync,
	output reg video_on,
	output[11:0] pixel_x,pixel_y
    );		
	 //640x480 parameters
	 localparam HD=640, //Horizontal Display
					HR=16, //Right Border
					HRet=96, //Horizontal Retrace
					HL=48, //Left Border
					
					VD=480, //Vertical Display
					VB=10, //Bottom Border
					VRet=2, //Vertical Retrace
					VT=33; //Top Border
					
	reg[11:0] vctr_q=0,vctr_d; //counter for vertical scan
	reg[11:0] hctr_q=0,hctr_d; //counter for vertical scan
	reg hsync_q=0,hsync_d; //horizontal sync is buffered for a glitchless output
	reg vsync_q=0,vsync_d; //vertical sync is buffered for a glitchless output
	
	
	//vctr and hctr register operation
	always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			vctr_q<=0;
			hctr_q<=0;
			vsync_q<=0;
			hsync_q<=0;
		end
		else begin
			vctr_q<=vctr_d;
			hctr_q<=hctr_d;
			vsync_q<=vsync_d;
			hsync_q<=hsync_d;
		end
	end
	
	//horizontal and vertical counter logic for horizontal sync and vertical sync
	always @* begin
		vctr_d=vctr_q;
		hctr_d=hctr_q;
		video_on=0;
		hsync_d=1; 
		vsync_d=1; 
		
		if(hctr_q==HD+HR+HRet+HL-1) hctr_d=0; //horizontal counter
		else hctr_d=hctr_q+1'b1;
		
		if(vctr_q==VD+VB+VRet+VT-1) vctr_d=0; //vertical counter
		else if(hctr_q==HD+HR+HRet+HL-1) vctr_d=vctr_q+1'b1;
		
		if(hctr_q<HD && vctr_q<VD) video_on=1; //video_on 
		
		if( (hctr_d>=HD+HR) && (hctr_d<=HD+HR+HRet-1) ) hsync_d=0;  //d-input is used as condition (not the present ""q"")to remove the one-clock delay due to buffering the horizontal sync 
		if( (vctr_d>=VD+VB) && (vctr_d<=VD+VB+VRet-1) ) vsync_d=0; //d-input is used as condition (not the present ""q"")to remove the one-clock delay due to buffering the vertical sync 
				
	end
		assign vsync=vsync_q;
		assign hsync=hsync_q;
		assign pixel_x=hctr_q;
		assign pixel_y=vctr_q;

endmodule
",vga_core_640x480.txt,FPGA_Book_Experiments\vga_core_640x480.txt
"[Keyword]: vga_core_800x600

[Design Category]: Interface Circuits

[Design Function Description]:
This design is a VGA controller for generating synchronization signals and pixel coordinates for a display resolution of 800x600. It manages the horizontal and vertical synchronization signals required for VGA displays and determines when the video signal should be active.

[Input Signal Description]:
- `clk`: Clock input signal, expected to be 50MHz for proper timing.
- `rst_n`: Active-low reset signal to initialize or reset the counters and synchronization signals.

[Output Signal Description]:
- `hsync`: Horizontal synchronization signal for the VGA display.
- `vsync`: Vertical synchronization signal for the VGA display.
- `video_on`: A signal indicating when the video signal should be active (i.e., when the pixel data should be displayed).
- `pixel_x`: The current horizontal pixel position being processed.
- `pixel_y`: The current vertical pixel position being processed.


[Design Detail]:
`timescale 1ns / 1ps

module vga_core_800x600(
	input clk,rst_n, //clock must be 50MHz for 640x480 
	output hsync,vsync,
	output reg video_on,
	output[11:0] pixel_x,pixel_y
    );		
	 
	 //800x600 parameters
	 localparam HD=800, //Horizontal Display
					HR=64, //Right Border
					HRet=120, //Horizontal Retrace
					HL=56, //Left Border
					
					VD=600, //Vertical Display
					VB=23, //Bottom Border
					VRet=6, //Vertical Retrace
					VT=37; //Top Border
					
	reg[11:0] vctr_q=0,vctr_d; //counter for vertical scan
	reg[11:0] hctr_q=0,hctr_d; //counter for vertical scan
	reg hsync_q=0,hsync_d; //horizontal sync is buffered for a glitchless output
	reg vsync_q=0,vsync_d; //vertical sync is buffered for a glitchless output
	
	//vctr and hctr register operation
	always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			vctr_q<=0;
			hctr_q<=0;
			vsync_q<=0;
			hsync_q<=0;
		end
		else begin
			vctr_q<=vctr_d;
			hctr_q<=hctr_d;
			vsync_q<=vsync_d;
			hsync_q<=hsync_d;
		end
	end
	
	//horizontal and vertical counter logic for horizontal sync and vertical sync
	always @* begin
		vctr_d=vctr_q;
		hctr_d=hctr_q;
		video_on=0;
		hsync_d=1; 
		vsync_d=1; 
		
		if(hctr_q==HD+HR+HRet+HL-1) hctr_d=0; //horizontal counter
		else hctr_d=hctr_q+1'b1;
		
		if(vctr_q==VD+VB+VRet+VT-1) vctr_d=0; //vertical counter
		else if(hctr_q==HD+HR+HRet+HL-1) vctr_d=vctr_q+1'b1;
		
		if(hctr_q<HD && vctr_q<VD) video_on=1; //video_on 
		
		if( (hctr_d>=HD+HR) && (hctr_d<=HD+HR+HRet-1) ) hsync_d=0; //d-input is used as condition (not the present ""q"")to remove the one-clock delay due to buffering the horizontal sync 
		if( (vctr_d>=VD+VB) && (vctr_d<=VD+VB+VRet-1) ) vsync_d=0; //d-input is used as condition (not the present ""q"")to remove the one-clock delay due to buffering the vertical sync
				
	end
		assign vsync=vsync_q;
		assign hsync=hsync_q;
		assign pixel_x=hctr_q;
		assign pixel_y=vctr_q;

endmodule
",vga_core_800x600.txt,FPGA_Book_Experiments\vga_core_800x600.txt
"[Keyword]: vga_mouse

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a VGA mouse interface circuit. It integrates a PS/2 mouse input with a VGA display output, allowing the mouse to control a pointer on a VGA screen. The circuit updates the mouse pointer's position and color based on mouse movements and button clicks, and it displays the pointer on a VGA screen with a resolution of 640x480 pixels.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the circuit operations.
- `rst_n`: Active-low reset signal to initialize the circuit.
- `ps2c`: PS/2 clock line for mouse communication.
- `ps2d`: PS/2 data line for mouse communication.

[Output Signal Description]:
- `vga_out_r[4:0]`: 5-bit VGA red color output.
- `vga_out_g[5:0]`: 6-bit VGA green color output.
- `vga_out_b[4:0]`: 5-bit VGA blue color output.
- `vga_out_vs`: VGA vertical sync signal.
- `vga_out_hs`: VGA horizontal sync signal.



[Design Detail]:
`timescale 1ns / 1ps

module vga_mouse(
	input clk,rst_n,
	inout ps2c,ps2d,
	output reg[4:0] vga_out_r,
	output reg[5:0] vga_out_g,
	output reg[4:0] vga_out_b,
	output vga_out_vs,vga_out_hs
    );
	 localparam SIZE=16; //mouse pointer width and height
	 
	 wire[8:0] x,y;
	 wire[2:0] btn;
	 wire m_done_tick;
	 wire video_on;
	 wire mouse_on;
	 wire[11:0] pixel_x,pixel_y;
	 reg[9:0] mouse_x_q=0,mouse_x_d; //stores x-value(left part) of mouse, 
	 reg[9:0] mouse_y_q=0,mouse_y_d; //stores y-value(upper part) of mouse, 
	 reg[2:0] mouse_color_q=0,mouse_color_d; //stores current mouse color and can be changed by right/left click 
	 
	 //register operation
	 always @(posedge clk,negedge rst_n) begin
		if(!rst_n) begin
			mouse_x_q<=0;
			mouse_y_q<=0;
			mouse_color_q<=0;
		end
		else begin
			mouse_x_q<=mouse_x_d;
			mouse_y_q<=mouse_y_d;
			mouse_color_q<=mouse_color_d;
		end
	 end
	 
	 //logic for updating mouse location(by dragging the mouse) and mouse pointer color(by left/right click)
	 always @* begin
		mouse_x_d=mouse_x_q;
		mouse_y_d=mouse_y_q;
		mouse_color_d=mouse_color_q;
		if(m_done_tick) begin
			mouse_x_d=x[8]? mouse_x_q - 1 -{~{x[7:0]}} : mouse_x_q+x[7:0] ; //new x value of pointer
			mouse_y_d=y[8]? mouse_y_q + 1 +{~{y[7:0]}} : mouse_y_q-y[7:0] ; //new y value of pointer
			
			mouse_x_d=(mouse_x_d>640)? (x[8]? 640:0): mouse_x_d; //wraps around when reaches border
			mouse_y_d=(mouse_y_d>480)? (y[8]? 0:480): mouse_y_d; //wraps around when reaches border
			
			
			if(btn[1]) mouse_color_d=mouse_color_q+1;//right click to change color(increment)
			else if(btn[0]) mouse_color_d=mouse_color_q-1;//left click to change color(decrement)
		end
	 end
	 
	 assign mouse_on = (mouse_x_q<=pixel_x) && (pixel_x<=mouse_x_q+SIZE) && (mouse_y_q<=pixel_y) && (pixel_y<=mouse_y_q+SIZE);
	 
	 //display logic
	 always @* begin
				vga_out_r=0;
				vga_out_g=0;
				vga_out_b=0;
		if(video_on) begin
			if(mouse_on) begin //mouse color
				vga_out_r={5{mouse_color_q[0]}};
				vga_out_g={6{mouse_color_q[1]}};
				vga_out_b={5{mouse_color_q[2]}};
			end
			else begin //background color
				vga_out_g=6'b111_111;
				vga_out_b=5'b111_11;
			end
		end
	 end
	 

	 
	 //module instantiations
	 
	 dcm_25MHz m0
   (// Clock in ports
    .clk(clk),      // IN
    // Clock out ports
    .clk_out(clk_out),     // OUT
    // Status and control signals
    .RESET(RESET),// IN
    .LOCKED(LOCKED));      // OUT
	 
	 
	 mouse m1
	(
		.clk(clk),
		.rst_n(rst_n),
		.ps2c(ps2c),
		.ps2d(ps2d),
		.x(x),
		.y(y),
		.btn(btn),
		.m_done_tick(m_done_tick)
    );
	 
	vga_core m2 //clock must be 25MHz for 640x480 
	(
		.clk(clk_out),
		.rst_n(rst_n), 
		.hsync(vga_out_hs),
		.vsync(vga_out_vs),
		.video_on(video_on),
		.pixel_x(pixel_x),
		.pixel_y(pixel_y)
    );	
	 


endmodule
",vga_mouse.txt,FPGA_Book_Experiments\vga_mouse.txt
"[Keyword]: 2012 q1g

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit implements a specific logic function using a combination of AND, OR, and NOT gates. It evaluates the input signals and produces an output based on the specified logical expression.

[Input Signal Description]:
x[4:1]: A 4-bit input vector where each bit (x[1], x[2], x[3], x[4]) is used in the logical expression to determine the output.

[Output Signal Description]:
f: A single-bit output that is the result of the logical expression applied to the input signals.

[Design Detail]: 
module topmodule (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",2012 q1g.txt,Verilog_Practice\2012 q1g.txt
"[Keyword]: 2012 q2b

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a combinational logic circuit that processes a 6-bit input vector and a single-bit control signal to produce two specific outputs based on logical operations.

[Input Signal Description]:
y[5:0]: A 6-bit input vector that provides the data for logical operations.
w: A single-bit control signal that influences the logic applied to the input vector.

[Output Signal Description]:
Y1: The output is the result of a logical AND operation between the least significant bit of the input vector (y[0]) and the control signal (w).
Y3: The output is the result of a logical OR operation applied to several AND operations between specific bits of the input vector (y[1], y[2], y[4], y[5]) and the negation of the control signal (~w).

[Design Detail]: 
module topmodule (
    input [5:0] y,
    input w,
    output Y1,
    output Y3
);

    assign Y1 = y[0]&w;
    assign Y3 = y[1]&(~w) | y[2]&(~w) | y[4]&(~w) | y[5]&(~w);
    
endmodule",2012 q2b.txt,Verilog_Practice\2012 q2b.txt
"[Keyword]: 2012 q2fsm

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with six states (a, b, c, d, e, f). The FSM transitions between these states based on the input signal `w`. The output `z` is asserted when the FSM is in either state `e` or state `f`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `reset`: Synchronous reset signal that initializes the FSM to state `a` when asserted.
- `w`: Input signal that influences state transitions within the FSM.

[Output Signal Description]:
- `z`: Output signal that is asserted (logic high) when the FSM is in state `e` or state `f`.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,     // synchronous reset
    input w,
    output z);

    parameter a=3'b000, b=3'b001, c=3'b010, d=3'b011, e=3'b100, f=3'b101;
    reg [2:0] state, nextstate;
    
    always@(*) begin
        case({state, w})
            {a, 1'b0}:  nextstate = a;
            {a, 1'b1}:  nextstate = b;
            {b, 1'b0}:  nextstate = d;
            {b, 1'b1}:  nextstate = c;
            {c, 1'b0}:  nextstate = d;
            {c, 1'b1}:  nextstate = e;
            {d, 1'b0}:  nextstate = a;
            {d, 1'b1}:  nextstate = f;
            {e, 1'b0}:  nextstate = d;
            {e, 1'b1}:  nextstate = e;
            {f, 1'b0}:  nextstate = d;
            {f, 1'b1}:  nextstate = c;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= nextstate;
    end
    
    assign z = (state == e || state == f);
    
endmodule
```",2012 q2fsm.txt,Verilog_Practice\2012 q2fsm.txt
"[Keyword]: 2013 q2afsm

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a simple priority arbiter using a finite state machine (FSM). The arbiter grants access to one of the three requesters based on priority. The requests are prioritized in the order of r[1], r[2], and r[3]. The FSM transitions between states based on the active request signals and grants access accordingly.

[Input Signal Description]:
- clk: Clock signal for synchronizing the state transitions.
- resetn: Active-low synchronous reset signal, which initializes the state machine to the default state when asserted low.
- r[3:1]: Request signals from three different sources. Each bit represents a request from a different source, with r[1] having the highest priority.

[Output Signal Description]:
- g[3:1]: Grant signals corresponding to each request. When a particular grant signal is high, it indicates that the corresponding request has been granted access. g[1] corresponds to r[1], g[2] to r[2], and g[3] to r[3].

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input resetn,    // active-low synchronous reset
    input [3:1] r,   // request
    output [3:1] g   // grant
); 

    parameter a=2'd0, b=2'd1, c=2'd2, d=2'd3;
    reg [1:0] state, nextstate;
    
    always@(*) begin
        case(state)
            a: begin
                if(r[1])    nextstate = b;
                else if(~r[1] & r[2])   nextstate = c;
                else if(~r[1] & ~r[2] & r[3])   nextstate = d;
                else    nextstate = a;
            end
            b: begin
                if(r[1])    nextstate = b;
                else        nextstate = a;
            end
            c: begin
                if(r[2])    nextstate = c;
                else        nextstate = a;
            end
            d: begin
                if(r[3])    nextstate = d;
                else        nextstate = a;
            end
        endcase
    end

    always@(posedge clk) begin
        if(~resetn)
            state <= a;
        else
            state <= nextstate;
    end
    
    assign g[1] = (state == b);
    assign g[2] = (state == c);
    assign g[3] = (state == d);
    
endmodule
```",2013 q2afsm.txt,Verilog_Practice\2013 q2afsm.txt
"[Keyword]: 2013 q2bfsm

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a finite state machine (FSM) that transitions through a series of states based on the input signals `x` and `y`, as well as a synchronous active-low reset signal `resetn`. The FSM controls two output signals, `f` and `g`, which are set based on the current state of the machine.

[Input Signal Description]:
- `clk`: Clock signal that synchronizes the state transitions.
- `resetn`: Active-low synchronous reset signal that initializes the FSM to the starting state `A`.
- `x`: Input signal that influences state transitions between `tmp0`, `tmp1`, and `tmp2`.
- `y`: Input signal that influences state transitions between `g1`, `g1p`, `tmp3`, and `g0p`.

[Output Signal Description]:
- `f`: Output signal that is set to 1 when the FSM is in state `f1`.
- `g`: Output signal that is set to 1 when the FSM is in states `g1`, `tmp3`, or `g1p`, and set to 0 in state `g0p`.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, nextstate;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    nextstate = f1;
                else
                    nextstate = A;
            end
            f1:     nextstate = tmp0;
            tmp0: begin
                if(x)
                    nextstate = tmp1;
                else
                    nextstate = tmp0;
            end
            tmp1: begin
                if(~x)
                    nextstate = tmp2;
                else
                    nextstate = tmp1;
            end
            tmp2: begin
                if(x)
                    nextstate = g1;
                else
                    nextstate = tmp0;
            end
            g1: begin
                if(y)
                    nextstate = g1p;
                else
                    nextstate = tmp3;
            end
            tmp3: begin
                if(y)
                    nextstate = g1p;
                else
                    nextstate = g0p;
            end
            g1p: begin
                if(~resetn)
                    nextstate = A;
                else
                    nextstate = g1p;
            end
            g0p: begin
                if(~resetn)
                    nextstate = A;
                else
                    nextstate = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= nextstate;
    end
    
    always@(posedge clk) begin
        case(nextstate)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
```",2013 q2bfsm.txt,Verilog_Practice\2013 q2bfsm.txt
"[Keyword]: 2014 q3bfsm

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with five states (a, b, c, d, e). The FSM transitions between these states based on the input signal `x`. The output `z` is asserted when the FSM is in either state `d` or state `e`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `reset`: Synchronous reset signal that initializes the FSM to state `a` when asserted.
- `x`: Input signal that influences state transitions within the FSM.

[Output Signal Description]:
- `z`: Output signal that is asserted (logic high) when the FSM is in state `d` or state `e`.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, nextstate;

    always @(*) begin
        case (state)
            a: nextstate = x ? b : a;
            b: nextstate = x ? e : b;
            c: nextstate = x ? b : c;
            d: nextstate = x ? c : b;
            e: nextstate = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= nextstate;
        end
    end

    assign z = (state == d || state == e);

endmodule
```",2014 q3bfsm.txt,Verilog_Practice\2014 q3bfsm.txt
"[Keyword]: 2014 q3c

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a state machine that transitions between different states based on the current state and an input signal. The output `z` is determined by specific states, and `Y0` represents the least significant bit of the next state.

[Input Signal Description]:
- `clk`: Clock signal, though not used in this combinational logic block, it might be intended for synchronization in a larger design.
- `y[2:0]`: 3-bit current state input signal.
- `x`: Single-bit input signal that influences state transitions.

[Output Signal Description]:
- `Y0`: Outputs the least significant bit of the next state `Y`.
- `z`: Outputs a high signal when the current state `y` is either `3'b011` or `3'b100`.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule
```",2014 q3c.txt,Verilog_Practice\2014 q3c.txt
"[Keyword]: 2014 q3fsm

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with two states, A and B. The FSM transitions between these states based on the input signal `s`. The circuit also processes an input signal `w` to form a 3-bit sequence `wnew` and uses a counter to determine when to evaluate the sequence. The output `z` is asserted when the counter reaches a specific value and the sequence `wnew` matches one of the specified patterns.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing state transitions and operations.
- `reset`: Synchronous reset signal to initialize the state and other registers.
- `s`: Input signal that determines state transitions in the FSM.
- `w`: Input signal that is used to form a 3-bit sequence `wnew`.

[Output Signal Description]:
- `z`: Output signal that is asserted when the counter reaches 1 and the sequence `wnew` matches one of the patterns: 3'b011, 3'b110, or 3'b101.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, nextstate;
    reg [2:0] wnew;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            {A, 1'b0}: nextstate = A;
            {A, 1'b1}: nextstate = B;
            {B, 1'b0}: nextstate = B;
            {B, 1'b1}: nextstate = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= nextstate;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            wnew <= 0;
        end
        else if (nextstate == B) begin
            wnew <= {wnew[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (nextstate == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (wnew == 3'b011 || wnew == 3'b110 || wnew == 3'b101));

endmodule
```",2014 q3fsm.txt,Verilog_Practice\2014 q3fsm.txt
"[Keyword]: 2014 q4a

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a sequential logic circuit that implements a flip-flop with additional control signals for enabling, loading, and resetting. The output Q is updated based on the clock signal and the control inputs.

[Input Signal Description]:
- clk: Clock signal that triggers the update of the output Q.
- w: Data input used when the enable signal E is active.
- R: Data input used when the load signal L is active.
- E: Enable signal that determines whether the input w should be used to update the output.
- L: Load signal that determines whether the input R should be used to update the output.

[Output Signal Description]:
- Q: The output of the flip-flop, which is updated based on the control signals and the clock.

[Design Detail]: 
module topmodule (
    input clk,
    input w, R, E, L,
    output Q
);
    
    reg tmp;
    //not use <=
    always @(posedge clk) begin
        tmp = E ? w : Q;
        Q = L ? R : tmp;
    end

endmodule",2014 q4a.txt,Verilog_Practice\2014 q4a.txt
"[Keyword]: 7420

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements two 4-input NAND gates. Each NAND gate takes four input signals and produces an output that is the logical NAND of the inputs.

[Input Signal Description]:
- p1a, p1b, p1c, p1d: These are the four input signals for the first NAND gate.
- p2a, p2b, p2c, p2d: These are the four input signals for the second NAND gate.

[Output Signal Description]:
- p1y: This is the output of the first NAND gate, which is the negation of the logical AND of inputs p1a, p1b, p1c, and p1d.
- p2y: This is the output of the second NAND gate, which is the negation of the logical AND of inputs p2a, p2b, p2c, and p2d.

[Design Detail]: 
module topmodule ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",7420.txt,Verilog_Practice\7420.txt
"[Keyword]: 7458

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements two separate logic functions. The first function is a 3-input AND gate followed by an OR gate, which combines two sets of three inputs each. The second function is a 2-input AND gate followed by an OR gate, which combines two sets of two inputs each.

[Input Signal Description]:
- p1a, p1b, p1c, p1d, p1e, p1f: These are the input signals for the first logic function. They are grouped into two sets of three inputs each (p1a, p1b, p1c) and (p1d, p1e, p1f).
- p2a, p2b, p2c, p2d: These are the input signals for the second logic function. They are grouped into two sets of two inputs each (p2a, p2b) and (p2c, p2d).

[Output Signal Description]:
- p1y: This is the output signal for the first logic function. It is the result of OR-ing the outputs of two 3-input AND gates.
- p2y: This is the output signal for the second logic function. It is the result of OR-ing the outputs of two 2-input AND gates.

[Design Detail]: 
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule
```",7458.txt,Verilog_Practice\7458.txt
"[Keyword]: 7Vector1

[Design Category]: Combinational Logic

[Design Function Description]:
This design is a simple signal splitter that takes a 16-bit input and divides it into two separate 8-bit outputs. The higher 8 bits of the input are assigned to one output, and the lower 8 bits are assigned to another output.

[Input Signal Description]:
in[15:0]: A 16-bit input signal that is to be split into two 8-bit segments.

[Output Signal Description]:
out_hi[7:0]: An 8-bit output signal representing the higher 8 bits of the input.
out_lo[7:0]: An 8-bit output signal representing the lower 8 bits of the input.

[Design Detail]: 
`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",7Vector1.txt,Verilog_Practice\7Vector1.txt
"[Keyword]: Adder100

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 100-bit ripple carry adder. It takes two 100-bit binary numbers and an input carry, and produces a 100-bit sum and an output carry. The adder performs bitwise addition of the two input numbers, taking into account the carry from the previous bit addition.

[Input Signal Description]:
- a[99:0]: A 100-bit input signal representing the first operand for the addition.
- b[99:0]: A 100-bit input signal representing the second operand for the addition.
- cin: A single-bit input signal representing the initial carry-in for the least significant bit addition.

[Output Signal Description]:
- sum[99:0]: A 100-bit output signal representing the result of the addition of inputs a and b, including the carry propagation.
- cout: A single-bit output signal representing the final carry-out from the most significant bit addition.

[Design Detail]: 
module topmodule( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] couttmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign couttmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ couttmp[i-1];
            couttmp[i] = a[i] & b[i] | a[i] & couttmp[i-1] | b[i] & couttmp[i-1];
        end
        cout = couttmp[99];
    end

endmodule",Adder100.txt,Verilog_Practice\Adder100.txt
"[Keyword]: Adder100i

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 100-bit binary adder. It takes two 100-bit binary numbers and an initial carry-in as inputs and produces a 100-bit sum and a 100-bit carry-out as outputs. The adder performs bitwise addition, taking into account the carry from the previous bit.

[Input Signal Description]:
- a[99:0]: A 100-bit input representing the first binary number to be added.
- b[99:0]: A 100-bit input representing the second binary number to be added.
- cin: A single-bit input representing the initial carry-in for the least significant bit addition.

[Output Signal Description]:
- sum[99:0]: A 100-bit output representing the sum of the input binary numbers a and b, including the carry-in.
- cout[99:0]: A 100-bit output representing the carry-out from each bit addition, which is used as the carry-in for the next higher bit.

[Design Detail]: 
```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // Initial addition, use cin as carry-in
                if(!cin) begin // No carry-in
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // With carry-in
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // Subsequent additions, use cout[i - 1] as carry-in
                if(!cout[i - 1]) begin // No carry-in
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // With carry-in
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end
endmodule
```",Adder100i.txt,Verilog_Practice\Adder100i.txt
"[Keyword]: Adder3

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 3-bit ripple carry adder. It takes two 3-bit binary numbers and a carry-in bit as inputs and produces a 3-bit sum and a 3-bit carry-out as outputs. The adder performs bitwise addition, propagating carry bits from the least significant bit to the most significant bit.

[Input Signal Description]:
- a[2:0]: A 3-bit input representing the first operand for the addition.
- b[2:0]: A 3-bit input representing the second operand for the addition.
- cin: A single-bit input representing the initial carry-in for the least significant bit addition.

[Output Signal Description]:
- sum[2:0]: A 3-bit output representing the sum of the input operands and the carry-in.
- cout[2:0]: A 3-bit output representing the carry-out bits for each bit position of the addition.

[Design Detail]: 
```verilog
module topmodule( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule
```",Adder3.txt,Verilog_Practice\Adder3.txt
"[Keyword]: Always casezv

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a priority encoder. It takes an 8-bit input and outputs the position of the first high bit ('1') encountered from the least significant bit (LSB) to the most significant bit (MSB). If no bits are high, it defaults to outputting position 0.

[Input Signal Description]:
in[7:0]: An 8-bit input signal where each bit can be either 0 or 1. The circuit checks these bits to determine the position of the first '1' from the right.

[Output Signal Description]:
pos[2:0]: A 3-bit output signal representing the position of the first '1' found in the input signal. If no '1' is found, it defaults to 0.

[Design Detail]: 
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule
```",Always casezv.txt,Verilog_Practice\Always casezv.txt
"[Keyword]: Always if

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple 2-to-1 multiplexer using both continuous assignment and procedural assignment. The multiplexer selects between two input signals, `a` and `b`, based on the combination of two select signals, `sel_b1` and `sel_b2`.

[Input Signal Description]:
- `a`: A single-bit input signal.
- `b`: A single-bit input signal.
- `sel_b1`: A single-bit select signal.
- `sel_b2`: A single-bit select signal. The combination of `sel_b1` and `sel_b2` determines which input (`a` or `b`) is selected.

[Output Signal Description]:
- `out_assign`: A single-bit output signal determined by a continuous assignment. It outputs `b` if both `sel_b1` and `sel_b2` are high; otherwise, it outputs `a`.
- `out_always`: A single-bit output signal determined by a procedural assignment within an always block. It functions identically to `out_assign`, outputting `b` if both `sel_b1` and `sel_b2` are high; otherwise, it outputs `a`.

[Design Detail]: 
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule
```",Always if.txt,Verilog_Practice\Always if.txt
"[Keyword]: Always if2

[Design Category]: Control Circuits

[Design Function Description]:
This design is a control circuit that manages two outputs based on specific conditions. It determines whether to shut off a computer based on CPU temperature and whether to keep driving based on arrival status and gas tank level.

[Input Signal Description]:
- `cpu_overheated`: A signal indicating whether the CPU is overheated. If true, the computer should be shut off.
- `arrived`: A signal indicating whether the destination has been reached. If false, the system checks the gas tank status to decide on driving.
- `gas_tank_empty`: A signal indicating whether the gas tank is empty. If true and the destination is not reached, driving should stop.

[Output Signal Description]:
- `shut_off_computer`: A control signal that is set to 1 if the CPU is overheated, indicating the computer should be shut off.
- `keep_driving`: A control signal that is set to 1 if the destination has not been reached and the gas tank is not empty, indicating to keep driving.

[Design Detail]: 
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input      cpu_overheated,
    output reg shut_off_computer,
    input      arrived,
    input      gas_tank_empty,
    output reg keep_driving  ); //

    always @(*) begin
        if (cpu_overheated)
           shut_off_computer = 1;
        else
            shut_off_computer = 0;
    end

    always @(*) begin
        if (~arrived)
            keep_driving = ~gas_tank_empty;
        else
            keep_driving = 0;
    end

endmodule
```",Always if2.txt,Verilog_Practice\Always if2.txt
"[Keyword]: Alwaysblock1

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple 2-input AND gate using both continuous assignment and procedural assignment within an always block. The circuit outputs the logical AND of two input signals.

[Input Signal Description]:
a: A single-bit input signal.
b: A single-bit input signal.

[Output Signal Description]:
out_assign: A wire output that continuously outputs the result of the logical AND operation between inputs a and b.
out_alwaysblock: A register output that outputs the result of the logical AND operation between inputs a and b, updated whenever there is a change in inputs a or b.

[Design Detail]: 
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule
```",Alwaysblock1.txt,Verilog_Practice\Alwaysblock1.txt
"[Keyword]: Alwaysblock2

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple XOR operation between two input signals, `a` and `b`, and provides the result through three different output mechanisms: a continuous assignment, a combinational always block, and a sequential always block triggered by a clock edge.

[Input Signal Description]:
- `clk`: Clock signal used to trigger the sequential logic.
- `a`: First input signal for the XOR operation.
- `b`: Second input signal for the XOR operation.

[Output Signal Description]:
- `out_assign`: Output of the XOR operation using a continuous assignment.
- `out_always_comb`: Output of the XOR operation using a combinational always block.
- `out_always_ff`: Output of the XOR operation using a sequential always block, updated on the rising edge of the clock.

[Design Detail]: 
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule
```",Alwaysblock2.txt,Verilog_Practice\Alwaysblock2.txt
"[Keyword]: Alwayscase

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 4-bit wide, 6-to-1 multiplexer. It selects one of the six 4-bit input data lines based on a 3-bit selection signal and outputs the selected data.

[Input Signal Description]:
- sel[2:0]: A 3-bit selection signal that determines which of the six input data lines is routed to the output. It can represent values from 0 to 5.
- data0[3:0] to data5[3:0]: Six 4-bit input data lines from which one is selected based on the value of the selection signal.

[Output Signal Description]:
- out[3:0]: A 4-bit output that carries the value of the selected input data line based on the selection signal.

[Design Detail]: 
```verilog
// synthesis veriloginputversion verilog2001
module topmodule ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule
```",Alwayscase.txt,Verilog_Practice\Alwayscase.txt
"[Keyword]: Alwayscase2v

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a priority encoder that takes a 4-bit input and outputs a 2-bit position of the highest priority '1' bit. If no bits are set, it outputs 0.

[Input Signal Description]:
in[3:0]: A 4-bit input signal representing a binary number where each bit can be either 0 or 1.

[Output Signal Description]:
pos[1:0]: A 2-bit output signal that indicates the position of the highest priority '1' bit in the input. If no bits are set, it outputs 0.

[Design Detail]: 
```verilog
// synthesis veriloginputversion verilog2001
module topmodule (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule
```",Alwayscase2v.txt,Verilog_Practice\Alwayscase2v.txt
"[Keyword]: Alwaysnolatches

[Design Category]: Control Circuits

[Design Function Description]:
This design decodes a 16-bit scancode input to determine the direction of a key press. It sets one of the four directional outputs (left, down, right, up) based on the specific scancode received.

[Input Signal Description]:
scancode[15:0]: A 16-bit input signal representing the scancode of a key press. Specific scancodes correspond to directional keys.

[Output Signal Description]:
left: A signal that is set to 1 when the scancode corresponds to the left direction key.
down: A signal that is set to 1 when the scancode corresponds to the down direction key.
right: A signal that is set to 1 when the scancode corresponds to the right direction key.
up: A signal that is set to 1 when the scancode corresponds to the up direction key.

[Design Detail]: 
```verilog
// synthesis veriloginputversion verilog2001
module topmodule (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule
```",Alwaysnolatches.txt,Verilog_Practice\Alwaysnolatches.txt
"[Keyword]: Andgate

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple 2-input AND gate. The output is the logical AND of the two input signals.

[Input Signal Description]:
a: A single-bit input signal.
b: A single-bit input signal.

[Output Signal Description]:
out: A single-bit output signal that is the result of the logical AND operation between inputs a and b.

[Design Detail]: 
module top_module( 
    input a, 
    input b, 
    output out 
);
    assign out = a & b;
endmodule",Andgate.txt,Verilog_Practice\Andgate.txt
"[Keyword]: Anothergateq4f

[Design Category]: Combinational Logic

[Design Function Description]: 
This circuit implements a simple combinational logic function that performs a logical AND operation between the first input and the negation of the second input. It effectively outputs true only when the first input is true and the second input is false.

[Input Signal Description]: 
in1: A single-bit input signal that serves as one operand for the AND operation.
in2: A single-bit input signal that is negated and then used as the second operand for the AND operation.

[Output Signal Description]: 
out: A single-bit output signal that represents the result of the AND operation between in1 and the negation of in2.

[Design Detail]: 
module topmodule (
    input in1,
    input in2,
    output out
);
    assign out = in1 & (~in2);
endmodule",Anothergateq4f.txt,Verilog_Practice\Anothergateq4f.txt
"[Keyword]: Bcdadd100

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 400-digit Binary-Coded Decimal (BCD) adder. It takes two 400-digit BCD numbers and a carry-in as inputs and produces a 400-digit BCD sum and a carry-out. Each BCD digit is represented by 4 bits, and the addition is performed digit by digit using a BCD full adder module.

[Input Signal Description]:
- a[399:0]: A 400-digit BCD number, where each digit is represented by 4 bits.
- b[399:0]: Another 400-digit BCD number, where each digit is represented by 4 bits.
- cin: A single-bit carry-in input for the least significant digit addition.

[Output Signal Description]:
- cout: A single-bit carry-out from the most significant digit addition.
- sum[399:0]: The 400-digit BCD sum of the inputs a and b, with each digit represented by 4 bits.

[Design Detail]: 
```verilog
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule
```",Bcdadd100.txt,Verilog_Practice\Bcdadd100.txt
"[Keyword]: Bcdadd4

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a 16-bit Binary Coded Decimal (BCD) adder. It takes two 16-bit BCD numbers and a carry-in as inputs and produces a 16-bit BCD sum and a carry-out. The addition is performed in 4-bit BCD segments.

[Input Signal Description]:
- a[15:0]: A 16-bit input representing the first BCD number.
- b[15:0]: A 16-bit input representing the second BCD number.
- cin: A single-bit input representing the initial carry-in for the least significant BCD digit.

[Output Signal Description]:
- cout: A single-bit output representing the carry-out from the most significant BCD digit.
- sum[15:0]: A 16-bit output representing the BCD sum of the inputs a and b.

[Design Detail]: 
```verilog
module topmodule( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] couttmp;
    bcdfadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(couttmp[0]), .sum(sum[3:0]));
    assign cout = couttmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcdfadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(couttmp[i-4]), .cout(couttmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule

// Below solution is designed by @Lysias-1998

// module topmodule( 
//     input [15:0] a, b,
//     input cin,
//     output cout,
//     output [15:0] sum );
    
//     wire [4:0] c;
    
//     assign c[0] = cin;
//     assign cout = c[4];
//     generate
//         genvar i;
//         for (i = 0; i < 4; i = i + 1) begin : adders
//             bcdfadd thebcdfadders ( 
//                 .a(a[i*4+3 : i*4]), 
//                 .b(b[i*4+3 : i*4]), 
//                 .cin(c[i]), 
//                 .cout(c[i+1]), 
//                 .sum(sum[i*4+3 : i*4]) 
//             );
//         end
//     endgenerate

// endmodule
```",Bcdadd4.txt,Verilog_Practice\Bcdadd4.txt
"[Keyword]: Bugs addsubz

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements an 8-bit arithmetic unit that can perform either addition or subtraction based on the control signal `dosub`. It also checks if the result of the operation is zero and sets a flag accordingly.

[Input Signal Description]:
- `dosub`: A control signal (1-bit) that determines the operation. If `dosub` is 0, the circuit performs addition; if 1, it performs subtraction.
- `a[7:0]`: An 8-bit input operand for the arithmetic operation.
- `b[7:0]`: Another 8-bit input operand for the arithmetic operation.

[Output Signal Description]:
- `out[7:0]`: An 8-bit output that holds the result of the arithmetic operation (either `a + b` or `a - b`).
- `resultiszero`: A 1-bit output flag that is set to 1 if the result of the operation (`out`) is zero, otherwise it is set to 0.

[Design Detail]: 
```verilog
// synthesis veriloginputversion verilog2001
module topmodule ( 
    input dosub,
    input [7:0] a,
    input [7:0] b,
    output reg [7:0] out,
    output reg resultiszero
);//

    always @(*) begin
        case (dosub)
          0: out = a+b;
          1: out = a-b;
        endcase

        if (out == 0)
            resultiszero = 1;
        else
            resultiszero = 0;
    end

endmodule
```",Bugs addsubz.txt,Verilog_Practice\Bugs addsubz.txt
"[Keyword]: Bugs case

[Design Category]: Combinational Logic

[Design Function Description]:
This design is a decoder that converts an 8-bit input code into a 4-bit output. It checks if the input code matches one of the predefined hexadecimal values and outputs a corresponding 4-bit number. If the input code matches, the valid signal is set to 1; otherwise, it is set to 0.

[Input Signal Description]:
code[7:0]: An 8-bit input signal representing a code that needs to be decoded into a 4-bit output.

[Output Signal Description]:
out[3:0]: A 4-bit output signal that represents the decoded value of the input code.
valid: A signal that indicates whether the input code is valid (1) or not (0).

[Design Detail]: 
module topmodule (
    input [7:0] code,
    output reg [3:0] out,
    output reg valid = 1 
);

    always @(*)
        case (code)
            8'h45: begin
                out = 0;
                valid = 1;
            end
            8'h16: begin
                out = 1;
                valid = 1;
            end
            8'h1e: begin
                out = 2;
                valid = 1;
            end
            8'h26: begin
                out = 3;
                valid = 1;
            end
            8'h25: begin
                out = 4;
                valid = 1;
            end
            8'h2e: begin
                out = 5;
                valid = 1;
            end
            8'h36: begin
                out = 6;
                valid = 1;
            end
            8'h3d: begin
                out = 7;
                valid = 1;
            end
            8'h3e: begin
                out = 8;
                valid = 1;
            end
            8'h46: begin
                out = 9;
                valid = 1;
            end
            default: begin
                out = 0;
                valid = 0;
            end
        endcase

endmodule",Bugs case.txt,Verilog_Practice\Bugs case.txt
"[Keyword]: Bugs mux2

[Design Category]: Combinational Logic

[Design Function Description]: 
This design implements an 8-bit 2-to-1 multiplexer. It selects between two 8-bit input signals, 'a' and 'b', based on the value of the single-bit input 'sel'. If 'sel' is 1, the output 'out' will be the value of 'a'; if 'sel' is 0, the output 'out' will be the value of 'b'.

[Input Signal Description]:
- sel: A 1-bit selection signal that determines which input (either 'a' or 'b') is passed to the output.
- a[7:0]: An 8-bit input signal that is selected when 'sel' is 1.
- b[7:0]: An 8-bit input signal that is selected when 'sel' is 0.

[Output Signal Description]:
- out[7:0]: An 8-bit output signal that reflects the value of either input 'a' or 'b', depending on the value of 'sel'.

[Design Detail]: 
module topmodule (
    input sel,
    input [7:0] a,
    input [7:0] b,
    output [7:0] out
);
    assign out = sel ? a : b;
endmodule",Bugs mux2.txt,Verilog_Practice\Bugs mux2.txt
"[Keyword]: Bugs mux4

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 4-to-1 multiplexer using a hierarchical structure of 2-to-1 multiplexers. It selects one of the four 8-bit input signals (a, b, c, d) based on a 2-bit selection signal (sel) and outputs the selected 8-bit signal.

[Input Signal Description]:
- sel[1:0]: A 2-bit selection signal used to choose which of the four input signals (a, b, c, d) is routed to the output. 
- a[7:0]: An 8-bit input signal.
- b[7:0]: An 8-bit input signal.
- c[7:0]: An 8-bit input signal.
- d[7:0]: An 8-bit input signal.

[Output Signal Description]:
- out[7:0]: The 8-bit output signal that corresponds to one of the input signals (a, b, c, or d) based on the value of the selection signal (sel).

[Design Detail]: 
module topmodule (
    input [1:0] sel,
    input [7:0] a,
    input [7:0] b,
    input [7:0] c,
    input [7:0] d,
    output [7:0] out  ); //

    wire [7:0]  mux0, mux1;
    mux2 mux0ins ( sel[0],    a,    b, mux0 );
    mux2 mux1ins ( sel[0],    c,    d, mux1 );
    mux2 mux2ins ( sel[1], mux0, mux1,  out );

endmodule",Bugs mux4.txt,Verilog_Practice\Bugs mux4.txt
"[Keyword]: Bugs nand3

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a logic circuit that performs a logical AND operation on three input signals and two constant high signals, followed by a NOT operation on the result. The circuit effectively computes the logical NAND of the three input signals.

[Input Signal Description]:
a: First input signal for the AND operation.
b: Second input signal for the AND operation.
c: Third input signal for the AND operation.

[Output Signal Description]:
out: The output signal, which is the logical NOT of the AND operation result of the inputs a, b, c, and two constant high signals.

[Design Detail]: 
module topmodule (input a, input b, input c, output out);//
    
    wire outtmp;
    assign out = ~outtmp;
    andgate inst1 ( outtmp, a, b, c, 1, 1 );

endmodule",Bugs nand3.txt,Verilog_Practice\Bugs nand3.txt
"[Keyword]: Conditional

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is designed to find the minimum value among four 8-bit input values. It compares the inputs in pairs and determines the smallest value through a series of conditional assignments.

[Input Signal Description]:
a[7:0], b[7:0], c[7:0], d[7:0]: These are four 8-bit input signals representing the values to be compared to find the minimum.

[Output Signal Description]:
min[7:0]: This is an 8-bit output signal that holds the minimum value among the four input signals a, b, c, and d.

[Design Detail]: 
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min
);
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;
endmodule",Conditional.txt,Verilog_Practice\Conditional.txt
"[Keyword]: Conwaylife

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 256-bit cellular automaton, specifically a variant of Conway's Game of Life. The circuit updates the state of each cell in a 16x16 grid based on the states of its neighboring cells. The update rules are applied on each positive clock edge unless a load signal is active, in which case the grid is initialized with the input data.

[Input Signal Description]:
- `clk`: Clock signal that triggers the state update of the cellular automaton.
- `load`: Control signal that, when high, loads the input data into the grid instead of updating it based on the automaton rules.
- `data[255:0]`: 256-bit input signal used to initialize the grid when the load signal is high.

[Output Signal Description]:
- `q[255:0]`: 256-bit output signal representing the current state of the grid. Each bit corresponds to a cell in the 16x16 grid.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input load,
    input [255:0] data,
    output reg [255:0] q ); 

    reg [3:0] sum;

    always @(posedge clk) begin
        if (load) begin
            q  <= data;
        end
        else begin
            for (integer i = 0; i < 256; i++) begin
                if (i == 0) begin
                    sum = q[1]+q[16]+q[17]+q[240]+q[241]+q[15]+q[31]+q[255];
                end
                else if (i == 15) begin
                    sum = q[14]+q[16]+q[0]+q[240]+q[254]+q[30]+q[31]+q[255];
                end
                else if (i == 240) begin
                    sum = q[0]+q[15]+q[239]+q[241]+q[1]+q[224]+q[225]+q[255];
                end
                else if (i == 255) begin
                    sum = q[0]+q[15]+q[14]+q[224]+q[238]+q[240]+q[239]+q[254];
                end
                else if (i > 0 && i < 15) begin
                    sum = q[i-1]+q[i+1]+q[i+15]+q[i+16]+q[i+17]+q[i+239]+q[i+240]+q[i+241];
                end
                else if (i % 16 == 0) begin
                    sum = q[i-1]+q[i+1]+q[i+15]+q[i+16]+q[i+17]+q[i-16]+q[i-15]+q[i+31];
                end
                else if (i % 16 == 15) begin
                    sum = q[i-1]+q[i+1]+q[i+15]+q[i+16]+q[i-17]+q[i-16]+q[i-15]+q[i-31];
                end
                else if (i > 240 && i < 255) begin
                    sum = q[i-1]+q[i+1]+q[i-17]+q[i-16]+q[i-15]+q[i-239]+q[i-240]+q[i-241];
                end
                else begin
                    sum = q[i-1]+q[i+1]+q[i-17]+q[i-16]+q[i-15]+q[i+15]+q[i+16]+q[i+17];
                end

                if ((sum == 0 || sum == 1) || (sum >= 4)) begin
                    q[i] <= 0;
                end
                else if (sum == 3) begin
                    q[i] <= 1;
                end
            end
        end
    end

endmodule
```",Conwaylife.txt,Verilog_Practice\Conwaylife.txt
"[Keyword]: Count clock

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 12-hour clock with AM/PM indication. It counts hours, minutes, and seconds, and toggles the AM/PM indicator when the hour transitions from 11 to 12. The clock can be reset to 12:00:00 AM and can be enabled or disabled using the `ena` signal.

[Input Signal Description]:
- `clk`: Clock signal that drives the sequential logic.
- `reset`: Resets the clock to 12:00:00 AM when asserted.
- `ena`: Enable signal that allows the clock to increment when high.

[Output Signal Description]:
- `pm`: Indicates whether the time is in the PM period (1 for PM, 0 for AM).
- `hh`: 8-bit output representing the current hour in BCD format.
- `mm`: 8-bit output representing the current minute in BCD format.
- `ss`: 8-bit output representing the current second in BCD format.

[Design Detail]: 
```verilog
module topmodule 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule
```",Count clock.txt,Verilog_Practice\Count clock.txt
"[Keyword]: Count10

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a 4-bit decade counter that counts from 0 to 9. It increments the count on each positive edge of the clock signal. When the count reaches 9, it resets back to 0. The counter can also be reset to 0 synchronously when the reset signal is high.

[Input Signal Description]:
- clk: Clock signal that triggers the counter to increment on its positive edge.
- reset: Synchronous active-high reset signal that sets the counter to 0 when high.

[Output Signal Description]:
- q[3:0]: 4-bit output representing the current count value of the counter, ranging from 0 to 9.

[Design Detail]: 
module topmodule (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",Count10.txt,Verilog_Practice\Count10.txt
"[Keyword]: Count15

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a 4-bit binary counter with a synchronous reset. The counter increments on each positive edge of the clock and resets to zero when it reaches the maximum count of 15 or when the reset signal is active.

[Input Signal Description]:
- clk: Clock signal that triggers the counter to increment on its positive edge.
- reset: Synchronous active-high reset signal that sets the counter output to zero when asserted.

[Output Signal Description]:
- q[3:0]: 4-bit output representing the current count value of the counter.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule
```",Count15.txt,Verilog_Practice\Count15.txt
"[Keyword]: Count1to10

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a 4-bit decade counter that counts from 1 to 10. Upon reaching 10, it resets back to 1. The counter is synchronous with the clock signal and can be reset asynchronously to 1.

[Input Signal Description]:
clk: Clock signal that triggers the counter to increment on each rising edge.
reset: Asynchronous reset signal that sets the counter to 1 when asserted.

[Output Signal Description]:
q[3:0]: 4-bit output representing the current count value of the counter, ranging from 1 to 10.

[Design Detail]: 
module topmodule (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",Count1to10.txt,Verilog_Practice\Count1to10.txt
"[Keyword]: Countslow

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a decade counter that counts from 0 to 9. The counter increments on each positive edge of the clock signal when the `slowena` signal is high. If the counter reaches 9, it resets to 0 on the next clock cycle. The counter can also be reset to 0 asynchronously using the `reset` signal.

[Input Signal Description]:
- `clk`: Clock signal that triggers the counter to evaluate and potentially increment its value on each positive edge.
- `slowena`: Enable signal that allows the counter to increment when high. If low, the counter holds its current value.
- `reset`: Asynchronous reset signal that sets the counter value to 0 when high, regardless of the clock or enable signals.

[Output Signal Description]:
- `q[3:0]`: 4-bit output representing the current count value of the counter, ranging from 0 to 9.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule
```",Countslow.txt,Verilog_Practice\Countslow.txt
"[Keyword]: CS450counter2bc

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 2-bit saturating counter, often used in branch prediction logic. The counter has four states: Strongly Not Taken (SNT), Weakly Not Taken (WNT), Weakly Taken (WT), and Strongly Taken (ST). The state transitions are determined by the `trainvalid` and `traintaken` signals, which indicate whether a branch prediction should be updated and whether the branch was actually taken, respectively.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the state to Weakly Not Taken (WNT).
- `trainvalid`: Signal indicating whether the current training data is valid and should be used to update the state.
- `traintaken`: Signal indicating whether the branch was actually taken, used to determine the next state.

[Output Signal Description]:
- `state[1:0]`: 2-bit output representing the current state of the saturating counter, which can be one of the four states: SNT, WNT, WT, or ST.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,
    input trainvalid,
    input traintaken,
    output reg [1:0] state
);
    localparam SNT = 0, WNT = 1, WT = 2, ST = 3;
    wire [1:0] nextstate;
    
    always@(*)begin
        if (trainvalid) begin
            case(state)
                SNT: nextstate = traintaken?WNT:SNT;
                WNT: nextstate = traintaken?WT:SNT;
                WT: nextstate = traintaken?ST:WNT;
                ST: nextstate = traintaken?ST:WT;
            endcase
        end else begin
            case(state)
                SNT: nextstate = SNT;
                WNT: nextstate = WNT;
                WT: nextstate = WT;
                ST: nextstate = ST;
            endcase
        end
    end

    always@(posedge clk or posedge areset) begin
        if (areset) state <= WNT;
        else state <= nextstate;
    end

endmodule
```",CS450counter2bc.txt,Verilog_Practice\CS450counter2bc.txt
"[Keyword]: CS450gshare

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a branch predictor using a Pattern History Table (PHT) with a 2-bit saturating counter for each entry. The predictor uses the history of branch outcomes to predict whether a branch will be taken or not. It updates its prediction based on training data, which includes whether the previous prediction was correct or not.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the operations.
- `areset`: Asynchronous reset signal to initialize the predictor.
- `predictvalid`: Signal indicating if the prediction should be made.
- `predictpc[6:0]`: 7-bit program counter used for making predictions.
- `trainvalid`: Signal indicating if training data is available.
- `traintaken`: Signal indicating if the branch was actually taken.
- `trainmispredicted`: Signal indicating if the previous prediction was incorrect.
- `trainhistory[6:0]`: 7-bit history of previous branch outcomes used for training.
- `trainpc[6:0]`: 7-bit program counter used for training.

[Output Signal Description]:
- `predicttaken`: Output signal indicating the predicted outcome of the branch (taken or not taken).
- `predicthistory[6:0]`: 7-bit history of branch outcomes used for making predictions.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,

    input  predictvalid,
    input  [6:0] predictpc,
    output predicttaken,
    output [6:0] predicthistory,

    input trainvalid,
    input traintaken,
    input trainmispredicted,
    input [6:0] trainhistory,
    input [6:0] trainpc
);
    reg [1:0] PHT[127:0];

    always @(posedge clk, posedge areset) begin
        if (areset) begin
            predicthistory <= 0;
            for (integer i=0; i<128; i=i+1) begin
                PHT[i] <= 2'b01; //initialize to WNT, checkout couter2bc example
            end
        end
        else begin
            if (trainvalid) begin
                if (traintaken) PHT[trainhistory ^ trainpc] <= (PHT[trainhistory ^ trainpc] == 2'b11) ? 2'b11 : (PHT[trainhistory ^ trainpc] + 1);
            	else PHT[trainhistory ^ trainpc] <= (PHT[trainhistory ^ trainpc] == 2'b00) ? 2'b00 : (PHT[trainhistory ^ trainpc] - 1);
            end
            if (trainvalid && trainmispredicted) predicthistory <= {trainhistory[6:0], traintaken};
            else if (predictvalid) predicthistory <= {predicthistory[6:0], predicttaken};
    	end
    end
    assign predicttaken = PHT[predicthistory ^ predictpc][1];//""Not taken"" is 0x while ""taken"" is 1x 
endmodule
```",CS450gshare.txt,Verilog_Practice\CS450gshare.txt
"[Keyword]: CS450historyshift

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a branch prediction history register. It updates the prediction history based on the outcomes of branch predictions and training data. The history is updated on each clock cycle, and it can be reset asynchronously.

[Input Signal Description]:
- clk: Clock signal used to synchronize the updates of the prediction history.
- areset: Asynchronous reset signal that clears the prediction history when asserted.
- predictvalid: Signal indicating that a prediction has been made and the history should be updated with the prediction result.
- predicttaken: Signal indicating whether the branch was predicted to be taken.
- trainmispredicted: Signal indicating that the previous prediction was incorrect, prompting an update with the training data.
- traintaken: Signal indicating whether the branch was actually taken, used for updating the history when a misprediction occurs.
- trainhistory[31:0]: 32-bit input representing the historical prediction data used for training when a misprediction is detected.

[Output Signal Description]:
- predicthistory[31:0]: 32-bit output register that holds the history of branch predictions, updated based on the prediction and training signals.

[Design Detail]: 
module topmodule(
    input clk,
    input areset,

    input predictvalid,
    input predicttaken,
    output reg [31:0] predicthistory,

    input trainmispredicted,
    input traintaken,
    input [31:0] trainhistory
);
    always@(posedge clk or posedge areset) begin
        if (areset) predicthistory <= 32'b0;
        else begin
            if (trainmispredicted) predicthistory <= {trainhistory[30:0],traintaken};
            else if (predictvalid) predicthistory <= {predicthistory[30:0],predicttaken};
        end
    end

endmodule",CS450historyshift.txt,Verilog_Practice\CS450historyshift.txt
"[Keyword]: CS450timer

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a countdown counter with a loadable initial value. It counts down from a specified value and outputs a terminal count signal when the counter reaches zero.

[Input Signal Description]:
- clk: Clock signal that triggers the counter to decrement on each positive edge.
- load: Control signal to load the counter with a new value from the data input.
- data[9:0]: 10-bit input signal that provides the initial value to load into the counter when the load signal is active.

[Output Signal Description]:
- tc: Terminal count output signal that goes high when the counter reaches zero, indicating the countdown is complete.

[Design Detail]: 
module topmodule(
    input clk, 
    input load, 
    input [9:0] data, 
    output tc
);
    reg [9:0] counter;
    
    always@(posedge clk) begin
        if (load==1'b1) counter <= data;
        else counter <= (counter==10'b0)?counter:counter-1;
    end
    
    assign tc = (counter == 10'b0)?1'b1:1'b0;

endmodule",CS450timer.txt,Verilog_Practice\CS450timer.txt
"[Keyword]: Dff

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple D flip-flop. It captures the value of the input signal 'd' on the rising edge of the clock signal 'clk' and outputs it as 'q'. The output 'q' retains its value until the next rising edge of 'clk'.

[Input Signal Description]:
clk: Clock signal used to synchronize the data capture. The flip-flop captures the input 'd' on the rising edge of this clock.
d: Data input signal that is captured by the flip-flop on the rising edge of the clock.

[Output Signal Description]:
q: The output signal that holds the value of the input 'd' after the rising edge of the clock. It retains this value until the next rising edge of the clock.

[Design Detail]: 
module topmodule (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",Dff.txt,Verilog_Practice\Dff.txt
"[Keyword]: Dff16e

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a byte-enable register with asynchronous reset. It stores a 16-bit input data `d` into the output `q` based on the byte-enable signal `byteena`. The register updates its stored value on the rising edge of the clock `clk`, and it can reset to zero asynchronously when `resetn` is low.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the data storage.
- `resetn`: Active-low asynchronous reset signal. When low, it resets the output `q` to zero.
- `byteena[1:0]`: 2-bit byte-enable signal. `byteena[1]` controls the update of the upper byte (bits 15 to 8) of `q`, and `byteena[0]` controls the update of the lower byte (bits 7 to 0) of `q`.
- `d[15:0]`: 16-bit input data to be stored in the register.

[Output Signal Description]:
- `q[15:0]`: 16-bit output that holds the stored data. It updates based on the `byteena` signal and the input `d` on the rising edge of `clk`, or resets to zero when `resetn` is low.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output reg [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule
```",Dff16e.txt,Verilog_Practice\Dff16e.txt
"[Keyword]: Dff8

[Design Category]: Sequential Logic

[Design Function Description]:
This design is an 8-bit register that captures and holds the input data on the rising edge of the clock signal. It is a basic storage element used in sequential circuits.

[Input Signal Description]:
clk: Clock signal used to synchronize data capture.
d[7:0]: 8-bit data input signal that is captured and stored on the rising edge of the clock.

[Output Signal Description]:
q[7:0]: 8-bit output signal that holds the value of the input data after being captured on the rising edge of the clock.

[Design Detail]: 
module topmodule (
    input clk,
    input [7:0] d,
    output reg [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",Dff8.txt,Verilog_Practice\Dff8.txt
"[Keyword]: Dff8ar

[Design Category]: Sequential Logic

[Design Function Description]:
This design is an 8-bit register with an asynchronous reset. It captures the input data `d` on the rising edge of the clock `clk` and outputs it as `q`. If the asynchronous reset `areset` is active, the output `q` is reset to 0 regardless of the clock.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the data capture.
- `areset`: Active high asynchronous reset signal that resets the output `q` to 0 when high.
- `d[7:0]`: 8-bit data input that is captured and stored in the register on the rising edge of the clock.

[Output Signal Description]:
- `q[7:0]`: 8-bit output that holds the value of the input `d` after being captured by the clock. It is reset to 0 when `areset` is high.

[Design Detail]: 
module topmodule (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",Dff8ar.txt,Verilog_Practice\Dff8ar.txt
"[Keyword]: Dff8p

[Design Category]: Sequential Logic

[Design Function Description]:
This design is an 8-bit negative-edge triggered D flip-flop with an asynchronous reset. When the reset signal is active, the output is set to a predefined value (0x34). Otherwise, on the negative edge of the clock, the output follows the input data.

[Input Signal Description]:
- clk: Clock signal used to trigger the flip-flop on its negative edge.
- reset: Asynchronous reset signal. When high, it sets the output to a predefined value (0x34).
- d[7:0]: 8-bit data input signal that is captured on the negative edge of the clock when reset is not active.

[Output Signal Description]:
- q[7:0]: 8-bit output signal that holds the value of the input data 'd' on the negative edge of the clock, or the reset value (0x34) when reset is active.

[Design Detail]: 
module topmodule (
    input clk,
    input reset,
    input [7:0] d,
    output reg [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",Dff8p.txt,Verilog_Practice\Dff8p.txt
"[Keyword]: Dff8r

[Design Category]: Sequential Logic

[Design Function Description]:
This design is an 8-bit synchronous register with a synchronous reset. It captures the input data `d` on the rising edge of the clock `clk` and outputs it as `q`. If the `reset` signal is high during a clock edge, the output `q` is reset to 0.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the data capture.
- `reset`: Synchronous reset signal. When high, it resets the output `q` to 0 on the next rising edge of `clk`.
- `d[7:0]`: 8-bit data input that is captured and stored in the register on the rising edge of `clk` when `reset` is low.

[Output Signal Description]:
- `q[7:0]`: 8-bit output that holds the value of the input `d` after being captured on the rising edge of `clk`. It is reset to 0 when `reset` is high.

[Design Detail]: 
module topmodule (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",Dff8r.txt,Verilog_Practice\Dff8r.txt
"[Keyword]: ece241 2013 q

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with three states: start, mid, and ends. The FSM transitions between these states based on the input signal `x`. The output `z` is determined by the current state and the input `x`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `aresetn`: Asynchronous active-low reset signal that initializes the FSM to the start state when asserted low.
- `x`: Input signal that influences state transitions within the FSM.

[Output Signal Description]:
- `z`: Output signal that is determined by the current state of the FSM. It is set to 0 in the start and mid states, and it follows the input `x` in the ends state.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input aresetn,    // Asynchronous active-low reset
    input x,
    output z ); 

    parameter start = 0, mid = 1, ends = 2;
    reg [2:0] state, nextstate;

    always @(*) begin
        case (state)
            start: nextstate = x ? mid : start;
            mid: nextstate = x ? mid : ends;
            ends: nextstate = x ? mid : start;
        endcase
    end

    always @(posedge clk or negedge aresetn) begin
        if (!aresetn) begin
            state <= start;
        end
        else begin
            state <= nextstate;
        end
    end

    always @(*) begin
        case (state)
            start: z = 0;
            mid: z = 0;
            ends: z = x;
        endcase
    end

endmodule
```",ece241 2013 q.txt,Verilog_Practice\ece241 2013 q.txt
"[Keyword]: ece241 2013 q2

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a logic circuit that calculates the Sum of Products (SOP) and Product of Sums (POS) for a given set of inputs. The circuit outputs the same result for both SOP and POS forms, indicating that the logic expressions are equivalent.

[Input Signal Description]:
a, b, c, d: These are the 1-bit input signals to the circuit. They represent the variables used in the logic expressions for SOP and POS.

[Output Signal Description]:
outsop: This is the output signal representing the result of the Sum of Products expression.
outpos: This is the output signal representing the result of the Product of Sums expression. In this design, it is equivalent to outsop.

[Design Detail]: 
module topmodule (
    input a,
    input b,
    input c,
    input d,
    output outsop,
    output outpos
); 
    
    assign outsop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign outpos = outsop;

endmodule",ece241 2013 q2.txt,Verilog_Practice\ece241 2013 q2.txt
"[Keyword]: ece241 2013 q4

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with six states (A2, B1, B2, C1, C2, D1). The FSM transitions between these states based on the input signals and outputs a 4-bit signal that changes according to the current state.

[Input Signal Description]:
- clk: Clock signal that synchronizes the state transitions.
- reset: Asynchronous reset signal that initializes the FSM to state A2.
- s[3:1]: 3-bit input signal that influences the state transitions of the FSM.

[Output Signal Description]:
- fr3, fr2, fr1, dfr: 4-bit output signals that represent the current state of the FSM. Each state has a unique 4-bit output pattern.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
```",ece241 2013 q4.txt,Verilog_Practice\ece241 2013 q4.txt
"[Keyword]: ece241 2013 q7

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a JK flip-flop, a type of sequential logic circuit that changes its output state based on the inputs J and K and the clock signal. The JK flip-flop is a versatile memory element used in various digital systems.

[Input Signal Description]:
- clk: Clock signal that triggers the state change on its rising edge.
- j: J input, used to control the set/reset behavior of the flip-flop.
- k: K input, used to control the toggle/reset behavior of the flip-flop.

[Output Signal Description]:
- Q: The output of the JK flip-flop, which holds the current state of the flip-flop.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input j,
    input k,
    output reg Q
); 
    
    always @(posedge clk) begin
        if (!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule
```",ece241 2013 q7.txt,Verilog_Practice\ece241 2013 q7.txt
"[Keyword]: ece241 2014 q1c

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements an 8-bit adder with overflow detection. It adds two 8-bit numbers and provides the sum as well as an overflow flag that indicates if the addition resulted in a signed overflow.

[Input Signal Description]:
a[7:0]: An 8-bit input operand for the addition.
b[7:0]: Another 8-bit input operand for the addition.

[Output Signal Description]:
s[7:0]: The 8-bit result of the addition of inputs a and b.
overflow: A 1-bit signal that indicates if a signed overflow occurred during the addition. It is set to 1 if both input operands have the same sign and the result has a different sign.

[Design Detail]: 
module topmodule (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",ece241 2014 q1c.txt,Verilog_Practice\ece241 2014 q1c.txt
"[Keyword]: ece241 2014 q3

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple combinational logic circuit that generates a 4-bit output vector based on the logical operations performed on two input signals, c and d.

[Input Signal Description]:
c: A single-bit input signal.
d: A single-bit input signal.

[Output Signal Description]:
muxin[3:0]: A 4-bit output vector where each bit is the result of a different logical operation on the inputs c and d. Specifically:
- muxin[0] is the result of the logical OR operation between c and d.
- muxin[1] is a constant 0.
- muxin[2] is the logical NOT of d.
- muxin[3] is the result of the logical AND operation between c and d.

[Design Detail]: 
module topmodule (
    input c,
    input d,
    output [3:0] muxin
); 
    
    assign muxin[0] = c | d;
    assign muxin[1] = 0;
    assign muxin[2] = ~d;
    assign muxin[3] = c & d;

endmodule",ece241 2014 q3.txt,Verilog_Practice\ece241 2014 q3.txt
"[Keyword]: ece241 2014 q4

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a sequential logic circuit that uses a 3-bit register `Q` to perform bitwise operations based on the input `x` at every positive edge of the clock signal `clk`. The output `z` is determined by the logical negation of the OR operation on the bits of `Q`.

[Input Signal Description]:
- `clk`: Clock signal that triggers the sequential logic on its positive edge.
- `x`: Input signal used to modify the state of the 3-bit register `Q`.

[Output Signal Description]:
- `z`: Output signal that is the negation of the OR operation on the bits of the register `Q`. It is initially set to 1.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input x,
    output z
); 
    reg [2:0] Q;
    initial z = 1;
    always @(posedge clk) begin
        Q[0] = Q[0] ^ x;
        Q[1] = ~Q[1] & x;
        Q[2] = ~Q[2] | x;
        z = ~(Q[0] | Q[1] | Q[2]); 
    end

endmodule
```",ece241 2014 q4.txt,Verilog_Practice\ece241 2014 q4.txt
"[Keyword]: ece241 2014 q5a

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with three states (S0, S1, S2). The FSM transitions between these states based on the input signal `x`. The output `z` is determined by the current state, producing a specific output pattern as the FSM transitions through its states.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the FSM to state S0 when asserted.
- `x`: Input signal that influences state transitions within the FSM.

[Output Signal Description]:
- `z`: Output signal that reflects the current state of the FSM. It is set to `1` in state S1 and `0` in states S0 and S2.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] nextstate;
    
    always @(*) begin
        case(state)
            S0 : begin
                nextstate = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                nextstate = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                nextstate = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                nextstate = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= nextstate;
    end
    
endmodule
```",ece241 2014 q5a.txt,Verilog_Practice\ece241 2014 q5a.txt
"[Keyword]: ece241 2014 q5bhigh

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple finite state machine (FSM) with two states, S0 and S1. The FSM transitions between these states based on the input signal `x`. The output `z` is determined by the current state and the input `x`. The FSM is reset to the initial state S0 when the asynchronous reset signal `areset` is asserted.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the FSM to the starting state S0.
- `x`: Input signal that influences state transitions and output behavior.

[Output Signal Description]:
- `z`: Output signal that reflects the current state and input `x`. In state S0, `z` follows the input `x`. In state S1, `z` is the inverse of `x`.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input areset,
    input x,
    output z
); 
    localparam S0 = 0, S1 = 1;
    reg [1:0] state;
    reg [1:0] nextstate;
    
    always @(*) begin
        nextstate = 2'b0;
        case(1'b1)
            state[S0] : begin
                nextstate[S1] = x ? 1'b1 : 1'b0;
                nextstate[S0] = x ? 1'b0 : 1'b1;
                z = x;
            end
            
            state[S1] : begin
                nextstate[S1] = 1'b1;
                nextstate[S0] = 1'b0;
                z = ~x;
            end
            
            default : begin
                nextstate[S0] = 1'b1;
                nextstate[S1] = 1'b0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  begin
            state <= 2'b0;
            state[S0] <= 1'b1;
        end
        else
            state <= nextstate;
    end
   
endmodule
```",ece241 2014 q5bhigh.txt,Verilog_Practice\ece241 2014 q5bhigh.txt
"[Keyword]: Edgedetect

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit detects positive edges on each bit of an 8-bit input signal. It outputs a corresponding 8-bit signal where each bit indicates whether a positive edge (a transition from 0 to 1) has occurred on the respective input bit.

[Input Signal Description]:
- clk: Clock signal used to synchronize the detection of positive edges.
- in[7:0]: 8-bit input signal on which positive edge detection is performed.

[Output Signal Description]:
- pedge[7:0]: 8-bit output signal where each bit is set to 1 if a positive edge is detected on the corresponding input bit, otherwise it is set to 0.

[Design Detail]: 
module topmodule (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] intmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(intmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            intmp[i] = in[i];
        end
    end
endmodule",Edgedetect.txt,Verilog_Practice\Edgedetect.txt
"[Keyword]: Edgedetect2

[Design Category]: Sequential Logic

[Design Function Description]:
The circuit detects any edge (rising or falling) on each bit of an 8-bit input signal. It outputs a corresponding 8-bit signal where each bit indicates whether an edge has occurred on the respective input bit since the last clock cycle.

[Input Signal Description]:
- clk: Clock signal used to synchronize the edge detection process.
- in[7:0]: 8-bit input signal whose edges (transitions from 0 to 1 or 1 to 0) are to be detected.

[Output Signal Description]:
- anyedge[7:0]: 8-bit output signal where each bit is set to 1 if an edge is detected on the corresponding input bit, otherwise it is set to 0.

[Design Detail]: 
module topmodule (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] intmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(intmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            intmp[i] = in[i];
        end
    end

endmodule",Edgedetect2.txt,Verilog_Practice\Edgedetect2.txt
"[Keyword]: Exams2014 q4b

[Design Category]: Sequential Logic

[Design Function Description]:
The design implements a shift register with load and enable functionality. Each stage of the shift register is controlled by a multiplexer and a D flip-flop. The circuit can load new data from the switches (SW) or shift the data based on the enable (E) and load (L) signals.

[Input Signal Description]:
- SW[3:0]: 4-bit input signal used to load new data into the shift register.
- KEY[0]: Clock signal (clk) for synchronizing the data shifting/loading.
- KEY[1]: Enable signal (E) that allows data to be shifted when high.
- KEY[2]: Load signal (L) that allows new data from SW to be loaded into the register when high.
- KEY[3]: Initial input for the first stage of the shift register.

[Output Signal Description]:
- LEDR[3:0]: 4-bit output signal representing the current state of the shift register. Each bit corresponds to the output of a stage in the register.

[Design Detail]: 
```verilog
module topmodule (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output reg out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule
```",Exams2014 q4b.txt,Verilog_Practice\Exams2014 q4b.txt
"[Keyword]: Examsece241 2013 q12high

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements an 8-bit shift register with a parallel output. The shift register shifts its contents on the rising edge of the clock when the enable signal is high. The output Z is determined by the value of the 3-bit address formed by inputs A, B, and C, which selects one of the bits from the shift register.

[Input Signal Description]:
- clk: Clock signal that triggers the shift operation on its rising edge.
- enable: Control signal that allows the shift operation when high.
- S: Serial input bit that is shifted into the register.
- A, B, C: 3-bit address input used to select which bit of the shift register is output to Z.

[Output Signal Description]:
- Z: Output signal that represents the value of the bit in the shift register at the position specified by the address formed by A, B, and C.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    reg [7:0] Q = 0;
    
    always @(posedge clk) begin
        if(enable) begin
            Q <= {Q[6:0], S};
        end
    end
    
    assign Z = Q[{A, B, C}];

endmodule
```",Examsece241 2013 q12high.txt,Verilog_Practice\Examsece241 2013 q12high.txt
"[Keyword]: Examsece241 2014 q7a

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 4-bit counter with additional control logic. The counter counts from 1 to 12 and resets back to 1. It includes enable and reset functionality, and it interfaces with another module, `count4`, using control signals `cenable`, `cload`, and `cd`.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing the counter operations.
- `reset`: Resets the counter to 1 when asserted.
- `enable`: Enables the counter to increment when asserted.

[Output Signal Description]:
- `Q[3:0]`: 4-bit output representing the current count value.
- `cenable`: Control signal passed to the `count4` module, mirroring the `enable` input.
- `cload`: Control signal indicating when to load a new value into the `count4` module.
- `cd[3:0]`: Data signal for the `count4` module, set to 1 when `cload` is asserted.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output cenable,
    output cload,
    output [3:0] cd
); //
    wire [3:0] Qtmp;
    assign cenable = enable;
    assign cd = cload ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Qtmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Qtmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Qtmp <= Qtmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && cenable)) begin
            cload <= 1;
        end
        else begin
            cload <= 0;
        end
    end

    count4 thecounter (clk, cenable, cload, cd, Qtmp);

endmodule
```",Examsece241 2014 q7a.txt,Verilog_Practice\Examsece241 2014 q7a.txt
"[Keyword]: Examsece241 2014 q7bhigh

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a frequency divider that generates a 1 Hz signal from a higher frequency clock input. It uses a series of BCD (Binary-Coded Decimal) counters to count clock cycles and produce an output signal, `OneHertz`, that toggles every second. The `cenable` signals control the enablement of each BCD counter stage.

[Input Signal Description]:
- `clk`: The clock input signal that drives the counters.
- `reset`: A signal used to reset the counters to their initial state.

[Output Signal Description]:
- `OneHertz`: A signal that toggles at a frequency of 1 Hz, indicating the completion of a full count cycle.
- `cenable[2:0]`: A 3-bit signal that enables the counting operation of each BCD counter stage based on the current count values.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] cenable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, cenable[0], q0);
    bcdcount counter1 (clk, reset, cenable[1], q1);
    bcdcount counter2 (clk, reset, cenable[2], q2);

    assign cenable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule
```",Examsece241 2014 q7bhigh.txt,Verilog_Practice\Examsece241 2014 q7bhigh.txt
"[Keyword]: Examsm2014 q4k

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 3-bit shift register with synchronous reset functionality. The shift register captures the input signal 'in' on each rising edge of the clock and shifts it through three stages. The output 'out' reflects the value of the third stage of the shift register.

[Input Signal Description]:
- clk: Clock signal that triggers the shifting operation on its rising edge.
- resetn: Synchronous reset signal. When low, it resets the shift register to zero on the next clock edge.
- in: Input signal that is shifted into the register.

[Output Signal Description]:
- out: Output signal representing the value of the third stage of the shift register.

[Design Detail]: 
module topmodule (
    input clk,
    input resetn,   // synchronous reset
    input in,
    output out);
    
    reg [2:0] Q;
    
    always @(posedge clk) begin
        Q[0] <= (resetn) ? in : 0;
        Q[1] <= (resetn) ? Q[0] : 0;
        Q[2] <= (resetn) ? Q[1] : 0;
        out <= (resetn) ? Q[2] : 0;
    end

endmodule",Examsm2014 q4k.txt,Verilog_Practice\Examsm2014 q4k.txt
"[Keyword]: Fadd

[Design Category]: Arithmetic Circuits

[Design Function Description]: 
This design implements a 1-bit full adder. A full adder is a digital circuit that computes the sum of three binary bits, including a carry-in bit, and produces a sum and a carry-out bit.

[Input Signal Description]: 
- a: A 1-bit input representing one of the addends.
- b: A 1-bit input representing the other addend.
- cin: A 1-bit input representing the carry-in from a previous less significant bit addition.

[Output Signal Description]: 
- sum: A 1-bit output representing the sum of the inputs a, b, and cin.
- cout: A 1-bit output representing the carry-out, which is used as the carry-in for the next more significant bit addition.

[Design Detail]: 
module topmodule( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",Fadd.txt,Verilog_Practice\Fadd.txt
"[Keyword]: Fsm hdlc

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) that processes a serial input stream. The FSM transitions through a series of states based on the input signal and generates specific output signals when certain conditions are met. It detects sequences of consecutive '1's and outputs signals to indicate when a sequence should be discarded, flagged, or when an error occurs.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `reset`: Synchronous reset signal that initializes the FSM to the starting state (`none`).
- `in`: Serial input signal that the FSM processes to determine state transitions.

[Output Signal Description]:
- `disc`: Output signal that is asserted when the FSM reaches the `discard` state, indicating a sequence should be discarded.
- `flag`: Output signal that is asserted when the FSM reaches the `flagg` state, indicating a valid sequence has been detected.
- `err`: Output signal that is asserted when the FSM reaches the `error` state, indicating an error condition due to an invalid sequence.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input reset,    // Synchronous reset
    input in,
    output disc,
    output flag,
    output err);

    parameter none=4'd0, one=4'd1, two=4'd2, three=4'd3, four=4'd4, five=4'd5, six=4'd6, error=4'd7, discard=4'd8, flagg=4'd9;
    reg [3:0]   state, nextstate;
    
    always@(*) begin
        case({state, in})
            {none, 1'b0}:   nextstate = none;
            {none, 1'b1}:   nextstate = one;
            {one, 1'b0}:    nextstate = none;
            {one, 1'b1}:    nextstate = two;
            {two, 1'b0}:    nextstate = none;
            {two, 1'b1}:    nextstate = three;
            {three, 1'b0}:  nextstate = none;
            {three, 1'b1}:  nextstate = four;
            {four, 1'b0}:   nextstate = none;
            {four, 1'b1}:   nextstate = five;
            {five, 1'b0}:   nextstate = discard;
            {five, 1'b1}:   nextstate = six;
            {six, 1'b0}:    nextstate = flagg;
            {six, 1'b1}:    nextstate = error;
            {error, 1'b0}:  nextstate = none;
            {error, 1'b1}:  nextstate = error;
            {discard, 1'b0}:nextstate = none;
            {discard, 1'b1}:nextstate = one;
            {flagg, 1'b0}:  nextstate = none;
            {flagg, 1'b1}:  nextstate = one;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= none;
        else
            state <= nextstate;
    end
    
    assign  disc = (state == discard);
    assign  flag = (state == flagg);
    assign  err = (state == error);
    
endmodule
```",Fsm hdlc.txt,Verilog_Practice\Fsm hdlc.txt
"[Keyword]: Fsm onehot

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with 10 states. The FSM transitions between states based on the input signal 'in' and the current state. It also produces two output signals, 'out1' and 'out2', based on the current state.

[Input Signal Description]:
- in: A single-bit input signal that influences state transitions.
- state[9:0]: A 10-bit input vector representing the current state of the FSM.

[Output Signal Description]:
- nextstate[9:0]: A 10-bit output vector representing the next state of the FSM based on the current state and input signal.
- out1: A single-bit output signal that is high when the FSM is in state 8 or state 9.
- out2: A single-bit output signal that is high when the FSM is in state 7 or state 9.

[Design Detail]: 
module topmodule(
    input in,
    input [9:0] state,
    output [9:0] nextstate,
    output out1,
    output out2);

    assign nextstate[0] = ~in & (state[0] | state[1] | state[2] | state[3] | state[4] | state[7] | state[8] | state[9]);
    assign nextstate[1] = in & (state[0] | state[8] | state[9]);
    assign nextstate[2] = in & state[1];
    assign nextstate[3] = in & state[2];
    assign nextstate[4] = in & state[3];
    assign nextstate[5] = in & state[4];
    assign nextstate[6] = in & state[5];
    assign nextstate[7] = in & (state[6] | state[7]);
    assign nextstate[8] = ~in & state[5];
    assign nextstate[9] = ~in & state[6];
 
    assign out1 = state[8] | state[9];
    assign out2 = state[7] | state[9];

endmodule",Fsm onehot.txt,Verilog_Practice\Fsm onehot.txt
"[Keyword]: Fsm ps2

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with four states. The FSM processes an 8-bit input signal and transitions between states based on the value of the third bit of the input. The FSM starts in the `byte1` state and transitions through `byte2`, `byte3`, and finally to the `dn` state. The `done` output signal is asserted when the FSM reaches the `dn` state.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `in[7:0]`: 8-bit input signal used to determine state transitions based on the value of `in[3]`.
- `reset`: Synchronous reset signal that initializes the FSM to the `byte1` state.

[Output Signal Description]:
- `done`: Output signal that is asserted (set to 1) when the FSM reaches the `dn` state, indicating the completion of the state sequence.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, nextstate;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: nextstate = byte1;
            {byte1, 1'b1}: nextstate = byte2;
            {byte2, 1'b0}: nextstate = byte3;
            {byte2, 1'b1}: nextstate = byte3;
            {byte3, 1'b0}: nextstate = dn;
            {byte3, 1'b1}: nextstate = dn;
            {dn, 1'b0}: nextstate = byte1;
            {dn, 1'b1}: nextstate = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= nextstate;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule
```",Fsm ps2.txt,Verilog_Practice\Fsm ps2.txt
"[Keyword]: Fsm ps2data

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) that processes a sequence of 8-bit input data bytes. It stores three consecutive bytes and outputs them as a 24-bit value when the FSM reaches a specific state, indicating that the sequence is complete.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and data storage.
- `in[7:0]`: 8-bit input signal representing the data byte to be processed.
- `reset`: Synchronous reset signal that initializes the FSM to its starting state and clears the stored data.

[Output Signal Description]:
- `outbytes[23:0]`: 24-bit output signal that holds the concatenated three bytes of data when the FSM reaches the 'done' state.
- `done`: A signal indicating that the FSM has reached the 'done' state, meaning the 24-bit output is valid.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] outbytes,
    output done); //

    // FSM from fsmps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, nextstate;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: nextstate = b1;
            {b1, 1'b1}: nextstate = b2;
            {b2, 1'b0}: nextstate = b3;
            {b2, 1'b1}: nextstate = b3;
            {b3, 1'b0}: nextstate = dn;
            {b3, 1'b1}: nextstate = dn;
            {dn, 1'b0}: nextstate = b1;
            {dn, 1'b1}: nextstate = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= nextstate;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign outbytes = (done) ? data : 24'd0;

endmodule
```",Fsm ps2data.txt,Verilog_Practice\Fsm ps2data.txt
"[Keyword]: Fsm serial

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) that processes an input signal `in` and transitions through different states based on the input and a counter. The FSM has four states: `rd` (read), `rc` (receive), `dn` (done), and `err` (error). The FSM counts up to 8 cycles in the `rc` state and transitions to `dn` or `err` based on the input signal. The `done` output indicates when the FSM has reached the `dn` state.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions.
- `in`: Input signal that influences state transitions.
- `reset`: Synchronous reset signal that initializes the FSM to the `rd` state and resets the counter `i`.

[Output Signal Description]:
- `done`: Output signal that is asserted when the FSM reaches the `dn` state, indicating the completion of a specific sequence.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, nextstate;

    always @(*) begin
        case (state)
            rd: nextstate <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    nextstate <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    nextstate <= err;
                end
                else begin
                    nextstate <= rc;
                end
            end
            dn: nextstate <= in ? rd : rc;
            err: nextstate <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= nextstate;
        end
    end

    assign done = (state == dn);

endmodule
```",Fsm serial.txt,Verilog_Practice\Fsm serial.txt
"[Keyword]: Fsm serialdata

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) to receive a serial data stream and output an 8-bit byte once 8 bits have been successfully received. The FSM handles different states for reading data, checking for completion, and error handling.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and data latching.
- `in`: Serial input signal from which the 8-bit data is received.
- `reset`: Synchronous reset signal to initialize the FSM to its starting state.

[Output Signal Description]:
- `outbyte[7:0]`: 8-bit output that holds the received byte once 8 bits have been successfully read.
- `done`: Signal indicating that a complete byte has been successfully received and is available on `outbyte`.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] outbyte,
    output done
); //

    // Use FSM from Fsmserial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, nextstate;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: nextstate <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    nextstate <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    nextstate <= err;
                end
                else begin
                    nextstate <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                nextstate <= in ? rd : rc;
                outbyte <= date;
            end
            err: nextstate <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= nextstate;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule
```",Fsm serialdata.txt,Verilog_Practice\Fsm serialdata.txt
"[Keyword]: Fsm serialdp

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) that receives serial data input, processes it, and checks for parity. The FSM transitions through various states to capture an 8-bit data byte, checks for parity, and indicates when the data byte is ready and valid.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state transitions and data processing.
- `in`: Serial data input signal that provides the bits to be captured and processed.
- `reset`: Synchronous reset signal that initializes the FSM to the idle state and clears data.

[Output Signal Description]:
- `outbyte[7:0]`: 8-bit output that holds the captured data byte when the FSM indicates the data is ready.
- `done`: Signal that indicates when the data byte is fully captured and valid, based on parity checking.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] outbyte,
    output done
); //

    // Modify FSM and datapath from Fsmserialdata
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2,trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, err = 4'd11, pari = 4'd12;
    reg [3:0] state, nextstate;
    reg [7:0] data;
    wire odd, resetp;
    reg donereg;

    always @(*) begin
        case (state)
            idle:   nextstate <= in ? idle : start;
            start:  nextstate <= trans0;
            trans0: nextstate <= trans1;
            trans1: nextstate <= trans2;
            trans2: nextstate <= trans3;
            trans3: nextstate <= trans4;
            trans4: nextstate <= trans5;
            trans5: nextstate <= trans6;
            trans6: nextstate <= trans7;
            trans7: nextstate <= pari;
            pari:   nextstate <= in ? idle : err;
            err:    nextstate <= in ? idle : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= nextstate;
        end
    end

    // New: Add parity checking.
    always @(posedge clk) begin
        if (reset) begin
            data <= 8'd0;
            resetp <= 1'b1;
            donereg <= 1'b0;
        end
        else begin
            if (nextstate == trans0 || nextstate == trans1 || nextstate == trans2 || nextstate == trans3 || nextstate == trans4 || nextstate == trans5 || nextstate == trans6 || nextstate == trans7) begin
                data <= {in, data[7:1]};
            end
            else if (nextstate == start) begin
                data <= 8'd0;
                resetp <= 1'b0;
                donereg <= 1'b0;
            end
            else if (nextstate == idle) begin
                donereg <= odd;
            end
            else if (nextstate == pari) begin
                resetp <= 1'b1;
            end
        end
    end

    assign done = donereg;
    assign outbyte = done ? data : 8'd0;
    parity parmod(clk, reset | resetp, in, odd);

endmodule
```",Fsm serialdp.txt,Verilog_Practice\Fsm serialdp.txt
"[Keyword]: Fsm1

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple finite state machine (FSM) with two states, A and B. The FSM transitions between these states based on the input signal 'in'. The state transitions are controlled by a clock signal and an asynchronous reset signal. The output 'out' is determined by the current state of the FSM.

[Input Signal Description]:
- clk: Clock signal that synchronizes the state transitions.
- areset: Asynchronous reset signal that forces the FSM to state B when asserted.
- in: Input signal that influences the state transitions between A and B.

[Output Signal Description]:
- out: Output signal that is high when the FSM is in state B and low when in state A.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,    // Asynchronous reset to state B
    input in,
    output out
);  

    parameter A = 0, B = 1; 
    reg state, nextstate;

    always @(*) begin    // This is a combinational always block
        // State transition logic
        case (state)
            A: nextstate <= in ? A : B;
            B: nextstate <= in ? B : A;
        endcase
    end

    always @(posedge clk, posedge areset) begin    // This is a sequential always block
        // State flip-flops with asynchronous reset
        if (areset) begin
            state <= B;
        end
        else begin
            state <= nextstate;
        end
    end

    // Output logic
    assign out = (state == B);

endmodule
```",Fsm1.txt,Verilog_Practice\Fsm1.txt
"[Keyword]: Fsm1s

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple finite state machine (FSM) with two states, A and B. The FSM transitions between these states based on the input signal 'in'. The output 'out' is determined by the current state, specifically it is high when the FSM is in state B.

[Input Signal Description]:
- clk: Clock signal that synchronizes the state transitions.
- reset: Synchronous reset signal that initializes the FSM to state B when asserted.
- in: Input signal that influences state transitions between A and B.

[Output Signal Description]:
- out: Output signal that is high when the FSM is in state B and low when in state A.

[Design Detail]: 
```verilog
// Note the Verilog-1995 module declaration syntax here:
module topmodule(clk, reset, in, out);
    input clk;
    input reset;    // Synchronous reset to state B
    input in;
    output out;//  
    reg out;

    // Fill in state name declarations
    parameter A = 0, B = 1;

    reg presentstate, nextstate;

    always @(posedge clk) begin
        if (reset) begin  
            // Fill in reset logic
            presentstate <= B;
        end else begin
            presentstate <= nextstate;
        end
    end

    always @(*) begin
        case (presentstate)
            A: nextstate <= in ? A : B;
            B: nextstate <= in ? B : A;
        endcase
    end

    assign out = (presentstate == B);

endmodule
```",Fsm1s.txt,Verilog_Practice\Fsm1s.txt
"[Keyword]: Fsm2

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a JK flip-flop with an asynchronous reset. The JK flip-flop is a type of sequential logic circuit that can toggle its output state based on the inputs J and K. The circuit transitions between two states, ON and OFF, depending on the values of J and K. The asynchronous reset allows the flip-flop to be reset to the OFF state regardless of the clock signal.

[Input Signal Description]:
- clk: Clock signal that synchronizes the state transitions.
- areset: Asynchronous reset signal that forces the state to OFF when asserted.
- j: Input signal that, when high, can set the state to ON if the current state is OFF.
- k: Input signal that, when high, can reset the state to OFF if the current state is ON.

[Output Signal Description]:
- out: Output signal that reflects the current state of the flip-flop. It is high when the state is ON and low when the state is OFF.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,    // Asynchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF = 0, ON = 1; 
    reg state, nextstate;

    always @(*) begin
        // State transition logic
        case (state)
            ON: nextstate <= k ? OFF : ON;
            OFF: nextstate <= j ? ON : OFF;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
        if (areset) begin
            state <= OFF;
        end
        else begin
            state <= nextstate;
        end
    end

    // Output logic
    // assign out = (state == ...);
    assign out = (state == ON);

endmodule
```",Fsm2.txt,Verilog_Practice\Fsm2.txt
"[Keyword]: Fsm2s

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a JK flip-flop with synchronous reset functionality. The circuit transitions between two states, ON and OFF, based on the inputs j and k. The output reflects the current state of the flip-flop.

[Input Signal Description]:
- clk: Clock signal used to synchronize state transitions.
- reset: Synchronous reset signal that sets the state to OFF when asserted.
- j: Input signal that, when high, transitions the state from OFF to ON.
- k: Input signal that, when high, transitions the state from ON to OFF.

[Output Signal Description]:
- out: Output signal that indicates the current state of the flip-flop. It is high when the state is ON and low when the state is OFF.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input reset,    // Synchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF = 0, ON = 1; 
    reg state, nextstate;

    always @(*) begin
        // State transition logic
        case (state)
            ON: nextstate <= k ? OFF : ON;
            OFF: nextstate <= j ? ON : OFF;
        endcase
    end

    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if (reset) begin
            state <= OFF;
        end
        else begin
            state <= nextstate;
        end
    end

    // Output logic
    // assign out = (state == ...);
    assign out = (state == ON);

endmodule
```",Fsm2s.txt,Verilog_Practice\Fsm2s.txt
"[Keyword]: Fsm3

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with four states (A, B, C, D). The FSM transitions between these states based on the input signal 'in'. The output 'out' is asserted when the FSM is in state D. The FSM also includes an asynchronous reset to initialize the state to A.

[Input Signal Description]:
- clk: Clock signal used to synchronize state transitions.
- in: Input signal that influences state transitions.
- areset: Asynchronous reset signal that initializes the FSM to state A when asserted.

[Output Signal Description]:
- out: Output signal that is asserted (set to 1) when the FSM is in state D, otherwise it is deasserted (set to 0).

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, nextstate;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: nextstate <= in ? B : A;
            B: nextstate <= in ? B : C;
            C: nextstate <= in ? D : A;
            D: nextstate <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= nextstate;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule
```",Fsm3.txt,Verilog_Practice\Fsm3.txt
"[Keyword]: Fsm3comb

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a Moore state machine with four states (A, B, C, D). The state transitions depend on the current state and an input signal. The output is determined solely by the current state.

[Input Signal Description]:
- `in`: A single-bit input signal that influences state transitions.
- `state[1:0]`: A 2-bit signal representing the current state of the state machine.

[Output Signal Description]:
- `nextstate[1:0]`: A 2-bit signal representing the next state of the state machine based on the current state and input.
- `out`: A single-bit output signal that is high (1) when the state machine is in state D, and low (0) otherwise.

[Design Detail]: 
```verilog
module topmodule(
    input in,
    input [1:0] state,
    output [1:0] nextstate,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: nextstate = f(state, in)
    always @(*) begin
        case (state)
            A: nextstate <= in ? B : A;
            B: nextstate <= in ? B : C;
            C: nextstate <= in ? D : A;
            D: nextstate <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule
```",Fsm3comb.txt,Verilog_Practice\Fsm3comb.txt
"[Keyword]: Fsm3onehot

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with four states (A, B, C, D). The FSM transitions between these states based on the input signal 'in'. The output 'out' is determined by the current state of the FSM, specifically when the FSM is in state D.

[Input Signal Description]:
- in: A single-bit input signal that influences the state transitions of the FSM.
- state[3:0]: A 4-bit input signal representing the current state of the FSM, where each bit corresponds to one of the states A, B, C, or D.

[Output Signal Description]:
- nextstate[3:0]: A 4-bit output signal representing the next state of the FSM after evaluating the current state and input.
- out: A single-bit output signal that is high (1) when the FSM is in state D, and low (0) otherwise.

[Design Detail]: 
module topmodule(
    input in,
    input [3:0] state,
    output [3:0] nextstate,
    output out
); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign nextstate[A] = state[A] & (~in) | state[C] & (~in);
    assign nextstate[B] = state[A] & in | state[B] & in | state[D] & in;
    assign nextstate[C] = state[B] & (~in) | state[D] & (~in);
    assign nextstate[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",Fsm3onehot.txt,Verilog_Practice\Fsm3onehot.txt
"[Keyword]: Fsm3s

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with four states (A, B, C, D). The FSM transitions between these states based on the input signal 'in'. The output 'out' is asserted when the FSM is in state D.

[Input Signal Description]:
- clk: Clock signal used to synchronize state transitions.
- in: Input signal that influences state transitions.
- reset: Synchronous reset signal that initializes the FSM to state A.

[Output Signal Description]:
- out: Output signal that is asserted (set to 1) when the FSM is in state D, otherwise it is deasserted (set to 0).

[Design Detail]: 
module topmodule(
    input clk,
    input in,
    input reset,
    output out
);
    
    reg [2:0] state, nextstate;
    parameter A=0, B=1, C=2, D=3;
    
    // State transition logic
    always @(*) begin
        case (state)
            A: nextstate <= in ? B : A;
            B: nextstate <= in ? B : C;
            C: nextstate <= in ? D : A;
            D: nextstate <= in ? B : C;
        endcase
    end

    // State flip-flops with synchronous reset
    always @(posedge clk) begin
        if(reset) begin
            state <= A;
        end else begin
            state <= nextstate;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",Fsm3s.txt,Verilog_Practice\Fsm3s.txt
"[Keyword]: Gates

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit processes a 4-bit input vector to produce three different output vectors. It calculates bitwise operations between adjacent bits of the input vector to generate outputs that represent logical AND, OR, and inequality (XOR-like) operations.

[Input Signal Description]:
in[3:0]: A 4-bit input signal that serves as the source for generating the output signals through bitwise operations.

[Output Signal Description]:
outboth[2:0]: A 3-bit output signal where each bit is the result of a bitwise AND operation between adjacent bits of the input.
outany[3:1]: A 3-bit output signal where each bit is the result of a bitwise OR operation between adjacent bits of the input.
outdifferent[3:0]: A 4-bit output signal where each bit indicates whether adjacent bits of the input are different (similar to XOR operation).

[Design Detail]: 
module topmodule( 
    input [3:0] in,
    output [2:0] outboth,
    output [3:1] outany,
    output [3:0] outdifferent );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 3; i ++) begin
            outboth[i] = in[i] & in[i+1];
            outany[i+1] = in[i] | in[i+1];
            outdifferent[i] = (in[i] != in[i+1]) ? 1:0;
        end
        outdifferent[3] = (in[0] != in[3]) ? 1:0;
    end

endmodule",Gates.txt,Verilog_Practice\Gates.txt
"[Keyword]: Gates100

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a logic circuit that performs bitwise reduction operations on a 100-bit input vector. It calculates the logical AND, OR, and XOR of all bits in the input vector.

[Input Signal Description]:
in[99:0]: A 100-bit wide input signal on which the reduction operations (AND, OR, XOR) are performed.

[Output Signal Description]:
out_and: Outputs the result of the bitwise AND reduction of all bits in the input vector.
out_or: Outputs the result of the bitwise OR reduction of all bits in the input vector.
out_xor: Outputs the result of the bitwise XOR reduction of all bits in the input vector.

[Design Detail]: 
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",Gates100.txt,Verilog_Practice\Gates100.txt
"[Keyword]: Gates4

[Design Category]: Combinational Logic

[Design Function Description]: 
This design implements basic logic operations (AND, OR, XOR) on a 4-bit input vector. It computes the logical AND, OR, and XOR of all four input bits and outputs the results separately.

[Input Signal Description]: 
in[3:0]: A 4-bit input signal where each bit can be independently set to 0 or 1. The bits are used as inputs for the AND, OR, and XOR operations.

[Output Signal Description]: 
out_and: Outputs the result of the logical AND operation on all four input bits.
out_or: Outputs the result of the logical OR operation on all four input bits.
out_xor: Outputs the result of the logical XOR operation on all four input bits.

[Design Detail]: 
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",Gates4.txt,Verilog_Practice\Gates4.txt
"[Keyword]: Gatesv100

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit processes a 100-bit input vector to produce three different output vectors. It calculates bitwise operations between adjacent bits of the input vector to generate the outputs: `outboth` for bitwise AND, `outany` for bitwise OR, and `outdifferent` for detecting differences between adjacent bits.

[Input Signal Description]:
`in[99:0]`: A 100-bit input vector that serves as the source for bitwise operations to generate the outputs.

[Output Signal Description]:
- `outboth[98:0]`: A 99-bit output vector where each bit is the result of a bitwise AND operation between adjacent bits of the input vector.
- `outany[99:1]`: A 99-bit output vector where each bit is the result of a bitwise OR operation between adjacent bits of the input vector.
- `outdifferent[99:0]`: A 100-bit output vector where each bit indicates whether two adjacent bits in the input vector are different (1 if different, 0 if the same).

[Design Detail]: 
```verilog
module topmodule( 
    input [99:0] in,
    output [98:0] outboth,
    output [99:1] outany,
    output [99:0] outdifferent );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            outboth[i] = in[i] & in[i+1];
            outany[i+1] = in[i] | in[i+1];
            outdifferent[i] = (in[i] != in[i+1]) ? 1:0;
        end
        outdifferent[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule
```",Gatesv100.txt,Verilog_Practice\Gatesv100.txt
"[Keyword]: GNDq4i

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a simple constant output generator that always outputs a logic low (0).

[Input Signal Description]:
There are no input signals for this module.

[Output Signal Description]:
out: A single-bit output that is constantly set to 0.

[Design Detail]: 
module topmodule (
    output out
);
    assign out = 1'b0;
endmodule",GNDq4i.txt,Verilog_Practice\GNDq4i.txt
"[Keyword]: Hadd

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 1-bit full adder. It takes two 1-bit binary numbers as inputs and produces a sum and a carry-out as outputs.

[Input Signal Description]:
a: 1-bit input signal representing the first binary number.
b: 1-bit input signal representing the second binary number.

[Output Signal Description]:
cout: 1-bit output signal representing the carry-out of the addition.
sum: 1-bit output signal representing the sum of the two input bits.

[Design Detail]: 
module topmodule( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",Hadd.txt,Verilog_Practice\Hadd.txt
"[Keyword]: Inverter

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple inverter (NOT gate) that outputs the logical negation of the input signal.

[Input Signal Description]:
in: A single-bit input signal that is to be inverted.

[Output Signal Description]:
out: A single-bit output signal that represents the logical NOT of the input signal.

[Design Detail]: 
module top_module( 
    input in, 
    output out 
);
    assign out = ~in;
endmodule",Inverter.txt,Verilog_Practice\Inverter.txt
"[Keyword]: Kmap1

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit implements a NOR gate followed by a NOT gate, effectively creating a 3-input OR gate. The output is high if at least one of the inputs (a, b, or c) is high.

[Input Signal Description]:
a: A single-bit input signal.
b: A single-bit input signal.
c: A single-bit input signal.

[Output Signal Description]:
out: A single-bit output signal that is the logical OR of inputs a, b, and c.

[Design Detail]: 
module topmodule(
    input a,
    input b,
    input c,
    output out
); 
    assign out = ~(~a & ~b & ~c);
endmodule",Kmap1.txt,Verilog_Practice\Kmap1.txt
"[Keyword]: Kmap2

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit implements a specific combinational logic function using a combination of AND, OR, and NOT gates. The function is defined by the given logical expression, which combines the inputs a, b, c, and d to produce the output.

[Input Signal Description]:
a, b, c, d: These are the 1-bit input signals to the circuit. Each input can be either 0 or 1, and they are used in various combinations to determine the output based on the specified logic expression.

[Output Signal Description]:
out: This is the 1-bit output signal of the circuit. The output is determined by evaluating the logical expression provided, which combines the input signals using AND, OR, and NOT operations.

[Design Detail]: 
module topmodule(
    input a,
    input b,
    input c,
    input d,
    output out
); 
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);
endmodule",Kmap2.txt,Verilog_Practice\Kmap2.txt
"[Keyword]: Kmap3

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit implements a specific logic function using a combination of AND, OR, and NOT gates. The output is determined by the logical expression: (~b & c) | (a & c) | (a & ~c).

[Input Signal Description]:
- a: A single-bit input signal.
- b: A single-bit input signal.
- c: A single-bit input signal.
- d: A single-bit input signal (not used in the logic expression).

[Output Signal Description]:
- out: A single-bit output signal that is the result of the logical expression applied to the inputs a, b, and c.

[Design Detail]: 
module topmodule(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",Kmap3.txt,Verilog_Practice\Kmap3.txt
"[Keyword]: Kmap4

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a combinational logic circuit that outputs a specific logic function based on the inputs a, b, c, and d. The function is a sum of products (SOP) form, which is a common way to express logic functions.

[Input Signal Description]:
- a: A single-bit input signal.
- b: A single-bit input signal.
- c: A single-bit input signal.
- d: A single-bit input signal.

These inputs are used to evaluate the logic expression and determine the output.

[Output Signal Description]:
- out: A single-bit output signal that represents the result of the logic function based on the given inputs a, b, c, and d.

[Design Detail]: 
```verilog
module topmodule(
    input a,
    input b,
    input c,
    input d,
    output out
); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) | (a&b&~c&d) | (~a&b&c&d) | (a&~b&c&d) | (~a&~b&c&~d) | (a&b&c&~d);

endmodule
```",Kmap4.txt,Verilog_Practice\Kmap4.txt
"[Keyword]: Lemmings1

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple finite state machine (FSM) that controls the direction of movement for an entity, such as a Lemming. The entity can walk either left or right, and its direction can change based on bump signals. The FSM has two states: LEFT and RIGHT. The entity starts walking left upon reset and changes direction when it encounters a bump.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the state to LEFT, indicating the entity should start walking left.
- `bumpleft`: Signal indicating a bump encountered while walking left, prompting a change in direction to right.
- `bumpright`: Signal indicating a bump encountered while walking right, prompting a change in direction to left.

[Output Signal Description]:
- `walkleft`: Output signal that is high when the entity is in the LEFT state, indicating it is walking left.
- `walkright`: Output signal that is high when the entity is in the RIGHT state, indicating it is walking right.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bumpleft,
    input bumpright,
    output walkleft,
    output walkright); //  

    // parameter LEFT=0, RIGHT=1, ...
    parameter LEFT = 0, RIGHT = 1;
    reg state, nextstate;

    always @(*) begin
        // State transition logic
        case (state)
            LEFT: nextstate <= bumpleft ? RIGHT : LEFT;
            RIGHT: nextstate <= bumpright ? LEFT : RIGHT;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
        if (areset) begin
            state <= LEFT;
        end
        else begin
            state <= nextstate;
        end
    end

    // Output logic
    // assign walkleft = (state == ...);
    // assign walkright = (state == ...);
    assign walkleft = (state == LEFT);
    assign walkright = (state == RIGHT);

endmodule
```",Lemmings1.txt,Verilog_Practice\Lemmings1.txt
"[Keyword]: Lemmings2

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) to control the movement of a character (Lemming) that can walk left or right and react to falling off the ground. The FSM has four states: walking left, walking right, falling while facing left, and falling while facing right. The character changes direction upon bumping into an obstacle and transitions to a falling state when not on the ground.

[Input Signal Description]:
- `clk`: Clock signal to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the state to walking left.
- `bumpleft`: Signal indicating the character has bumped into an obstacle while walking left.
- `bumpright`: Signal indicating the character has bumped into an obstacle while walking right.
- `ground`: Signal indicating whether the character is on the ground.

[Output Signal Description]:
- `walkleft`: Signal indicating the character is currently walking left.
- `walkright`: Signal indicating the character is currently walking right.
- `aaah`: Signal indicating the character is falling (in either the left or right direction).

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bumpleft,
    input bumpright,
    input ground,
    output walkleft,
    output walkright,
    output aaah ); 

    parameter LEFT = 0, RIGHT = 1, LEFTaah = 2, RIGHTaah = 3;
    reg [2:0] state, nextstate;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= LEFT;
        end
        else begin
            state <= nextstate;
        end
    end

    always @(*) begin
        case (state)
            LEFT: begin
                if (ground) begin
                    nextstate <= bumpleft ? RIGHT : LEFT;
                end
                else begin
                    nextstate <= LEFTaah;
                end
            end
            RIGHT: begin
                if (ground) begin
                    nextstate <= bumpright ? LEFT : RIGHT;
                end
                else begin
                    nextstate <= RIGHTaah;
                end
            end
            LEFTaah: begin
                if (ground) begin
                    nextstate <= LEFT;
                end
                else begin
                    nextstate <= LEFTaah;
                end
            end
            RIGHTaah: begin
                if (ground) begin
                    nextstate <= RIGHT;
                end
                else begin
                    nextstate <= RIGHTaah;
                end
            end
        endcase
    end

    assign walkleft = (state == LEFT);
    assign walkright = (state == RIGHT);
    assign aaah = ((state == LEFTaah) || (state == RIGHTaah));

endmodule
```",Lemmings2.txt,Verilog_Practice\Lemmings2.txt
"[Keyword]: Lemmings3

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) to control the behavior of a Lemming character in a game-like scenario. The Lemming can walk left or right, dig, or fall off the ground, and the FSM manages these states based on input signals such as ground presence, bumping into walls, and digging commands.

[Input Signal Description]:
- `clk`: Clock signal to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the Lemming to walk left.
- `bumpleft`: Signal indicating the Lemming has bumped into a wall on the left.
- `bumpright`: Signal indicating the Lemming has bumped into a wall on the right.
- `ground`: Signal indicating whether the Lemming is on the ground.
- `dig`: Signal indicating the Lemming should start digging.

[Output Signal Description]:
- `walkleft`: Signal indicating the Lemming is walking left.
- `walkright`: Signal indicating the Lemming is walking right.
- `aaah`: Signal indicating the Lemming is falling (not on the ground).
- `digging`: Signal indicating the Lemming is currently digging.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bumpleft,
    input bumpright,
    input ground,
    input dig,
    output walkleft,
    output walkright,
    output aaah,
    output digging ); 

    parameter left = 0, right = 1;
    parameter leftground = 2, rightground = 3;
    parameter leftdig = 4, rightdig = 5;

    reg [2:0] state, nextstate;

    always @(posedge clk or posedge areset) begin
        if (areset) begin
            state <= left;
        end
        else begin
            state <= nextstate;
        end
    end

    always @(*) begin
        case (state)
            left: begin
                if (ground) begin
                    if (dig) begin
                        nextstate <= leftdig;
                    end
                    else begin
                        nextstate <= bumpleft ? right : left;
                    end
                end
                else begin
                    nextstate <= leftground;
                end
            end
            right: begin
                if (ground) begin
                    if (dig) begin
                        nextstate <= rightdig;
                    end
                    else begin
                        nextstate <= bumpright ? left : right;
                    end
                end
                else begin
                    nextstate <= rightground;
                end
            end
            leftdig: begin
                if (ground) begin
                    nextstate <= leftdig;
                end
                else begin
                    nextstate <= leftground;
                end
            end
            rightdig: begin
                if (ground) begin
                    nextstate <= rightdig;
                end
                else begin
                    nextstate <= rightground;
                end
            end
            leftground: begin
                if (ground) begin
                    nextstate <= left;
                end
                else begin
                    nextstate <= leftground;
                end
            end
            rightground: begin
                if (ground) begin
                    nextstate <= right;
                end
                else begin
                    nextstate <= rightground;
                end
            end
        endcase
    end

    assign walkleft = (state == left);
    assign walkright = (state == right);
    assign aaah = ((state == leftground) || (state == rightground));
    assign digging = ((state == leftdig) || (state == rightdig));

endmodule
```",Lemmings3.txt,Verilog_Practice\Lemmings3.txt
"[Keyword]: Lemmings4

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a finite state machine (FSM) to control the behavior of a character (Lemming) in a simulation. The Lemming can walk left or right, fall, dig, or splat based on various input conditions such as ground presence, bumping into walls, and digging commands.

[Input Signal Description]:
- `clk`: Clock signal to synchronize state transitions.
- `areset`: Asynchronous reset signal that initializes the Lemming to walk left.
- `bumpleft`: Signal indicating the Lemming has bumped into a wall on the left.
- `bumpright`: Signal indicating the Lemming has bumped into a wall on the right.
- `ground`: Signal indicating whether the Lemming is on the ground.
- `dig`: Command signal to start digging.

[Output Signal Description]:
- `walkleft`: Signal indicating the Lemming is walking left.
- `walkright`: Signal indicating the Lemming is walking right.
- `aaah`: Signal indicating the Lemming is falling.
- `digging`: Signal indicating the Lemming is digging.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bumpleft,
    input bumpright,
    input ground,
    input dig,
    output walkleft,
    output walkright,
    output aaah,
    output digging ); 

    parameter left=3'd0, right=3'd1, falll=3'd2, fallr=3'd3, digl=3'd4, digr=3'd5, splat=3'd6;
    reg [2:0] state, nextstate;
    reg [31:0] count;

    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= left;
        else if(state == falll || state == fallr) begin
            state <= nextstate;
            count <= count + 1;
        end
        else begin
            state <= nextstate;
            count <= 0;
        end
    end

    always@(*) begin
        case(state)
            left: begin
                if(~ground)         nextstate = falll;
                else if(dig)        nextstate = digl;
                else if(bumpleft)  nextstate = right;
                else                nextstate = left;
            end
            right: begin
                if(~ground)         nextstate = fallr;
                else if(dig)        nextstate = digr;
                else if(bumpright) nextstate = left;
                else                nextstate = right;
            end
            falll: begin
                if(ground) begin
                    if(count>19)    nextstate = splat;
                    else            nextstate = left;
                end
                else                nextstate = falll;
            end
            fallr: begin
                if(ground) begin
                    if(count>19)    nextstate = splat;
                    else            nextstate = right;
                end
                else                nextstate = fallr;
            end
            digl: begin
                if(ground)  nextstate = digl;
                else        nextstate = falll;
            end
            digr: begin
                if(ground)  nextstate = digr;
                else        nextstate = fallr;
            end
            splat: begin
                nextstate = splat;
            end
        endcase
    end

    assign  walkleft = (state == left);
    assign  walkright = (state == right);
    assign  aaah = (state == falll || state == fallr);
    assign  digging = (state == digl || state == digr);

endmodule
```",Lemmings4.txt,Verilog_Practice\Lemmings4.txt
"[Keyword]: Lfsr32

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 32-bit Linear Feedback Shift Register (LFSR) with a specific feedback polynomial. The LFSR is used to generate pseudo-random sequences. The register is initialized to 32'h1 upon a reset signal.

[Input Signal Description]:
- clk: Clock signal that triggers the LFSR to shift and update its state on each rising edge.
- reset: Active-high synchronous reset signal that initializes the LFSR to 32'h1 when asserted.

[Output Signal Description]:
- q[31:0]: The 32-bit output of the LFSR, representing the current state of the register.

[Design Detail]: 
module topmodule(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",Lfsr32.txt,Verilog_Practice\Lfsr32.txt
"[Keyword]: Lfsr5

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 5-bit Linear Feedback Shift Register (LFSR) with a specific feedback polynomial. The LFSR generates a pseudo-random sequence of bits. The register is reset to a specific value (5'h1) when the reset signal is active.

[Input Signal Description]:
clk: Clock signal that triggers the LFSR to shift and update its state on the rising edge.
reset: Active-high synchronous reset signal that initializes the LFSR to the value 5'h1.

[Output Signal Description]:
q[4:0]: 5-bit output representing the current state of the LFSR, which changes with each clock cycle based on the feedback logic.

[Design Detail]: 
module topmodule(
    input clk,
    input reset,    // Active-high synchronous reset to 5'h1
    output [4:0] q
); 

    always @(posedge clk) begin
        if(reset) begin
            q <= 5'h1;
        end
        else begin
            q <= {0 ^ q[0], q[4], q[3] ^ q[0], q[2], q[1]};
        end
    end
    
endmodule",Lfsr5.txt,Verilog_Practice\Lfsr5.txt
"[Keyword]: m2014 q3

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a specific logic function using a combination of AND, OR, and NOT gates. The function is defined by a specific Boolean expression that takes a 4-bit input and produces a single output.

[Input Signal Description]:
x[4:1]: A 4-bit input signal where each bit (x[1], x[2], x[3], x[4]) can be either 0 or 1. These bits are used in the logic expression to determine the output.

[Output Signal Description]:
f: A single-bit output signal that is the result of the logic operation defined by the given Boolean expression. It represents the negation of a combination of conditions applied to the input bits.

[Design Detail]: 
module topmodule (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",m2014 q3.txt,Verilog_Practice\m2014 q3.txt
"[Keyword]: m2014 q4a

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple latch that captures and holds the value of the input signal 'd' when the enable signal 'ena' is high. The output 'q' reflects the input 'd' when enabled.

[Input Signal Description]:
d: A single-bit data input signal that is captured by the latch.
ena: A single-bit enable signal that controls when the input 'd' is captured and transferred to the output 'q'.

[Output Signal Description]:
q: A single-bit output signal that holds the value of the input 'd' when the enable signal 'ena' is high.

[Design Detail]: 
module topmodule (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",m2014 q4a.txt,Verilog_Practice\m2014 q4a.txt
"[Keyword]: m2014 q4b

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a D flip-flop with an asynchronous reset. It captures the value of the input 'd' on the rising edge of the clock 'clk' and outputs it on 'q'. If the asynchronous reset 'ar' is asserted, the output 'q' is immediately reset to 0, regardless of the clock.

[Input Signal Description]:
- clk: Clock signal used to synchronize the data capture.
- d: Data input signal that is captured on the rising edge of the clock.
- ar: Asynchronous reset signal that, when high, resets the output 'q' to 0 immediately.

[Output Signal Description]:
- q: The output signal that holds the value of the input 'd' after being captured on the rising edge of the clock, or 0 if the asynchronous reset is active.

[Design Detail]: 
module topmodule (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",m2014 q4b.txt,Verilog_Practice\m2014 q4b.txt
"[Keyword]: m2014 q4c

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a D flip-flop with a synchronous reset. The flip-flop captures the value of the input 'd' on the rising edge of the clock 'clk' and outputs it as 'q'. If the reset 'r' is asserted during the clock edge, the output 'q' is reset to 0.

[Input Signal Description]:
- clk: Clock signal that triggers the flip-flop on its rising edge.
- d: Data input signal that is captured by the flip-flop on the rising edge of the clock.
- r: Synchronous reset signal that, when high, resets the output 'q' to 0 on the rising edge of the clock.

[Output Signal Description]:
- q: The output signal that holds the value of the input 'd' after the rising edge of the clock, unless the reset 'r' is asserted, in which case it is set to 0.

[Design Detail]: 
module topmodule (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",m2014 q4c.txt,Verilog_Practice\m2014 q4c.txt
"[Keyword]: m2014 q4d

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a simple sequential circuit that performs a bitwise XOR operation between the current output and the input signal on every rising edge of the clock. It effectively toggles the output bit based on the input signal.

[Input Signal Description]:
clk: Clock signal that triggers the operation on its rising edge.
in: Input signal that is XORed with the current output to determine the next state of the output.

[Output Signal Description]:
out: The output signal that holds the result of the XOR operation between the previous output and the input signal. It is updated on each rising edge of the clock.

[Design Detail]: 
module topmodule (
    input clk,
    input in, 
    output reg out
);
    
    always @(posedge clk) begin
        out <= out ^ in;
    end

endmodule",m2014 q4d.txt,Verilog_Practice\m2014 q4d.txt
"[Keyword]: m2014 q4j

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 4-bit binary adder. It takes two 4-bit binary numbers as inputs and produces a 5-bit sum as output. The additional bit in the output is used to accommodate any carry that results from the addition of the two 4-bit numbers.

[Input Signal Description]:
x[3:0]: A 4-bit input signal representing the first binary number to be added.
y[3:0]: A 4-bit input signal representing the second binary number to be added.

[Output Signal Description]:
sum[4:0]: A 5-bit output signal representing the sum of the two 4-bit input numbers. The least significant 4 bits represent the sum, and the most significant bit represents the carry-out from the addition.

[Design Detail]: 
module topmodule (
    input [3:0] x,
    input [3:0] y, 
    output [4:0] sum
);
    
    integer i;
    wire [3:0] cout;
    assign sum[0] = x[0] ^ y[0];
    assign cout[0] = x[0] & y[0];
    always @(*) begin
        for(i = 1; i < 4; i=i+1) begin
            sum[i] = x[i] ^ y[i] ^ cout[i-1];
            cout[i] = x[i] & y[i] | x[i] & cout[i-1] | y[i] & cout[i-1];
        end
        sum[4] = cout[3];
    end

endmodule",m2014 q4j.txt,Verilog_Practice\m2014 q4j.txt
"[Keyword]: m2014 q6

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with six states (a, b, c, d, e, f). The FSM transitions between states based on the input signal `w` and outputs a signal `z` that is high when the FSM is in states `e` or `f`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `reset`: Synchronous reset signal that initializes the FSM to state `a` when high.
- `w`: Input signal that influences state transitions within the FSM.

[Output Signal Description]:
- `z`: Output signal that is high when the FSM is in state `e` or `f`, and low otherwise.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,     // synchronous reset
    input w,
    output z);

    parameter a=3'b000, b=3'b001, c=3'b010, d=3'b011, e=3'b100, f=3'b101;
    reg [2:0] state, nextstate;
    
    always@(*) begin
        case({state, w})
            {a, 1'b0}:  nextstate = b;
            {a, 1'b1}:  nextstate = a;
            {b, 1'b0}:  nextstate = c;
            {b, 1'b1}:  nextstate = d;
            {c, 1'b0}:  nextstate = e;
            {c, 1'b1}:  nextstate = d;
            {d, 1'b0}:  nextstate = f;
            {d, 1'b1}:  nextstate = a;
            {e, 1'b0}:  nextstate = e;
            {e, 1'b1}:  nextstate = d;
            {f, 1'b0}:  nextstate = c;
            {f, 1'b1}:  nextstate = d;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= nextstate;
    end
    
    assign z = (state == e || state == f);
    
endmodule
```",m2014 q6.txt,Verilog_Practice\m2014 q6.txt
"[Keyword]: m2014 q6b

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a state machine with six states (A, B, C, D, E, F) represented by a 3-bit register Y. The state transitions are determined by the current state (y) and an input signal (w). The output Y2 is the second bit of the current state, which can be used to determine the state of the machine.

[Input Signal Description]:
- y[3:1]: A 3-bit input signal representing the current state of the state machine.
- w: A 1-bit input signal that influences the state transitions.

[Output Signal Description]:
- Y2: A 1-bit output signal representing the second bit of the current state, which can be used to identify the state of the machine.

[Design Detail]: 
```verilog
module topmodule (
    input [3:1] y,
    input w,
    output Y2);

    reg [3:1] Y;
    // A000 B001 C010 D011 E100 F101
    always @(*) begin
        case({y, w})
            4'b0000: Y = 3'b001;
            4'b0001: Y = 3'b000;
            4'b0010: Y = 3'b010;
            4'b0011: Y = 3'b011;
            4'b0100: Y = 3'b100;
            4'b0101: Y = 3'b011;
            4'b0110: Y = 3'b101;
            4'b0111: Y = 3'b000;
            4'b1000: Y = 3'b100;
            4'b1001: Y = 3'b011;
            4'b1010: Y = 3'b010;
            4'b1011: Y = 3'b011;
        endcase
    end
    
    assign Y2 = Y[2];

endmodule
```",m2014 q6b.txt,Verilog_Practice\m2014 q6b.txt
"[Keyword]: m2014 q6c

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a combinational logic circuit that computes two specific output signals, Y2 and Y4, based on the input signals. It uses logical operations to determine the values of these outputs.

[Input Signal Description]:
- y[6:1]: A 6-bit input vector where each bit can be used in logical operations to determine the output.
- w: A single-bit input signal that influences the logic for determining the outputs Y2 and Y4.

[Output Signal Description]:
- Y2: The output is the result of a logical AND operation between the first bit of the input vector y and the negation of the input w.
- Y4: The output is the result of a logical OR operation among several AND operations involving bits 2, 3, 5, and 6 of the input vector y, all ANDed with the input w.

[Design Detail]: 
module topmodule (
    input [6:1] y,
    input w,
    output Y2,
    output Y4
);

    assign Y2 = y[1] & (~w);
    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);

endmodule",m2014 q6c.txt,Verilog_Practice\m2014 q6c.txt
"[Keyword]: Module

[Design Category]: Combinational Logic

[Design Function Description]:
This design instantiates a module named `mod_a` which takes two inputs and produces an output. The specific function of `mod_a` is not detailed in the provided code, but it likely performs a combinational logic operation on the inputs `a` and `b`.

[Input Signal Description]:
a: A single-bit input signal.
b: A single-bit input signal.

[Output Signal Description]:
out: A single-bit output signal that is the result of the operation performed by the `mod_a` module on inputs `a` and `b`.

[Design Detail]: 
module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",Module.txt,Verilog_Practice\Module.txt
"[Keyword]: Moduleadd

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 32-bit adder using two 16-bit adders. It takes two 32-bit input numbers and produces their 32-bit sum. The addition is performed in two stages: the lower 16 bits are added first, and the carry-out from this addition is used as the carry-in for the addition of the upper 16 bits.

[Input Signal Description]:
a[31:0]: A 32-bit input operand for the addition.
b[31:0]: Another 32-bit input operand for the addition.

[Output Signal Description]:
sum[31:0]: The 32-bit result of the addition of inputs 'a' and 'b'.

[Design Detail]: 
module topmodule(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",Moduleadd.txt,Verilog_Practice\Moduleadd.txt
"[Keyword]: Moduleaddsub

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 32-bit adder/subtractor. It can perform addition or subtraction based on the control signal `sub`. When `sub` is high, the circuit performs subtraction by inverting the second operand `b` and adding 1 (using the carry-in). When `sub` is low, it performs addition.

[Input Signal Description]:
- `a[31:0]`: A 32-bit input operand.
- `b[31:0]`: A 32-bit input operand that can be inverted for subtraction.
- `sub`: A control signal that determines whether the operation is addition (0) or subtraction (1).

[Output Signal Description]:
- `sum[31:0]`: The 32-bit result of the addition or subtraction operation.

[Design Detail]: 
```verilog
module topmodule(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] bxor;
    
    always @(*) begin
        if(sub)
            bxor = ~b;
        else
            bxor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(bxor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(bxor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule
```",Moduleaddsub.txt,Verilog_Practice\Moduleaddsub.txt
"[Keyword]: Modulecseladd

[Design Category]: Arithmetic Circuits

[Design Function Description]:
This design implements a 32-bit adder using three 16-bit adders. It adds two 32-bit numbers, `a` and `b`, and produces a 32-bit sum. The design uses two different carry-in scenarios for the upper 16 bits to handle the carry from the lower 16 bits.

[Input Signal Description]:
- `a[31:0]`: A 32-bit input operand for the addition.
- `b[31:0]`: Another 32-bit input operand for the addition.

[Output Signal Description]:
- `sum[31:0]`: The 32-bit result of the addition of `a` and `b`.

[Design Detail]: 
```verilog
module topmodule(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sumh;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sumh = sum2;
            1 : sumh = sum3;
        endcase
    end
    
    assign sum = {sumh, sum1};
    
endmodule
```",Modulecseladd.txt,Verilog_Practice\Modulecseladd.txt
"[Keyword]: Modulefadd

[Design Category]: Arithmetic Circuits

[Design Function Description]:
The design implements a 32-bit ripple-carry adder using two 16-bit adders. It takes two 32-bit input numbers and produces their 32-bit sum. The addition is performed in two stages: the lower 16 bits are added first, and the carry-out from this addition is used as the carry-in for the addition of the upper 16 bits.

[Input Signal Description]:
- a[31:0]: A 32-bit input operand for the addition.
- b[31:0]: Another 32-bit input operand for the addition.

[Output Signal Description]:
- sum[31:0]: The 32-bit result of the addition of inputs `a` and `b`.

[Design Detail]: 
```verilog
module topmodule (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule
```",Modulefadd.txt,Verilog_Practice\Modulefadd.txt
"[Keyword]: Modulename

[Design Category]: Combinational Logic

[Design Function Description]:
The module 'topmodule' instantiates another module 'moda' which takes four input signals and produces two output signals. The specific function of 'moda' is not provided, but it likely performs a combinational logic operation based on the inputs.

[Input Signal Description]:
a, b, c, d: These are individual input signals to the 'topmodule', which are passed to the 'moda' instance. The specific role of each input depends on the internal logic of 'moda'.

[Output Signal Description]:
out1, out2: These are the output signals from the 'moda' instance, which are also the outputs of the 'topmodule'. Their values depend on the logic implemented within 'moda'.

[Design Detail]: 
module topmodule ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    moda instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",Modulename.txt,Verilog_Practice\Modulename.txt
"[Keyword]: Modulepos

[Design Category]: Combinational Logic

[Design Function Description]:
The module `topmodule` instantiates another module `moda` which takes four inputs and produces two outputs. The specific function of `moda` is not detailed in the provided code, but it likely performs a combinational logic operation on the inputs `a`, `b`, `c`, and `d` to produce the outputs `out1` and `out2`.

[Input Signal Description]:
- `a`: A single-bit input signal.
- `b`: A single-bit input signal.
- `c`: A single-bit input signal.
- `d`: A single-bit input signal.

These inputs are likely used by the `moda` module to perform some logic operations.

[Output Signal Description]:
- `out1`: A single-bit output signal produced by the `moda` module.
- `out2`: A single-bit output signal produced by the `moda` module.

The outputs are the result of the logic operations performed by `moda` on the inputs.

[Design Detail]: 
```verilog
module topmodule ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    moda instance1(out1, out2, a, b, c, d);
endmodule
```
Note: The specific functionality of `moda` is not provided, so the exact operations on the inputs to produce the outputs are unknown.",Modulepos.txt,Verilog_Practice\Modulepos.txt
"[Keyword]: Moduleshift

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 3-stage shift register using D flip-flops. The input data is shifted through three stages of flip-flops on each clock cycle, resulting in a delayed version of the input signal at the output.

[Input Signal Description]:
clk: Clock signal that synchronizes the data shifting process.
d: Input data signal to be shifted through the register.

[Output Signal Description]:
q: Output signal representing the data after it has been shifted through all three stages of the shift register.

[Design Detail]: 
module topmodule ( 
  input clk, 
  input d, 
  output q 
);
    wire q1, q2;
    mydff instance1(.clk(clk), .d(d), .q(q1));
    mydff instance2(.clk(clk), .d(q1), .q(q2));
    mydff instance3(.clk(clk), .d(q2), .q(q));
endmodule",Moduleshift.txt,Verilog_Practice\Moduleshift.txt
"[Keyword]: Moduleshift8v

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a shift register with three stages, each stage being an 8-bit D flip-flop. The output `q` can be selected from the input `d` or from the output of any of the three stages using a 2-bit selection signal `sel`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the flip-flops.
- `d[7:0]`: 8-bit input data signal that is fed into the first stage of the shift register.
- `sel[1:0]`: 2-bit selection signal used to choose which stage's output is assigned to the output `q`.

[Output Signal Description]:
- `q[7:0]`: 8-bit output signal that reflects the selected data from the input or one of the three stages of the shift register based on the `sel` signal.

[Design Detail]: 
```verilog
module topmodule ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    mydff8 instance1(.clk(clk), .d(d), .q(q1));
    mydff8 instance2(.clk(clk), .d(q1), .q(q2));
    mydff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule
```",Moduleshift8v.txt,Verilog_Practice\Moduleshift8v.txt
"[Keyword]: Mt2015 eq2

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 2-bit equality comparator. It compares two 2-bit input vectors, A and B, and outputs a high signal (1) if they are equal, otherwise, it outputs a low signal (0).

[Input Signal Description]:
A[1:0]: A 2-bit input signal representing the first operand for comparison.
B[1:0]: A 2-bit input signal representing the second operand for comparison.

[Output Signal Description]:
z: A single-bit output signal that is set to 1 if the inputs A and B are equal, otherwise set to 0.

[Design Detail]: 
module topmodule ( 
  input [1:0] A, 
  input [1:0] B, 
  output z 
); 
  always @(*) begin
    if(A == B)
      z = 1;
    else
      z = 0;
  end
endmodule",Mt2015 eq2.txt,Verilog_Practice\Mt2015 eq2.txt
"[Keyword]: Mt2015 lfsr

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 3-bit shift register with parallel load capability. The register can either load new data from the input or shift its current contents based on the control signals.

[Input Signal Description]:
- SW[2:0]: A 3-bit input signal representing the data to be loaded into the register when the load signal is active.
- KEY[1:0]: A 2-bit input signal where KEY[0] is the clock signal and KEY[1] is the load signal. The load signal determines whether the register loads new data or shifts its current contents.

[Output Signal Description]:
- LEDR[2:0]: A 3-bit output signal representing the current state of the register.

[Design Detail]: 
```verilog
module topmodule (
    input [2:0] SW,      // R
    input [1:0] KEY,     // L and clk
    output [2:0] LEDR);  // Q
    
    wire clk, L;
    wire [2:0] R;
    reg [2:0] Q;
    assign clk = KEY[0];
    assign L = KEY[1];
    assign R = SW;

    always @(posedge clk) begin
        Q <= {(L) ? R[2] : (Q[1] ^ Q[2]), (L) ? R[1] : Q[0], (L) ? R[0] : Q[2]};
    end
    
    assign LEDR = Q;

endmodule
```",Mt2015 lfsr.txt,Verilog_Practice\Mt2015 lfsr.txt
"[Keyword]: Mt2015 q4

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit implements a combination of two tasks, A and B, which perform specific logical operations on the inputs x and y. The results of these tasks are stored in a temporary wire array ztmp. The final output z is derived from a combination of these intermediate results using bitwise operations.

[Input Signal Description]:
x: A single-bit input signal.
y: A single-bit input signal.

[Output Signal Description]:
z: A single-bit output signal that results from a combination of the outputs of tasks A and B, processed through additional bitwise operations.

[Design Detail]: 
module topmodule (input x, input y, output z);
    wire [3:0] ztmp;
    
    task A;
        input x,y;
        output z;
        begin
            z = (x ^ y) & x;
        end
    endtask
    
    task B;
        input x,y;
        output z;
        begin
            if(x == y)
                z = 1;
            else
                z = 0;
        end
    endtask
    
    always @(*) begin
        A(x,y,ztmp[0]);
        B(x,y,ztmp[1]);
        A(x,y,ztmp[2]);
        B(x,y,ztmp[3]);
    end
    
    assign z = (ztmp[0] | ztmp[1]) ^ (ztmp[2] & ztmp[3]);
    
endmodule",Mt2015 q4.txt,Verilog_Practice\Mt2015 q4.txt
"[Keyword]: Mt2015 q4a

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit implements a simple combinational logic function that performs a bitwise XOR operation between two input signals, x and y, and then performs a bitwise AND operation with the result and the input signal x.

[Input Signal Description]:
x: A single-bit input signal.
y: A single-bit input signal.

[Output Signal Description]:
z: A single-bit output signal that results from the XOR operation between x and y, followed by an AND operation with x.

[Design Detail]: 
module topmodule (
  input x,
  input y,
  output z
);
   assign z = (x ^ y) & x;
endmodule",Mt2015 q4a.txt,Verilog_Practice\Mt2015 q4a.txt
"[Keyword]: Mt2015 q4bv

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple equality comparator. It compares two input signals, x and y, and outputs a high signal (1) if they are equal, otherwise it outputs a low signal (0).

[Input Signal Description]:
x: A single-bit input signal.
y: A single-bit input signal.

[Output Signal Description]:
z: A single-bit output signal that is set to 1 if x and y are equal, otherwise it is set to 0.

[Design Detail]: 
module topmodule ( 
  input x, 
  input y, 
  output reg z 
);
  always @(*) begin
    if(x == y)
      z = 1;
    else
      z = 0;
  end
endmodule",Mt2015 q4bv.txt,Verilog_Practice\Mt2015 q4bv.txt
"[Keyword]: Mux256to1

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 256-to-1 multiplexer. It selects one bit from a 256-bit input vector based on an 8-bit selection signal. The selected bit is then output.

[Input Signal Description]:
- in[255:0]: A 256-bit wide input vector containing the data from which a single bit will be selected.
- sel[7:0]: An 8-bit selection signal that determines which bit from the input vector is output. It can represent values from 0 to 255.

[Output Signal Description]:
- out: A single bit output that corresponds to the bit selected from the input vector based on the value of the selection signal.

[Design Detail]: 
module topmodule( 
    input [255:0] in,
    input [7:0] sel,
    output out 
);
    assign out = in[sel];
endmodule",Mux256to1.txt,Verilog_Practice\Mux256to1.txt
"[Keyword]: Mux256to1v

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 256-to-1 multiplexer for 4-bit wide data. The 256 4-bit inputs are packed into a single 1024-bit input vector. The 8-bit selection signal determines which 4-bit segment of the input vector is routed to the output.

[Input Signal Description]:
in[1023:0]: A 1024-bit input signal containing 256 4-bit wide data segments.
sel[7:0]: An 8-bit selection signal that determines which 4-bit segment of the input is selected (can represent values from 0 to 255).

[Output Signal Description]:
out[3:0]: A 4-bit output signal that corresponds to the selected 4-bit segment from the input vector based on the value of the selection signal.

[Design Detail]: 
module topmodule( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",Mux256to1v.txt,Verilog_Practice\Mux256to1v.txt
"[Keyword]: Mux2to1

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 2-to-1 multiplexer. It selects one of the two input signals, `a` or `b`, based on the value of the selection signal `sel`.

[Input Signal Description]:
- `a`: One of the input signals to the multiplexer.
- `b`: The other input signal to the multiplexer.
- `sel`: A selection signal that determines which input signal is passed to the output. If `sel` is 1, `b` is selected; if `sel` is 0, `a` is selected.

[Output Signal Description]:
- `out`: The output signal of the multiplexer, which is either `a` or `b` depending on the value of `sel`.

[Design Detail]: 
module topmodule( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",Mux2to1.txt,Verilog_Practice\Mux2to1.txt
"[Keyword]: Mux2to1v

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 100-bit wide 2-to-1 multiplexer. It selects between two 100-bit input vectors, `a` and `b`, based on the value of the selection signal `sel`. If `sel` is 1, the output `out` will be equal to `b`; if `sel` is 0, the output `out` will be equal to `a`.

[Input Signal Description]:
- `a[99:0]`: A 100-bit input vector.
- `b[99:0]`: Another 100-bit input vector.
- `sel`: A 1-bit selection signal that determines which input vector is passed to the output.

[Output Signal Description]:
- `out[99:0]`: A 100-bit output vector that is equal to either `a` or `b`, depending on the value of the selection signal `sel`.

[Design Detail]: 
```verilog
module topmodule( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule
```",Mux2to1v.txt,Verilog_Practice\Mux2to1v.txt
"[Keyword]: Mux9to1v

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 16-bit wide, 9-to-1 multiplexer. It selects one of the nine 16-bit input signals (a, b, c, d, e, f, g, h, i) based on a 4-bit selection signal (sel). If the selection signal is outside the range of 0 to 8, the output defaults to 16'hffff.

[Input Signal Description]:
- a, b, c, d, e, f, g, h, i: Each is a 16-bit input signal.
- sel[3:0]: A 4-bit selection signal that determines which input signal is routed to the output. It can represent values from 0 to 8.

[Output Signal Description]:
- out[15:0]: A 16-bit output signal that reflects the value of the selected input signal based on the sel value. If sel is outside the range of 0 to 8, the output is set to 16'hffff.

[Design Detail]: 
module topmodule( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule",Mux9to1v.txt,Verilog_Practice\Mux9to1v.txt
"[Keyword]: muxdff

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple D-type flip-flop with a load-enable feature. It captures the input data based on the clock edge and the load signal. If the load signal (L) is high, the flip-flop captures the data from the `rin` input; otherwise, it captures the data from the `qin` input.

[Input Signal Description]:
- `clk`: Clock signal that triggers the data capture on its rising edge.
- `L`: Load-enable signal that determines which input data to capture.
- `rin`: Data input that is captured when the load-enable signal (L) is high.
- `qin`: Data input that is captured when the load-enable signal (L) is low.

[Output Signal Description]:
- `Q`: The output of the flip-flop, which holds the captured data based on the clock and load-enable conditions.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input L,
    input rin,
    input qin,
    output reg Q);
    
    always @(posedge clk) begin
        Q <= L ? rin : qin;
    end

endmodule
```",muxdff.txt,Verilog_Practice\muxdff.txt
"[Keyword]: Norgate

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a NOR gate, which outputs the logical NOR of two input signals. The output is true only when both inputs are false.

[Input Signal Description]:
a: A single-bit input signal.
b: A single-bit input signal.

[Output Signal Description]:
out: A single-bit output signal that represents the NOR of inputs a and b. It is true (1) only when both a and b are false (0).

[Design Detail]: 
module top_module( 
    input a, 
    input b, 
    output out 
);
    assign out = ~(a | b);
endmodule",Norgate.txt,Verilog_Practice\Norgate.txt
"[Keyword]: NORq4e

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a NOR gate, which is a digital logic gate that outputs true or high only when both inputs are false or low.

[Input Signal Description]:
in1: A single-bit input signal.
in2: A single-bit input signal.

[Output Signal Description]:
out: A single-bit output signal that is the NOR of the inputs in1 and in2. It outputs high when both in1 and in2 are low.

[Design Detail]: 
module topmodule (
    input in1,
    input in2,
    output out
);
    assign out = ~(in1 | in2);
endmodule",NORq4e.txt,Verilog_Practice\NORq4e.txt
"[Keyword]: Popcount255

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit counts the number of '1's in a 255-bit input vector and outputs the count as an 8-bit number.

[Input Signal Description]:
in[254:0]: A 255-bit input signal where each bit can be either '0' or '1'.

[Output Signal Description]:
out[7:0]: An 8-bit output signal representing the count of '1's present in the input vector.

[Design Detail]: 
module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",Popcount255.txt,Verilog_Practice\Popcount255.txt
"[Keyword]: Popcount3

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit counts the number of '1's in a 3-bit input vector and outputs the count as a 2-bit binary number.

[Input Signal Description]:
in[2:0]: A 3-bit input signal representing a binary number, where each bit can be either 0 or 1.

[Output Signal Description]:
out[1:0]: A 2-bit output signal representing the count of '1's present in the input signal 'in'.

[Design Detail]: 
module topmodule( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",Popcount3.txt,Verilog_Practice\Popcount3.txt
"[Keyword]: Reduction

[Design Category]: Combinational Logic

[Design Function Description]:
This design calculates the parity of an 8-bit input vector. The parity is determined by performing a bitwise XOR operation across all bits of the input. The output is 1 if the number of 1s in the input is odd, and 0 if the number of 1s is even.

[Input Signal Description]:
in[7:0]: An 8-bit input signal whose parity is to be calculated.

[Output Signal Description]:
parity: A single-bit output signal that represents the parity of the input. It is 1 if the number of 1s in the input is odd, and 0 if even.

[Design Detail]: 
module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",Reduction.txt,Verilog_Practice\Reduction.txt
"[Keyword]: review2015 count1k

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 10-bit binary counter that counts from 0 to 999. The counter increments on each positive edge of the clock signal. If the counter reaches 999, it resets to 0 on the next clock cycle. Additionally, the counter can be reset to 0 at any time using the reset signal.

[Input Signal Description]:
clk: Clock signal that triggers the counter to increment on its positive edge.
reset: Asynchronous reset signal that sets the counter to 0 when asserted.

[Output Signal Description]:
q[9:0]: A 10-bit output representing the current count value of the counter, ranging from 0 to 999.

[Design Detail]: 
module topmodule (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",review2015 count1k.txt,Verilog_Practice\review2015 count1k.txt
"[Keyword]: review2015 fancytimer

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) that processes input data to load a 4-bit count value and then counts down from that value. The FSM transitions through various states based on the input data and acknowledges signals, and it includes a synchronous reset. The circuit outputs whether it is currently counting and when it has completed the counting process.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing state transitions and operations.
- `reset`: Synchronous reset signal to initialize the state and counters.
- `data`: Input data signal used to load the count value and determine state transitions.
- `ack`: Acknowledgment signal used to transition from the waiting state back to the idle state.

[Output Signal Description]:
- `count[3:0]`: 4-bit output representing the current count value being processed.
- `counting`: Output signal indicating whether the FSM is in the counting state.
- `done`: Output signal indicating that the FSM has completed the counting process and is in the waiting state.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, nextstate;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   nextstate = data ? s1 : idle;
            s1:     nextstate = data ? s2 : idle;
            s2:     nextstate = data ? s2 : s3;
            s3:     nextstate = data ? b0 : idle;
            b0:     nextstate = b1;
            b1:     nextstate = b2;
            b2:     nextstate = b3;
            b3:     nextstate = counts;
            counts: nextstate = (count == 0 && counter == 999) ? waiting : counts;
            waiting:nextstate = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= nextstate;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule
```",review2015 fancytimer.txt,Verilog_Practice\review2015 fancytimer.txt
"[Keyword]: review2015 fsm

[Design Category]: Control Circuits

[Design Function Description]:
This design implements a finite state machine (FSM) that detects a specific sequence of input bits (""110"") and then performs a series of operations, including shifting and counting. The FSM transitions through various states based on the input data and control signals, ultimately signaling when the sequence has been detected and processed.

[Input Signal Description]:
- `clk`: Clock signal for synchronizing state transitions.
- `reset`: Synchronous reset signal to initialize the FSM to the idle state.
- `data`: Input data signal used to detect the sequence ""110"".
- `donecounting`: Input signal indicating the completion of a counting operation.
- `ack`: Acknowledgment signal to reset the FSM back to the idle state after processing.

[Output Signal Description]:
- `shiftena`: Output signal that enables shifting operations when the FSM is in states b0, b1, b2, or b3.
- `counting`: Output signal indicating that the FSM is in the counting state.
- `done`: Output signal indicating that the FSM has completed its operations and is in the waiting state.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shiftena,
    output counting,
    input donecounting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, nextstate;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    nextstate = idle;
                else
                    nextstate = s1;
            end
            s1: begin
                if(data==1'b0)
                    nextstate = idle;
                else
                    nextstate = s11;
            end
            s11: begin
                if(data==1'b0)
                    nextstate = s110;
                else
                    nextstate = s11;
            end
            s110: begin
                if(data==1'b0)
                    nextstate = idle;
                else
                    nextstate = b0;
            end
            b0:     nextstate = b1;
            b1:     nextstate = b2;
            b2:     nextstate = b3;
            b3:     nextstate = count;
            count: begin
                if(donecounting)
                    nextstate = waiting;
                else
                    nextstate = count;
            end
            waiting: begin
                if(ack)
                    nextstate = idle;
                else
                    nextstate = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= nextstate;
    end
    
    assign  shiftena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule
```",review2015 fsm.txt,Verilog_Practice\review2015 fsm.txt
"[Keyword]: review2015 fsmonehot

[Design Category]: Control Circuits

[Design Function Description]:
This design is a state machine that manages transitions between different states based on input signals. It uses a one-hot encoding scheme for the states and determines the next state and control signals based on the current state and inputs. The circuit is likely part of a larger system that requires sequential control flow, such as a sequence detector or a controller for a specific process.

[Input Signal Description]:
- `d`: A single-bit input signal that influences state transitions, likely representing a data input or condition.
- `donecounting`: A single-bit input signal indicating whether a counting process has completed.
- `ack`: A single-bit input signal used to acknowledge or confirm a condition, affecting state transitions.
- `state[9:0]`: A 10-bit one-hot encoded signal representing the current state of the state machine. Each bit corresponds to a specific state.

[Output Signal Description]:
- `B3next`: A signal indicating the next state should be B3, based on the current state.
- `Snext`: A signal indicating the next state should be S, based on the current state and inputs.
- `S1next`: A signal indicating the next state should be S1, based on the current state and inputs.
- `Countnext`: A signal indicating the next state should be Count, based on the current state and inputs.
- `Waitnext`: A signal indicating the next state should be Wait, based on the current state and inputs.
- `done`: A signal indicating the state machine is in the Wait state, often used to signal completion.
- `counting`: A signal indicating the state machine is in the Count state, often used to signal an active counting process.
- `shiftena`: A signal enabling a shift operation, active when the state machine is in any of the B0, B1, B2, or B3 states.

[Design Detail]: 
```verilog
module topmodule(
    input d,
    input donecounting,
    input ack,
    input [9:0] state,    // 10-bit one-hot current state
    output B3next,
    output Snext,
    output S1next,
    output Countnext,
    output Waitnext,
    output done,
    output counting,
    output shiftena
); //

    // You may use these parameters to access state bits using e.g., state[B2] instead of state[6].
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;

    assign B3next = state[B2];
    assign Snext = (state[S] & (~d)) || (state[S1] & (~d)) || (state[S110] & (~d)) || (state[Wait] & ack);
    assign S1next = state[S] & d;
    assign Countnext = state[B3] || (state[Count] & (~donecounting));
    assign Waitnext = (state[Count] & (donecounting)) || (state[Wait] & (~ack));
    assign done = state[Wait];
    assign counting = state[Count];
    assign shiftena = state[B0] || state[B1] || state[B2] || state[B3];

endmodule
```",review2015 fsmonehot.txt,Verilog_Practice\review2015 fsmonehot.txt
"[Keyword]: review2015 fsmseq

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with five states (a, b, c, d, e). The FSM transitions between states based on the input signal `data`. The output signal `startshifting` is asserted when the FSM reaches state `e`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `reset`: Synchronous reset signal that initializes the FSM to state `a` when asserted.
- `data`: Input signal that influences state transitions within the FSM.

[Output Signal Description]:
- `startshifting`: Output signal that is asserted (set to high) when the FSM is in state `e`, indicating that a specific condition has been met.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output startshifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, nextstate;

    always @(*) begin
        case (state)
            a: nextstate = data ? b : a;
            b: nextstate = data ? c : a;
            c: nextstate = data ? c : d;
            d: nextstate = data ? e : a;
            e: nextstate = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= nextstate;
        end
    end

    assign startshifting = (state == e);

endmodule
```",review2015 fsmseq.txt,Verilog_Practice\review2015 fsmseq.txt
"[Keyword]: review2015 fsmshifthigh

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a finite state machine (FSM) with five states. The FSM transitions through the states c0, c1, c2, c3, and c4 in a sequential manner. The state transitions are controlled by a synchronous reset signal. The output signal `shiftena` is enabled when the FSM is in any state other than c0.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize state transitions.
- `reset`: Synchronous reset signal that, when asserted, causes the FSM to transition from state c0 to state c1.

[Output Signal Description]:
- `shiftena`: A signal that is asserted (set to true) when the FSM is in states c1, c2, c3, or c4, indicating that a shift operation should be enabled.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input reset,      // Synchronous reset
    output shiftena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, nextstate;
    
    always@(*) begin
        case(state)
            c0:     nextstate = reset ? c1 : c0;
            c1:     nextstate = c2;
            c2:     nextstate = c3;
            c3:     nextstate = c4;
            c4:     nextstate = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= nextstate; 
    end
    
    assign shiftena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule
```",review2015 fsmshifthigh.txt,Verilog_Practice\review2015 fsmshifthigh.txt
"[Keyword]: review2015 shiftcount

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 4-bit shift register with additional functionality to decrement the register value. The register can either shift its contents left by one bit and load a new bit from the input, or decrement its value by 1, depending on the control signals.

[Input Signal Description]:
- clk: Clock signal that triggers the operations on the rising edge.
- shiftena: Control signal to enable the shift operation. When high, the register shifts left and loads the new bit from the 'data' input.
- countena: Control signal to enable the count operation. When high, the register decrements its current value by 1.
- data: Input data bit to be shifted into the register when 'shiftena' is high.

[Output Signal Description]:
- q[3:0]: 4-bit output representing the current state of the register. It reflects the result of either the shift operation or the decrement operation based on the control signals.

[Design Detail]: 
module topmodule (
    input clk,
    input shiftena,
    input countena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shiftena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (countena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",review2015 shiftcount.txt,Verilog_Practice\review2015 shiftcount.txt
"[Keyword]: Ringer

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is designed to control a mobile device's alert system, determining whether the device should ring or vibrate based on the input signals. It uses simple logic to decide between activating a ringer or a motor for vibration.

[Input Signal Description]:
- ring: A signal indicating whether the device should alert the user (1 for alert, 0 for no alert).
- vibratemode: A signal indicating the mode of alert (1 for vibrate mode, 0 for ring mode).

[Output Signal Description]:
- ringer: An output signal that activates the ringer to make sound when the device is in ring mode and the ring signal is active.
- motor: An output signal that activates the motor to vibrate when the device is in vibrate mode and the ring signal is active.

[Design Detail]: 
module topmodule (
    input ring,
    input vibratemode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibratemode);
    assign motor = ring & vibratemode;

endmodule",Ringer.txt,Verilog_Practice\Ringer.txt
"[Keyword]: Rotate100high

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 100-bit shift register with load and enable control. The register can load new data or shift its contents left or right based on the enable signals.

[Input Signal Description]:
- `clk`: Clock signal that triggers the register operations on its rising edge.
- `load`: Control signal to load new data into the register when high.
- `ena[1:0]`: 2-bit enable signal that determines the direction of the shift operation. If `ena` is `01`, the register shifts right; if `ena` is `10`, the register shifts left.
- `data[99:0]`: 100-bit input data to be loaded into the register when `load` is high.

[Output Signal Description]:
- `q[99:0]`: 100-bit output representing the current state of the register. It holds the loaded data or the shifted data based on the control signals.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input load,
    input [1:0] ena,
    input [99:0] data,
    output reg [99:0] q); 

    always @(posedge clk) begin
        if(load == 1) begin
            q = data;
        end
        else begin
            if(ena[0]^ena[1]) begin
                case (ena)
                    /*right*/
                    2'b01: begin
                        q <= {q[0], q[99:1]};
                    end
                    /*left*/
                    2'b10: begin
                        q <= {q[98:0], q[99]};
                    end
                endcase
            end
        end
    end
    
endmodule
```",Rotate100high.txt,Verilog_Practice\Rotate100high.txt
"[Keyword]: Rule110

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 512-bit shift register with a load capability. When the load signal is high, the register loads the input data. When the load signal is low, the register performs a specific bitwise operation on its current contents, which involves a combination of XOR, AND, and OR operations with shifted versions of the register's contents.

[Input Signal Description]:
- clk: Clock signal that triggers the register operations on its rising edge.
- load: Control signal that determines whether to load new data into the register or perform the bitwise operation.
- data[511:0]: 512-bit input data that is loaded into the register when the load signal is high.

[Output Signal Description]:
- q[511:0]: 512-bit output that represents the current state of the register. It either holds the loaded data or the result of the bitwise operation, depending on the state of the load signal.

[Design Detail]: 
module topmodule(
    input clk,
    input load,
    input [511:0] data,
    output reg [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",Rule110.txt,Verilog_Practice\Rule110.txt
"[Keyword]: Rule90

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a shift register with a specific feedback mechanism. When the load signal is high, the register loads the input data. Otherwise, it performs a bitwise operation involving a right shift and an XOR operation on the stored data.

[Input Signal Description]:
- clk: Clock signal that triggers the operations on the rising edge.
- load: Control signal that determines whether to load new data or perform the shift and XOR operation.
- data[511:0]: 512-bit input data to be loaded into the register when the load signal is high.

[Output Signal Description]:
- q[511:0]: 512-bit output that holds the current state of the register. It either reflects the loaded data or the result of the shift and XOR operation.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input load,
    input [511:0] data,
    output reg [511:0] q );
    
    always @(posedge clk) begin
        if(load) begin
            q <= data;    
        end
        else begin
            q <= {1'b0, q[511:1]} ^ {q[510:0], 1'b0};    
        end
    end

endmodule
```",Rule90.txt,Verilog_Practice\Rule90.txt
"[Keyword]: Shift18

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 64-bit arithmetic shift register with load and enable functionality. The register can perform left or right shifts by 1 or 8 bits, depending on the control signals. It also supports loading a new value into the register.

[Input Signal Description]:
- `clk`: Clock signal that triggers the register operations on its rising edge.
- `load`: Control signal to load the input data into the register when high.
- `ena`: Enable signal that allows shifting operations when high.
- `amount[1:0]`: 2-bit control signal that determines the shift operation:
  - `00`: Shift left by 1 bit.
  - `01`: Shift left by 8 bits.
  - `10`: Arithmetic shift right by 1 bit.
  - `11`: Arithmetic shift right by 8 bits.
- `data[63:0]`: 64-bit input data to be loaded into the register when `load` is high.

[Output Signal Description]:
- `q[63:0]`: 64-bit output register that holds the current value after load or shift operations.

[Design Detail]: 
```verilog
module topmodule(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule
```",Shift18.txt,Verilog_Practice\Shift18.txt
"[Keyword]: Shift4

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a 4-bit shift register with asynchronous reset, load, and enable functionalities. The register can load a 4-bit input value, shift its contents right by one bit, or reset to zero based on control signals.

[Input Signal Description]:
- clk: Clock signal for synchronizing the operations.
- areset: Asynchronous active-high reset signal that sets the output to zero when high.
- load: Control signal to load the input data into the register when high.
- ena: Enable signal that allows the register to shift its contents right by one bit when high.
- data[3:0]: 4-bit input data to be loaded into the register when the load signal is high.

[Output Signal Description]:
- q[3:0]: 4-bit output register that holds the current state of the shift register. It can be loaded with new data, shifted right, or reset to zero based on the control signals.

[Design Detail]: 
module topmodule(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",Shift4.txt,Verilog_Practice\Shift4.txt
"[Keyword]: Simcircui10high

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple sequential circuit that uses a clock signal to update its state based on the comparison of two input signals, `a` and `b`. The output `q` is determined by the current state and the comparison result of `a` and `b`.

[Input Signal Description]:
- `clk`: Clock signal used to synchronize the state updates.
- `a`: Input signal used for comparison.
- `b`: Input signal used for comparison.

[Output Signal Description]:
- `q`: Output signal that reflects the current state or its complement based on the comparison of `a` and `b`.
- `state`: Internal state of the circuit that is updated on the rising edge of the clock when `a` equals `b`.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input a,
    input b,
    output q,
    output state
);

    always @ (posedge clk) begin
        if(a == b)
            state <= a;
        else
            state <= state;
    end
    
    assign q = (a == b) ? state : (~state);
    
endmodule
```",Simcircui10high.txt,Verilog_Practice\Simcircui10high.txt
"[Keyword]: Simcircuit1

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a simple 2-input AND gate. It takes two binary inputs and produces a single binary output that is true only when both inputs are true.

[Input Signal Description]:
a: A binary input signal.
b: A binary input signal.

[Output Signal Description]:
q: A binary output signal that is the logical AND of inputs a and b.

[Design Detail]: 
module topmodule (
    input a,
    input b,
    output q
);
    assign q = a && b; // Fix me
endmodule",Simcircuit1.txt,Verilog_Practice\Simcircuit1.txt
"[Keyword]: Simcircuit2

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is designed to compute the sum of four 1-bit inputs and produce an output based on the parity of the sum. Specifically, the output `q` is set to 0 if the sum is either 1 or 3, and to 1 otherwise.

[Input Signal Description]:
- `a`: 1-bit input signal.
- `b`: 1-bit input signal.
- `c`: 1-bit input signal.
- `d`: 1-bit input signal.

These inputs are used to calculate the sum, which determines the output.

[Output Signal Description]:
- `q`: 1-bit output signal. It outputs 0 if the sum of the inputs is 1 or 3, and 1 otherwise.

[Design Detail]: 
```verilog
module topmodule (
    input a,
    input b,
    input c,
    input d,
    output q
);

    reg [2:0] sum;
    assign sum = a + b + c + d;
    assign q = (sum == 1 || sum == 3) ? 0 : 1; // Fix me

endmodule
```",Simcircuit2.txt,Verilog_Practice\Simcircuit2.txt
"[Keyword]: Simcircuit3

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit implements a logical expression that combines four input signals using OR and AND operations. Specifically, it outputs a high signal if either 'a' or 'b' is high, and either 'c' or 'd' is high.

[Input Signal Description]:
- a: A single-bit input signal.
- b: A single-bit input signal.
- c: A single-bit input signal.
- d: A single-bit input signal.

[Output Signal Description]:
- q: A single-bit output signal that results from the logical expression (a || b) && (c || d).

[Design Detail]: 
module topmodule (
    input a,
    input b,
    input c,
    input d,
    output q
);
    assign q = (a || b) && (c || d); // Fix me
endmodule",Simcircuit3.txt,Verilog_Practice\Simcircuit3.txt
"[Keyword]: Simcircuit4

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is intended to perform a logical operation on the input signals. The current implementation assigns the output `q` to the logical OR of inputs `b` and `c`. However, the comment ""Fix me"" suggests that the intended functionality might be different or incomplete.

[Input Signal Description]:
- `a`: An input signal, currently unused in the logic.
- `b`: An input signal used in the logical OR operation.
- `c`: An input signal used in the logical OR operation.
- `d`: An input signal, currently unused in the logic.

[Output Signal Description]:
- `q`: The output signal, which is currently assigned the result of the logical OR operation between inputs `b` and `c`.

[Design Detail]: 
```verilog
module topmodule (
    input a,
    input b,
    input c,
    input d,
    output q );//

    assign q = (b || c); // Fix me

endmodule
```

Note: The design might require additional logic or corrections based on the intended functionality, which is not fully clear from the provided code.",Simcircuit4.txt,Verilog_Practice\Simcircuit4.txt
"[Keyword]: Simcircuit5

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 4-bit wide, 5-to-1 multiplexer. The output `q` is selected from one of the four 4-bit inputs (`a`, `b`, `d`, `e`) based on the value of the 4-bit input `c`. If `c` is 0, 1, 2, or 3, the corresponding input is selected. If `c` is any other value, the output `q` is set to 15 (binary 1111).

[Input Signal Description]:
- `a[3:0]`: A 4-bit input signal.
- `b[3:0]`: A 4-bit input signal.
- `c[3:0]`: A 4-bit control signal used to select which input to pass to the output.
- `d[3:0]`: A 4-bit input signal.
- `e[3:0]`: A 4-bit input signal.

[Output Signal Description]:
- `q[3:0]`: A 4-bit output signal that reflects the value of one of the inputs (`a`, `b`, `d`, `e`) based on the value of `c`, or is set to 15 if `c` is not 0, 1, 2, or 3.

[Design Detail]: 
```verilog
module topmodule (
    input [3:0] a,
    input [3:0] b,
    input [3:0] c,
    input [3:0] d,
    input [3:0] e,
    output reg [3:0] q );
    
    always @ (*) begin
        case(c)
            0: q = b;
            1: q = e;
            2: q = a;
            3: q = d;
            default: q = 15;
        endcase
    end

endmodule
```",Simcircuit5.txt,Verilog_Practice\Simcircuit5.txt
"[Keyword]: Simcircuit6

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 3-to-8 decoder with a 16-bit output. Based on the 3-bit input, it outputs one of eight predefined 16-bit values.

[Input Signal Description]:
a[2:0]: A 3-bit input signal that selects one of the eight predefined 16-bit values.

[Output Signal Description]:
q[15:0]: A 16-bit output signal that corresponds to the value selected by the input signal 'a'.

[Design Detail]: 
module topmodule (
    input [2:0] a,
    output [15:0] q ); 

    always @ (*) begin
        case(a)
            0: q = 16'h1232;
            1: q = 16'haee0;
            2: q = 16'h27d4;
            3: q = 16'h5a0e;
            4: q = 16'h2066;
            5: q = 16'h64ce;
            6: q = 16'hc526;
            7: q = 16'h2f19;
        endcase
    end
    
endmodule",Simcircuit6.txt,Verilog_Practice\Simcircuit6.txt
"[Keyword]: Simcircuit7

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple D flip-flop with an inverted input. On each rising edge of the clock signal, the output `q` is updated to be the logical NOT of the input `a`.

[Input Signal Description]:
- `clk`: Clock signal that triggers the flip-flop on its rising edge.
- `a`: Input signal whose inverted value is stored in the flip-flop on the rising edge of the clock.

[Output Signal Description]:
- `q`: Output signal that holds the inverted value of `a` after each rising edge of the clock.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input a,
    output q );
    
    always @ (posedge clk) begin
        q <= ~a;
    end

endmodule
```",Simcircuit7.txt,Verilog_Practice\Simcircuit7.txt
"[Keyword]: Simcircuit8

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple sequential logic circuit that uses a clock signal to control the assignment of values to the outputs. When the clock signal is high, the output `p` is assigned the value of input `a`. When the clock signal is low, the output `q` is assigned the value of `p`.

[Input Signal Description]:
- `clock`: A control signal that determines which operation to perform. When high, it assigns the value of `a` to `p`. When low, it assigns the value of `p` to `q`.
- `a`: An input signal whose value is assigned to `p` when the clock is high.

[Output Signal Description]:
- `p`: An output signal that holds the value of `a` when the clock is high.
- `q`: An output signal that holds the value of `p` when the clock is low.

[Design Detail]: 
```verilog
module topmodule (
    input clock,
    input a,
    output p,
    output q );
    
    always @ (*) begin
        if(clock == 1) begin
            p = a;
        end
        else begin
            q = p;
        end
    end

endmodule
```",Simcircuit8.txt,Verilog_Practice\Simcircuit8.txt
"[Keyword]: Simcircuit9

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a sequential logic circuit that updates a 4-bit output `q` based on the input signal `a` and a clock signal `clk`. When `a` is high, `q` is set to 4. Otherwise, `q` increments by 1 on each clock cycle until it reaches 6, at which point it resets to 0.

[Input Signal Description]:
- `clk`: Clock signal that triggers the update of the output `q` on its rising edge.
- `a`: Control signal that determines whether `q` is set to 4 or incremented.

[Output Signal Description]:
- `q[3:0]`: A 4-bit output that is either set to 4 when `a` is high or incremented on each clock cycle until it reaches 6, after which it resets to 0.

[Design Detail]: 
```verilog
module topmodule (
    input clk,
    input a,
    output reg [3:0] q 
);
    
    always @ (posedge clk) begin
        if(a == 1) begin
            q = 4;
        end
        else begin
            q = (q < 6) ? (q + 1) : 0;
        end
    end

endmodule
```",Simcircuit9.txt,Verilog_Practice\Simcircuit9.txt
"[Keyword]: Stepone

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a simple constant output generator that always outputs a logic high ('1').

[Input Signal Description]:
There are no input signals for this design as it is a constant output generator.

[Output Signal Description]:
one: A single-bit output that is always set to logic high ('1').

[Design Detail]: 
module topmodule( output one );
    // Insert your code here
    assign one = 1'b1;
endmodule",Stepone.txt,Verilog_Practice\Stepone.txt
"[Keyword]: Tband

[Design Category]: Combinational Logic

[Design Function Description]:
The design is a simple testbench for a 2-input AND gate. It applies different 2-bit input combinations to the AND gate and observes the output.

[Input Signal Description]:
in[1:0]: A 2-bit input signal that changes over time to test the AND gate with different input combinations.

[Output Signal Description]:
out: The output of the AND gate, which will be the logical AND of the two input bits.

[Design Detail]: 
module topmodule();
    reg [1:0] in;
    reg out;
    initial begin
        in = 2'b0;
        #10 in = 2'b01;
        #10 in = 2'b10;
        #10 in = 2'b11;
    end
    andgate gate1(in, out);
endmodule",Tband.txt,Verilog_Practice\Tband.txt
"[Keyword]: Tbclock

[Design Category]: Sequential Logic

[Design Function Description]:
This design generates a clock signal with a specified time period. The clock signal toggles its state every half of the time period, effectively creating a square wave. This clock signal is then used to drive a device under test (DUT).

[Input Signal Description]:
There are no external input signals in this module. The clock signal is internally generated.

[Output Signal Description]:
There are no direct output signals from this module. However, the generated clock signal is used as an input to the DUT instance.

[Design Detail]: 
```verilog
module topmodule ( );
    parameter timeperiod = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(timeperiod / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule
```",Tbclock.txt,Verilog_Practice\Tbclock.txt
"[Keyword]: Tbtb1

[Design Category]: Sequential Logic

[Design Function Description]:
This design is a simple testbench that generates a sequence of input patterns over time. It uses an initial block to simulate changes in the output signals A and B at specific time intervals.

[Input Signal Description]:
There are no explicit input signals in this module. The design is focused on generating output patterns over time.

[Output Signal Description]:
A: A reg type output signal that changes its value over time according to the specified timing in the initial block.
B: A reg type output signal that also changes its value over time according to the specified timing in the initial block.

[Design Detail]: 
module topmodule ( output reg A, output reg B );//
    
    // generate input patterns here
    initial begin
        A = 0;
        B = 0;
        #10 A = 1;
        #5  B = 1;
        #5  A = 0;
        #20 B = 0;
    end

endmodule",Tbtb1.txt,Verilog_Practice\Tbtb1.txt
"[Keyword]: Tbtb2

[Design Category]: Sequential Logic

[Design Function Description]:
The design is a testbench for a sequential circuit module named `q7`. It generates a clock signal and provides a sequence of input signals to test the behavior of the `q7` module. The testbench initializes the inputs and changes them at specific time intervals to observe the output behavior of the `q7` module.

[Input Signal Description]:
- `clk`: A clock signal that toggles every 5 time units, used to synchronize the operations in the `q7` module.
- `in`: A single-bit input signal that changes at specified intervals to test different scenarios in the `q7` module.
- `s[2:0]`: A 3-bit selection or control signal that changes at specified intervals to test different states or conditions in the `q7` module.

[Output Signal Description]:
- `out`: The output signal from the `q7` module, which is observed to verify the correct operation of the module under different input conditions.

[Design Detail]: 
```verilog
module topmodule();
    reg clk, in;
    reg [2:0] s;
    reg out;
    initial begin
        clk = 0;
        s = 2;
        in = 0;
        #10 s = 6;
        #10 begin
            s = 2;
            in = 1;
        end
        #10 begin
            s = 7;
            in = 0;
        end
        #10 begin
            s = 0;
            in = 1;
        end
        #30 in = 0;
    end
    always begin
        #5 clk = ~clk;
    end
    
    q7 q7test(clk, in, s, out);
    
endmodule
```",Tbtb2.txt,Verilog_Practice\Tbtb2.txt
"[Keyword]: Tbtff

[Design Category]: Sequential Logic

[Design Function Description]:
This design implements a testbench for a T flip-flop (TFF). The T flip-flop toggles its output on each clock cycle when the T input is high, and it can be reset asynchronously.

[Input Signal Description]:
- clk: Clock signal used to drive the T flip-flop.
- reset: Asynchronous reset signal to initialize or reset the flip-flop.
- t: Toggle input signal for the T flip-flop. When high, it causes the flip-flop to toggle its state on each clock cycle.

[Output Signal Description]:
- q: Output of the T flip-flop, representing the current state of the flip-flop.

[Design Detail]: 
module topmodule ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",Tbtff.txt,Verilog_Practice\Tbtff.txt
"[Keyword]: Thermostat

[Design Category]: Control Circuits

[Design Function Description]:
This circuit is a simple climate control system that manages a heater, air conditioner, and fan based on temperature conditions and mode settings. It decides whether to turn on the heater or air conditioner based on the current mode and temperature inputs, and controls the fan accordingly.

[Input Signal Description]:
- toocold: A signal indicating if the temperature is too cold.
- toohot: A signal indicating if the temperature is too hot.
- mode: A signal indicating the current mode of operation (e.g., heating or cooling mode).
- fanon: A signal indicating if the fan should be forced on regardless of other conditions.

[Output Signal Description]:
- heater: A signal to activate the heater when the system is in heating mode and the temperature is too cold.
- aircon: A signal to activate the air conditioner when the system is in cooling mode and the temperature is too hot.
- fan: A signal to activate the fan when either the heater or air conditioner is on, or if the fan is forced on.

[Design Detail]: 
module topmodule (
    input toocold,
    input toohot,
    input mode,
    input fanon,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & toocold;
    assign aircon = (~mode) & toohot;
    assign fan = (heater | aircon) | fanon;
    
endmodule",Thermostat.txt,Verilog_Practice\Thermostat.txt
"[Keyword]: Truthtable1

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a combinational logic circuit that evaluates a 3-bit input and produces a single output. The output is determined based on whether the 3-bit input represents a prime number (2, 3, 5, 7) or not (0, 1, 4, 6).

[Input Signal Description]:
- x3, x2, x1: These are the three input signals that form a 3-bit binary number. The combination of these inputs is used to determine the output.

[Output Signal Description]:
- f: This is the output signal that is set to 1 if the 3-bit input represents a prime number (2, 3, 5, 7) and set to 0 otherwise.

[Design Detail]: 
```verilog
module topmodule( 
    input x3,
    input x2,
    input x1,  // three inputs
    output reg f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule
```",Truthtable1.txt,Verilog_Practice\Truthtable1.txt
"[Keyword]: TwoGatesq4g

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a logic circuit that performs a specific combination of XOR and XNOR operations on three input signals. It first computes the XNOR of `in1` and `in2`, and then XORs the result with `in3`.

[Input Signal Description]:
- `in1`: A single-bit input signal.
- `in2`: A single-bit input signal.
- `in3`: A single-bit input signal.

[Output Signal Description]:
- `out`: A single-bit output signal that is the result of the operation `(~(in1 ^ in2)) ^ in3`.

[Design Detail]: 
```verilog
module topmodule (
    input in1,
    input in2,
    input in3,
    output out
);

    assign out = (~(in1 ^ in2)) ^ in3;
    
endmodule
```",TwoGatesq4g.txt,Verilog_Practice\TwoGatesq4g.txt
"[Keyword]: Vector0

[Design Category]: Combinational Logic

[Design Function Description]:
This design is a simple signal routing circuit that takes a 3-bit input vector and directly assigns it to a 3-bit output vector. Additionally, it breaks out each bit of the output vector into separate output signals.

[Input Signal Description]:
vec[2:0]: A 3-bit input vector that serves as the source of the data to be routed to the outputs.

[Output Signal Description]:
outv[2:0]: A 3-bit output vector that directly mirrors the input vector.
o0: A single-bit output that corresponds to the least significant bit of the input vector.
o1: A single-bit output that corresponds to the middle bit of the input vector.
o2: A single-bit output that corresponds to the most significant bit of the input vector.

[Design Detail]: 
module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0
);
    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
endmodule",Vector0.txt,Verilog_Practice\Vector0.txt
"[Keyword]: Vector100r

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is designed to reverse the order of a 100-bit input vector. It takes a 100-bit input and outputs a 100-bit vector where the bits are in reverse order compared to the input.

[Input Signal Description]:
in[99:0]: A 100-bit input signal that represents the data to be reversed.

[Output Signal Description]:
out[99:0]: A 100-bit output signal that contains the reversed order of the input bits.

[Design Detail]: 
module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",Vector100r.txt,Verilog_Practice\Vector100r.txt
"[Keyword]: Vector2

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit rearranges the bytes of a 32-bit input signal. It takes the input and swaps the positions of its bytes, effectively reversing the order of the bytes.

[Input Signal Description]:
in[31:0]: A 32-bit input signal composed of four 8-bit bytes.

[Output Signal Description]:
out[31:0]: A 32-bit output signal where the bytes of the input signal are reversed in order.

[Design Detail]: 
module top_module( 
    input [31:0] in,
    output [31:0] out );

    // Rearrange the bytes of the input signal
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",Vector2.txt,Verilog_Practice\Vector2.txt
"[Keyword]: Vector3

[Design Category]: Combinational Logic

[Design Function Description]:
This design concatenates six 5-bit input signals and a 2-bit constant to form four 8-bit output signals. The concatenation is done in such a way that the total number of bits is 32, which is then divided into four 8-bit outputs.

[Input Signal Description]:
- a[4:0]: 5-bit input signal
- b[4:0]: 5-bit input signal
- c[4:0]: 5-bit input signal
- d[4:0]: 5-bit input signal
- e[4:0]: 5-bit input signal
- f[4:0]: 5-bit input signal

[Output Signal Description]:
- w[7:0]: 8-bit output signal, part of the concatenated result
- x[7:0]: 8-bit output signal, part of the concatenated result
- y[7:0]: 8-bit output signal, part of the concatenated result
- z[7:0]: 8-bit output signal, part of the concatenated result

[Design Detail]: 
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z
);
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
endmodule",Vector3.txt,Verilog_Practice\Vector3.txt
"[Keyword]: Vector4

[Design Category]: Combinational Logic

[Design Function Description]:
This design is a sign-extension circuit that takes an 8-bit input and extends it to a 32-bit output by replicating the sign bit (the most significant bit of the input) 24 times, followed by the original 8-bit input.

[Input Signal Description]:
in[7:0]: An 8-bit input signal that represents a signed integer in 2's complement form.

[Output Signal Description]:
out[31:0]: A 32-bit output signal that is the sign-extended version of the input, where the most significant 24 bits are filled with the sign bit of the input, followed by the original 8-bit input.

[Design Detail]: 
module top_module (
    input [7:0] in,
    output [31:0] out
);
    assign out = {{24{in[7]}}, in};
endmodule",Vector4.txt,Verilog_Practice\Vector4.txt
"[Keyword]: Vector5

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit performs bitwise operations on the input signals to generate a 25-bit output. Each 5-bit segment of the output is derived by performing a bitwise NOT operation on a repeated input signal and then XORing it with a vector composed of all input signals.

[Input Signal Description]:
a, b, c, d, e: Single-bit input signals used to generate the output through bitwise operations.

[Output Signal Description]:
out[24:0]: A 25-bit output signal composed of five 5-bit segments, each generated by applying bitwise operations on the input signals.

[Design Detail]: 
module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",Vector5.txt,Verilog_Practice\Vector5.txt
"[Keyword]: Vectorgates

[Design Category]: Combinational Logic

[Design Function Description]:
This design performs bitwise OR, logical OR, and bitwise NOT operations on two 3-bit input vectors. It outputs the results of these operations.

[Input Signal Description]:
a[2:0]: A 3-bit input vector.
b[2:0]: Another 3-bit input vector.

[Output Signal Description]:
out_or_bitwise[2:0]: The result of the bitwise OR operation between inputs a and b.
out_or_logical: The result of the logical OR operation between inputs a and b, which checks if either a or b is non-zero.
out_not[5:0]: A 6-bit output where the upper 3 bits are the bitwise NOT of b and the lower 3 bits are the bitwise NOT of a.

[Design Detail]: 
module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",Vectorgates.txt,Verilog_Practice\Vectorgates.txt
"[Keyword]: Vectorr

[Design Category]: Combinational Logic

[Design Function Description]:
The circuit is a simple wire assignment that directly maps each bit of an 8-bit input vector to the corresponding bit of an 8-bit output vector. It effectively passes the input to the output without any modification or transformation.

[Input Signal Description]:
in[7:0]: An 8-bit input signal that represents the data to be passed through to the output.

[Output Signal Description]:
out[7:0]: An 8-bit output signal that is a direct copy of the input signal.

[Design Detail]: 
module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",Vectorr.txt,Verilog_Practice\Vectorr.txt
"[Keyword]: Wire

[Design Category]: Combinational Logic

[Design Function Description]:
This is a simple buffer circuit that directly transfers the input signal to the output without any modification.

[Input Signal Description]:
in: A single-bit input signal that is passed directly to the output.

[Output Signal Description]:
out: A single-bit output signal that is the same as the input signal.

[Design Detail]: 
module top_module( 
  input in, 
  output out 
);
  assign out = in;
endmodule",Wire.txt,Verilog_Practice\Wire.txt
"[Keyword]: Wire4

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is a simple wire assignment module that directly connects input signals to output signals. It essentially passes the input values to the outputs without any modification or logic operation.

[Input Signal Description]:
a, b, c: These are the input signals to the module. Each is a single-bit input.

[Output Signal Description]:
w, x, y, z: These are the output signals of the module. Each output is directly assigned the value of one of the input signals. Specifically, w is assigned the value of a, x and y are both assigned the value of b, and z is assigned the value of c.

[Design Detail]: 
module top_module( 
    input a, b, c,
    output w, x, y, z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",Wire4.txt,Verilog_Practice\Wire4.txt
"[Keyword]: Wiredecl

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a simple combinational logic circuit that performs a series of logical operations on its inputs. It computes the logical AND of two pairs of inputs and then performs a logical OR on the results. Additionally, it provides both the direct output and its logical negation.

[Input Signal Description]:
- a: A single-bit input signal.
- b: A single-bit input signal.
- c: A single-bit input signal.
- d: A single-bit input signal.

[Output Signal Description]:
- out: The output signal representing the logical OR of the AND results of the input pairs (a & b) and (c & d).
- outn: The output signal representing the logical negation of the 'out' signal.

[Design Detail]: 
```verilog
`defaultnettype none
module topmodule(
    input a,
    input b,
    input c,
    input d,
    output out,
    output outn   ); 
    
    wire wire1, wire2, wire3;
    assign wire1 = a & b;
    assign wire2 = c & d;
    assign wire3 = wire1 | wire2;
    assign out = wire3;
    assign outn = ~wire3;
    
endmodule
```",Wiredecl.txt,Verilog_Practice\Wiredecl.txt
"[Keyword]: Wireq4h

[Design Category]: Combinational Logic

[Design Function Description]:
This is a simple buffer circuit that directly transfers the input signal to the output without any modification.

[Input Signal Description]:
in: A single-bit input signal that is passed directly to the output.

[Output Signal Description]:
out: A single-bit output signal that is the same as the input signal.

[Design Detail]: 
module topmodule (
    input in,
    output out
);
    assign out = in;
endmodule",Wireq4h.txt,Verilog_Practice\Wireq4h.txt
"[Keyword]: Xnorgate

[Design Category]: Combinational Logic

[Design Function Description]:
This design implements a 1-bit XNOR gate. The circuit outputs the logical XNOR of two input signals, which is true when both inputs are the same (either both 0 or both 1).

[Input Signal Description]:
a: A 1-bit input signal.
b: A 1-bit input signal.

[Output Signal Description]:
out: A 1-bit output signal that represents the XNOR of inputs a and b. It is high (1) when both inputs are the same and low (0) otherwise.

[Design Detail]: 
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",Xnorgate.txt,Verilog_Practice\Xnorgate.txt
"[Keyword]: Zero

[Design Category]: Combinational Logic

[Design Function Description]:
This circuit is designed to output a constant logic low signal. It is a simple combinational logic circuit that assigns a constant value of 0 to the output.

[Input Signal Description]:
There are no input signals for this module. It is designed to always output a constant value.

[Output Signal Description]:
zero: A single-bit output signal that is always set to logic low (0).

[Design Detail]: 
module top_module(
    output zero
);
    assign zero = 1'b0;
endmodule",Zero.txt,Verilog_Practice\Zero.txt
