[Keyword]: stream_arbiter_flushable.sv

[Design Category]: Interface Circuits

[Design Function Description]:
The design is a stream arbiter that arbitrates a configurable number of input streams to a single output stream. It uses a valid-ready handshaking protocol similar to AXI4. The arbiter can operate in either a round-robin ("rr") or priority ("prio") mode, ensuring fair access to the output stream. Once the output is valid, it remains stable until the handshake is completed. The design also supports a flush operation to reset the arbitration process.

[Input Signal Description]:
- `clk_i`: Clock input signal for synchronization.
- `rst_ni`: Active-low reset signal to initialize the arbiter.
- `flush_i`: Signal to flush or reset the arbitration process.
- `inp_data_i`: Array of input data streams, each of type `DATA_T`.
- `inp_valid_i`: Array of valid signals corresponding to each input data stream, indicating if the data is valid.
- `oup_ready_i`: Signal indicating if the output stream is ready to accept data.

[Output Signal Description]:
- `inp_ready_o`: Array of ready signals for each input stream, indicating if the arbiter is ready to accept data from the corresponding input.
- `oup_data_o`: Output data stream of type `DATA_T`, selected from one of the input streams.
- `oup_valid_o`: Signal indicating if the output data is valid and ready to be transferred.


[Design Detail]:
// Copyright 2018 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Stream arbiter: Arbitrates a parametrizable number of input streams (i.e., valid-ready
// handshaking with dependency rules as in AXI4) to a single output stream.  Once `oup_valid_o` is
// asserted, `oup_data_o` remains invariant until the output handshake has occurred.  The
// arbitration scheme is fair round-robin tree, see `rr_arb_tree` for details.

module stream_arbiter_flushable #(
    parameter type      DATA_T = logic,   // Vivado requires a default value for type parameters.
    parameter integer   N_INP = -1,       // Synopsys DC requires a default value for parameters.
    parameter           ARBITER = "rr"    // "rr" or "prio"
) (
    input  logic              clk_i,
    input  logic              rst_ni,
    input  logic              flush_i,

    input  DATA_T [N_INP-1:0] inp_data_i,
    input  logic  [N_INP-1:0] inp_valid_i,
    output logic  [N_INP-1:0] inp_ready_o,

    output DATA_T             oup_data_o,
    output logic              oup_valid_o,
    input  logic              oup_ready_i
);

  if (ARBITER == "rr") begin : gen_rr_arb
    rr_arb_tree #(
      .NumIn      (N_INP),
      .DataType   (DATA_T),
      .ExtPrio    (1'b0),
      .AxiVldRdy  (1'b1),
      .LockIn     (1'b1)
    ) i_arbiter (
      .clk_i,
      .rst_ni,
      .flush_i,
      .rr_i   ('0),
      .req_i  (inp_valid_i),
      .gnt_o  (inp_ready_o),
      .data_i (inp_data_i),
      .gnt_i  (oup_ready_i),
      .req_o  (oup_valid_o),
      .data_o (oup_data_o),
      .idx_o  ()
    );

  end else if (ARBITER == "prio") begin : gen_prio_arb
    rr_arb_tree #(
      .NumIn      (N_INP),
      .DataType   (DATA_T),
      .ExtPrio    (1'b1),
      .AxiVldRdy  (1'b1),
      .LockIn     (1'b0)
    ) i_arbiter (
      .clk_i,
      .rst_ni,
      .flush_i,
      .rr_i   ('0),
      .req_i  (inp_valid_i),
      .gnt_o  (inp_ready_o),
      .data_i (inp_data_i),
      .gnt_i  (oup_ready_i),
      .req_o  (oup_valid_o),
      .data_o (oup_data_o),
      .idx_o  ()
    );

  end else begin : gen_arb_error
    `ifndef SYNTHESIS
    $fatal(1, "Invalid value for parameter 'ARBITER'!");
    `endif
  end

endmodule
